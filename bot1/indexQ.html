<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Логистические роботы</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }
        body {
            background: black;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: hidden;
            touch-action: manipulation;
        }
        .container {
            background: black;
            border-radius: 0;
            padding: 8px;
            box-shadow: none;
            text-align: center;
            width: 100vw;
            max-width: 100%;
            max-height: 100vh;
            margin: 4px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }
        .stats-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 0 6px;
            gap: 8px;
            width: 100%;
            max-width: 550px;
        }
        .stat-item {
            background: #ecf0f1;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: bold;
            font-size: min(0.9em, 4vw);
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 1px;
            overflow: hidden;
        }
        .game-board {
            display: grid;
            gap: 1px;
            border: 2px solid #34495e;
            background: #bdc3c7;
            position: relative;
            overflow: hidden;
        }
        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
            border-radius: 1px;
            background-color: #ecf0f1;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            aspect-ratio: 1/1;
        }
        .cell:hover {
            transform: scale(0.95);
            opacity: 0.9;
            z-index: 2;
        }
        /* Фоновые изображения */
        .parking {
            background-image: url('Parking.png');
            background-size: cover; /* contain cover */
        }
        .column {
            background-image: url('Column.png');
            background-size: cover; /* contain cover */
        }
        .charging-station {
            background-image: url('Charging.png');
            background-size: cover; /* contain cover */
        }
        .shelf {
            background-image: url('Shelf.png');
            background-size: contain; /* contain cover */
        }
        /* Изображение робота как отдельный элемент */
        .robot-image {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%; /* было 80% */
            height: 100%; /* было 80% */
            background-size: contain; /* contain cover */
            background-position: center;
            background-repeat: no-repeat;
            z-index: 5;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
            transform: translate(-50%, -50%);
        }
        .charge-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background-color: #ccc;
            z-index: 3;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }
        .charge-level {
            height: 100%;
            transition: width 0.3s ease;
        }
        .charge-level.low { background-color: #e74c3c; }
        .charge-level.medium { background-color: #f39c12; }
        .charge-level.good { background-color: #f1c40f; }
        .charge-level.high { background-color: #27ae60; }
        /* === ГРАДИЕНТНЫЙ ФОН ВЫБРАННОГО РОБОТА === */
        .cell.selected::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000, #ffff00);
            background-size: 200% 200%;
            animation: pulseGradient 2s ease infinite;
            z-index: 1;
            border-radius: 1px;
            pointer-events: none;
        }
        @keyframes pulseGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        /* === КЛЕТКИ НАЗНАЧЕНИЯ: мигают фоном #ecf0f1 ↔ #ffff77 === */
        .target-cell {
            animation: blinkTarget 1s ease infinite;
        }
        @keyframes blinkTarget {
            0%, 100% { background-color: #ecf0f1; }
            50% { background-color: #ffff77; }
        }
        /* === БЕГУЩИЕ ОГНИ (красные) === */
        .blinking-cell {
            position: relative;
            overflow: hidden;
        }
        .moving-part {
            position: absolute;
            background: red;
            pointer-events: none;
        }
        /* === МАРШРУТНАя ЛИНИЯ === */
        .route-line {
            position: absolute;
            background-color: yellow;
            z-index: 4;
            pointer-events: none;
        }
        button {
            background: yellow;
            color: black;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: min(1em, 4.5vw);
            font-weight: bold;
            transition: background 0.3s;
            margin-top: 12px;
            width: 100%;
            max-width: 550px;
        }
        button:hover {
            background: #ffeb3b;
        }
        .splash-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('Ronavi.png') no-repeat center center;
            background-size: cover;
            z-index: 900;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: red;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 10px yellow;
            pointer-events: none;
        }
        .victory-time {
            font-size: 24px;
            margin-top: 20px;
            color: yellow;
        }
        /* Скрытие статистики */
        .stats-container.hidden {
            visibility: hidden;
            height: 0;
            margin-bottom: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="stats-container hidden">
            <div id="moves" class="stat-item">Заряд робота</div>
            <div id="timer" class="stat-item">Время: 00:00</div>
        </div>
        <div class="game-wrapper">
            <div class="game-board" id="game-board">
                <div class="splash-screen"></div>
            </div>
        </div>
        <button id="reset-btn">Новая игра</button>
    </div>
    <script>
        class Pathfinder {
            constructor(game) {
                this.game = game;
            }

            findPath(startRow, startCol, endRow, endCol, isRobotCarryingShelf, forRobotId) {
                const queue = [];
                const visited = new Set();
                const parent = {};
                const localObstacleCells = new Set();
                const endKey = `${endRow},${endCol}`;

                queue.push({ row: startRow, col: startCol });
                visited.add(`${startRow},${startCol}`);

                const directions = [
                    { row: 0, col: 1 },
                    { row: 1, col: 0 },
                    { row: 0, col: -1 },
                    { row: -1, col: 0 }
                ];

                while (queue.length > 0) {
                    const current = queue.shift();
                    const currentKey = `${current.row},${current.col}`;

                    if (current.row === endRow && current.col === endCol) {
                        if (!this.game.cellManager.isCellPassable(endRow, endCol, isRobotCarryingShelf, false, true, forRobotId)) {
                            localObstacleCells.add(endKey);
                            return { route: null, obstacles: Array.from(localObstacleCells) };
                        }

                        const path = [];
                        let step = current;
                        while (step) {
                            path.unshift(step);
                            const stepKey = `${step.row},${step.col}`;
                            step = parent[stepKey];
                        }
                        return { route: path, obstacles: [] };
                    }

                    for (const dir of directions) {
                        const newRow = current.row + dir.row;
                        const newCol = current.col + dir.col;

                        if (newRow < 0 || newRow >= this.game.rows || newCol < 0 || newCol >= this.game.cols) continue;

                        const newKey = `${newRow},${newCol}`;
                        if (visited.has(newKey)) continue;

                        if (newRow === endRow && newCol === endCol) {
                            if (this.game.cellManager.isCellPassable(endRow, endCol, isRobotCarryingShelf, false, true, forRobotId)) {
                                const path = [];
                                const finalStep = { row: newRow, col: newCol };
                                let step = current;
                                while (step) {
                                    path.unshift(step);
                                    const stepKey = `${step.row},${step.col}`;
                                    step = parent[stepKey];
                                }
                                path.push(finalStep);
                                return { route: path, obstacles: [] };
                            } else {
                                localObstacleCells.add(newKey);
                                continue;
                            }
                        }

                        if (this.game.cellManager.isCellPassable(newRow, newCol, isRobotCarryingShelf, false, false, forRobotId)) {
                            visited.add(newKey);
                            parent[newKey] = current;
                            queue.push({ row: newRow, col: newCol });
                        } else {
                            localObstacleCells.add(newKey);
                        }
                    }
                }

                return { route: null, obstacles: Array.from(localObstacleCells) };
            }
        }

        class CellManager {
            constructor(game) {
                this.game = game;
                this.cellCache = new Map();
            }

            cacheCell(row, col, element) {
                const key = `${row},${col}`;
                this.cellCache.set(key, element);
            }

            getCell(row, col) {
                const key = `${row},${col}`;
                if (this.cellCache.has(key)) {
                    return this.cellCache.get(key);
                }

                const cell = this.game.board.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (cell) {
                    this.cacheCell(row, col, cell);
                }

                return cell;
            }

            isCellOccupied(key) {
                for (const [id, robot] of this.game.state.robots) {
                    if (`${robot.row},${robot.col}` === key) return true;
                }
                return false;
            }

            isCellPassable(row, col, isRobotCarryingShelf, ignoreRoute = false, isFinalDestination = false, forRobotId = null) {
                const key = `${row},${col}`;
                const cell = this.getCell(row, col);

                if (!cell) return false;
                if (this.game.state.obstacles.has(key)) return false;
                if (this.isCellOccupied(key)) return false;

                if (!ignoreRoute) {
                    for (const [otherId, route] of this.game.state.activeRoutes) {
                        if (otherId === forRobotId) continue;
                        if (route && route.some(step => step.row === row && step.col === col)) {
                            return false;
                        }
                    }
                }

                // ПОЛНЫЙ ЗАПРЕТ ПРОЕЗДА ЧЕРЕЗ ЗАРЯДНЫЕ СТАНЦИИ
                if (this.game.state.chargingStations.has(key)) {
                    return isFinalDestination; // Только как конечная точка
                }

                if (isFinalDestination) {
                    if (this.game.state.shelves.has(key)) return !isRobotCarryingShelf;
                    if (this.game.state.parkingCells.has(key)) return true;
                    return true;
                } else {
                    if (this.game.state.shelves.has(key)) return !isRobotCarryingShelf;
                    return true;
                }
            }

            isCellAvailableForTarget(key) {
                if (this.game.state.parkingCells.has(key) && this.game.state.shelves.has(key)) {
                    return false;
                }
                if (this.isCellOccupied(key)) return false;

                for (const [otherId, route] of this.game.state.activeRoutes) {
                    if (otherId === this.game.selectedRobot) continue;
                    if (route && route.some(step => `${step.row},${step.col}` === key)) {
                        return false;
                    }
                }

                return true;
            }

            restoreCellBackground(cell, row, col) {
                const key = `${row},${col}`;
                cell.className = 'cell';

                if (this.game.state.parkingCells.has(key)) {
                    cell.classList.add('parking');
                    const parkingState = this.game.state.parkingCellStates.get(key);
                    if (parkingState && parkingState.hasShelf) {
                        const shelfImage = document.createElement('div');
                        shelfImage.className = 'robot-image';
                        shelfImage.style.backgroundImage = `url('Shelf.png')`;
                        shelfImage.style.zIndex = 6;
                        cell.appendChild(shelfImage);
                    }
                } else if (this.game.state.obstacles.has(key)) {
                    cell.classList.add('column');
                } else if (this.game.state.chargingStations.has(key)) {
                    cell.classList.add('charging-station');
                } else if (this.game.state.shelves.has(key)) {
                    cell.classList.add('shelf');
                }
            }

            restoreCellState(cell, row, col) {
                const key = `${row},${col}`;

                while (cell.firstChild) {
                    cell.removeChild(cell.firstChild);
                }

                cell.className = 'cell';

                let robotHere = null;
                for (const [id, robot] of this.game.state.robots) {
                    if (robot.row === row && robot.col === col) {
                        robotHere = robot;
                        break;
                    }
                }

                if (!(robotHere && this.game.state.chargingStations.has(key) && robotHere.isCharging)) {
                    if (this.game.state.parkingCells.has(key)) cell.classList.add('parking');
                    else if (this.game.state.obstacles.has(key)) cell.classList.add('column');
                    else if (this.game.state.chargingStations.has(key)) cell.classList.add('charging-station');
                    else if (this.game.state.shelves.has(key)) cell.classList.add('shelf');
                }

                if (this.game.state.parkingCells.has(key)) {
                    const parkingState = this.game.state.parkingCellStates.get(key);
                    if (parkingState && parkingState.hasShelf) {
                        const shelfImage = document.createElement('div');
                        shelfImage.className = 'robot-image';
                        shelfImage.style.backgroundImage = `url('Shelf.png')`;
                        shelfImage.style.zIndex = 6;
                        cell.appendChild(shelfImage);
                    }
                }

                if (robotHere) {
                    this.game.animationManager.addRobotImage(cell, this.game.animationManager.getRobotImageType(robotHere, row, col));
                    this.game.animationManager.addChargeBar(cell, robotHere.charge);

                    if (this.game.selectedRobot === robotHere.id) {
                        cell.classList.add('selected');
                    }

                    if (this.game.state.parkingCells.has(key)) {
                        const state = this.game.state.parkingCellStates.get(key) || { hasShelf: false, robotId: null };
                        this.game.state.parkingCellStates.set(key, {
                            hasShelf: state.hasShelf,
                            robotId: robotHere.id
                        });
                    }
                } else {
                    if (this.game.state.parkingCells.has(key)) {
                        const state = this.game.state.parkingCellStates.get(key) || { hasShelf: false, robotId: null };
                        this.game.state.parkingCellStates.set(key, {
                            hasShelf: state.hasShelf,
                            robotId: null
                        });
                    }
                }
            }
        }

        class AnimationManager {
            constructor(game) {
                this.game = game;
                this.activeAnimations = new Set();
                this.constantBlinkInterval = null;
            }

            addRobotImage(cell, imageUrl) {
                const existingImage = cell.querySelector('.robot-image');
                if (existingImage) cell.removeChild(existingImage);

                const robotImage = document.createElement('div');
                robotImage.className = 'robot-image';
                robotImage.style.backgroundImage = `url('${imageUrl}')`;
                cell.appendChild(robotImage);

                return robotImage;
            }

            addChargeBar(cell, charge) {
                const chargeBar = cell.querySelector('.charge-bar');
                if (chargeBar) cell.removeChild(chargeBar);

                const newBar = document.createElement('div');
                newBar.className = 'charge-bar';

                const level = document.createElement('div');
                level.className = 'charge-level';

                if (charge < this.game.GAME_CONSTANTS.LOW_CHARGE_THRESHOLD) level.classList.add('low');
                else if (charge < 50) level.classList.add('medium');
                else if (charge < 75) level.classList.add('good');
                else level.classList.add('high');

                level.style.width = charge + '%';
                newBar.appendChild(level);
                cell.appendChild(newBar);

                return newBar;
            }

            getRobotImageType(robot, row, col) {
                const key = `${row},${col}`;

                if (this.game.state.chargingStations.has(key) && robot.isCharging) {
                    return 'Robot_Charg.png';
                } else if (robot.hasShelf) {
                    return 'Robot_Shelf.png';
                } else {
                    return 'Robot.png';
                }
            }

            addBlinkingAnimation(cell) {
                if (cell.classList.contains('blinking-cell')) return;

                cell.classList.add('blinking-cell');
                const parts = ['top', 'right', 'bottom', 'left'].map((side, i) => {
                    const part = document.createElement('div');
                    part.className = 'moving-part';
                    part.style[side] = '0';
                    part.style.width = ['top', 'bottom'].includes(side) ? '20%' : '2px';
                    part.style.height = ['left', 'right'].includes(side) ? '20%' : '2px';
                    cell.appendChild(part);
                    return part;
                });

                let step = 0;
                const interval = setInterval(() => {
                    parts.forEach((part, i) => {
                        const pos = (step * 25) + '%';
                        if (i === 0) part.style.left = pos;
                        if (i === 1) part.style.top = pos;
                        if (i === 2) part.style.right = pos;
                        if (i === 3) part.style.bottom = pos;
                    });
                    step = (step + 1) % 4;
                }, 150);

                this.activeAnimations.add({ cell, interval, type: 'blink' });
            }

            stopAllBlinking() {
                this.activeAnimations.forEach(data => {
                    if (data.type === 'blink') {
                        clearInterval(data.interval);
                        data.cell.classList.remove('blinking-cell');
                        data.cell.querySelectorAll('.moving-part').forEach(el => el.remove());
                    }
                });

                this.activeAnimations.clear();

                const cells = this.game.board.querySelectorAll('.cell');
                cells.forEach(cell => {
                    cell.classList.remove('target-cell');
                    cell.querySelectorAll('.moving-part').forEach(el => el.remove());
                });
            }

            async blinkElement(element, color = '#ff0000', times = 3) {
                for (let i = 0; i < times; i++) {
                    element.style.backgroundColor = color;
                    await new Promise(resolve => setTimeout(resolve, 150));
                    element.style.backgroundColor = '';
                    await new Promise(resolve => setTimeout(resolve, 150));
                }
            }

            async blinkObstacleCells(cells, color = '#ff0000') {
                if (!cells || cells.length === 0) return;

                const uniqueCells = Array.from(new Set(cells.map(c => `${c.row},${c.col}`)))
                    .map(key => {
                        const [r, c] = key.split(',').map(Number);
                        return { row: r, col: c };
                    });

                const blinkPromises = uniqueCells.map(({ row, col }) => {
                    return new Promise(resolve => {
                        const cell = this.game.cellManager.getCell(row, col);
                        if (!cell) {
                            resolve();
                            return;
                        }

                        let count = 0;
                        const blink = () => {
                            if (count >= 3) {
                                resolve();
                                return;
                            }

                            cell.style.backgroundColor = color;
                            setTimeout(() => {
                                cell.style.backgroundColor = '';
                                setTimeout(blink, 150);
                                count++;
                            }, 150);
                        };

                        blink();
                    });
                });

                await Promise.all(blinkPromises);
            }

            drawLineBetweenCells(row1, col1, row2, col2) {
                const cell1 = this.game.cellManager.getCell(row1, col1);
                const cell2 = this.game.cellManager.getCell(row2, col2);

                if (!cell1 || !cell2) return null;

                const rect1 = cell1.getBoundingClientRect();
                const rect2 = cell2.getBoundingClientRect();
                const boardRect = this.game.board.getBoundingClientRect();

                const x1 = rect1.left + rect1.width / 2 - boardRect.left;
                const y1 = rect1.top + rect1.height / 2 - boardRect.top;
                const x2 = rect2.left + rect2.width / 2 - boardRect.left;
                const y2 = rect2.top + rect2.height / 2 - boardRect.top;

                const line = document.createElement('div');
                line.className = 'route-line';

                const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

                line.style.width = `${length}px`;
                line.style.height = '2px';
                line.style.left = `${x1}px`;
                line.style.top = `${y1}px`;
                line.style.transformOrigin = '0 0';
                line.style.transform = `rotate(${angle}deg)`;

                return line;
            }

            startConstantBlinking(element, color = '#ff0000') {
                if (this.constantBlinkInterval) {
                    clearInterval(this.constantBlinkInterval);
                }

                let isOn = true;
                this.constantBlinkInterval = setInterval(() => {
                    if (isOn) {
                        element.style.backgroundColor = color;
                    } else {
                        element.style.backgroundColor = '';
                    }
                    isOn = !isOn;
                }, 250);
            }
        }

        class RobotManager {
            constructor(game) {
                this.game = game;
            }

            handleManualShelfInteraction(robot, row, col) {
                const key = `${row},${col}`;
                const cell = this.game.cellManager.getCell(row, col);

                if (!cell) return;

                if (robot.hasShelf) {
                    if (!this.game.state.chargingStations.has(key) && !this.game.state.shelves.has(key)) {
                        robot.hasShelf = false;
                        this.game.state.shelves.add(key);

                        if (this.game.state.parkingCells.has(key)) {
                            const state = this.game.state.parkingCellStates.get(key) || { hasShelf: false, robotId: null };
                            this.game.state.parkingCellStates.set(key, {
                                hasShelf: true,
                                robotId: state.robotId
                            });
                        }

                        this.game.cellManager.restoreCellState(cell, row, col);
                    }
                } else {
                    if (this.game.state.shelves.has(key)) {
                        robot.hasShelf = true;
                        this.game.state.shelves.delete(key);

                        if (this.game.state.parkingCells.has(key)) {
                            const state = this.game.state.parkingCellStates.get(key) || { hasShelf: false, robotId: null };
                            this.game.state.parkingCellStates.set(key, {
                                hasShelf: false,
                                robotId: state.robotId
                            });
                        }

                        this.game.cellManager.restoreCellState(cell, row, col);
                    }
                }
            }

            dropShelfHere(robot, cell, row, col) {
                if (!robot.hasShelf) return;

                robot.hasShelf = false;
                const key = `${row},${col}`;

                if (!this.game.state.shelves.has(key)) {
                    this.game.state.shelves.add(key);
                }

                if (this.game.state.parkingCells.has(key)) {
                    const state = this.game.state.parkingCellStates.get(key) || { hasShelf: false, robotId: null };
                    this.game.state.parkingCellStates.set(key, {
                        hasShelf: true,
                        robotId: state.robotId
                    });
                }

                if (cell) {
                    this.game.cellManager.restoreCellState(cell, row, col);
                }
            }

            startCharging(robotId) {
                const robot = this.game.state.robots.get(robotId);
                if (!robot) return;

                robot.isCharging = true;

                if (this.game.state.chargingIntervals.has(robotId)) {
                    clearInterval(this.game.state.chargingIntervals.get(robotId));
                }

                const cell = this.game.cellManager.getCell(robot.row, robot.col);
                if (cell) {
                    this.game.cellManager.restoreCellState(cell, robot.row, robot.col);

                    if (this.game.selectedRobot === robotId) {
                        cell.classList.add('selected');
                    }
                }

                const chargeInterval = setInterval(() => {
                    if (!robot.isCharging || this.game.state.movingRobots.has(robotId)) {
                        clearInterval(chargeInterval);
                        this.game.state.chargingIntervals.delete(robotId);
                        return;
                    }

                    if (robot.charge >= 100) {
                        robot.charge = 100;
                        robot.isCharging = false;

                        clearInterval(chargeInterval);
                        this.game.state.chargingIntervals.delete(robotId);

                        const finalCell = this.game.cellManager.getCell(robot.row, robot.col);
                        if (finalCell) {
                            this.game.cellManager.restoreCellState(finalCell, robot.row, robot.col);

                            if (this.game.selectedRobot === robotId) {
                                finalCell.classList.add('selected');
                                this.game.startTargetBlinking(this.game.state.robots.get(robotId));
                            }
                        }

                        return;
                    }

                    robot.charge = Math.min(100, robot.charge + this.game.GAME_CONSTANTS.CHARGE_GAIN_PER_SECOND);

                    const chargeCell = this.game.cellManager.getCell(robot.row, robot.col);
                    if (chargeCell) {
                        this.game.animationManager.addChargeBar(chargeCell, robot.charge);
                    }

                    if (this.game.selectedRobot === robotId) {
                        this.game.movesElement.textContent = `Заряд робота: ${robot.charge}%`;
                    }
                }, 1000);

                this.game.state.chargingIntervals.set(robotId, chargeInterval);
            }

            async startRobotMovement(robotId) {
                const robot = this.game.state.robots.get(robotId);
                if (!robot || !robot.route || robot.route.length <= 1) return;

                const initialRoute = [...robot.route];

                if (this.game.abortControllers.has(robotId)) {
                    this.game.abortControllers.get(robotId).abort();
                }

                const abortController = new AbortController();
                this.game.abortControllers.set(robotId, abortController);
                const signal = abortController.signal;

                this.game.state.movingRobots.add(robotId);
                const route = [...robot.route];
                const lines = this.game.state.routeLines.get(robotId) || [];

                try {
                    for (let i = 1; i < route.length; i++) {
                        if (signal.aborted) {
                            if (this.game.selectedRobot === robotId) {
                                this.game.animationManager.stopAllBlinking();
                            }

                            const currentCell = this.game.cellManager.getCell(robot.row, robot.col);
                            if (currentCell) {
                                this.game.cellManager.restoreCellState(currentCell, robot.row, robot.col);
                            }

                            const nextStep = route[i];
                            const nextCell = this.game.cellManager.getCell(nextStep.row, nextStep.col);
                            if (nextCell) {
                                while (nextCell.firstChild) {
                                    nextCell.removeChild(nextCell.firstChild);
                                }
                                this.game.cellManager.restoreCellBackground(nextCell, nextStep.row, nextStep.col);
                            }

                            if (i > 1) {
                                const prevStep = route[i - 2];
                                const prevCell = this.game.cellManager.getCell(prevStep.row, prevStep.col);
                                if (prevCell) {
                                    while (prevCell.firstChild) {
                                        prevCell.removeChild(prevCell.firstChild);
                                    }
                                    this.game.cellManager.restoreCellBackground(prevCell, prevStep.row, prevStep.col);
                                }
                            }

                            break;
                        }

                        const prevStep = route[i - 1];
                        const nextStep = route[i];
                        const currentCell = this.game.cellManager.getCell(prevStep.row, prevStep.col);
                        const nextCell = this.game.cellManager.getCell(nextStep.row, nextStep.col);

                        if (!nextCell) break;

                        if (this.game.state.chargingStations.has(`${nextStep.row},${nextStep.col}`) && robot.hasShelf) {
                            if (currentCell) {
                                this.dropShelfHere(robot, currentCell, prevStep.row, prevStep.col);
                            }
                        }

                        if (currentCell) {
                            const currentRobotImg = currentCell.querySelector('.robot-image');
                            const currentChargeBar = currentCell.querySelector('.charge-bar');
                            if (currentRobotImg) currentRobotImg.style.opacity = '0';
                            if (currentChargeBar) currentChargeBar.style.opacity = '0';
                        }

                        await new Promise(resolve => setTimeout(resolve, this.game.GAME_CONSTANTS.ROBOT_SPEED / 2));

                        if (currentCell) {
                            while (currentCell.firstChild) {
                                currentCell.removeChild(currentCell.firstChild);
                            }
                            this.game.cellManager.restoreCellBackground(currentCell, prevStep.row, prevStep.col);
                        }

                        while (nextCell.firstChild) {
                            nextCell.removeChild(nextCell.firstChild);
                        }

                        nextCell.className = 'cell';
                        this.game.animationManager.addRobotImage(nextCell, this.game.animationManager.getRobotImageType(robot, nextStep.row, nextStep.col));
                        this.game.animationManager.addChargeBar(nextCell, robot.charge);

                        const nextRobotImg = nextCell.querySelector('.robot-image');
                        const nextChargeBar = nextCell.querySelector('.charge-bar');
                        if (nextRobotImg) nextRobotImg.style.opacity = '0';
                        if (nextChargeBar) nextChargeBar.style.opacity = '0';

                        if (lines.length > 0) {
                            const lineToRemove = lines.shift();
                            if (lineToRemove && lineToRemove.parentNode) lineToRemove.remove();
                        }

                        robot.row = nextStep.row;
                        robot.col = nextStep.col;
                        robot.charge = Math.max(0, robot.charge - this.game.GAME_CONSTANTS.CHARGE_DEPLETION_PER_CELL);

                        if (robot.charge <= 0) {
                            this.game.triggerGameOver();
                            return;
                        }

                        if (robot.route && robot.route.length > i) {
                            robot.route = robot.route.slice(i - 1);
                            this.game.state.activeRoutes.set(robotId, robot.route);
                        }

                        if (nextRobotImg) nextRobotImg.style.opacity = '1';
                        if (nextChargeBar) nextChargeBar.style.opacity = '1';

                        if (this.game.selectedRobot === robotId) {
                            this.game.movesElement.textContent = `Заряд робота: ${robot.charge}%`;
                        }

                        await new Promise(resolve => setTimeout(resolve, this.game.GAME_CONSTANTS.ROBOT_SPEED / 2));
                        this.game.cellManager.restoreCellBackground(nextCell, nextStep.row, nextStep.col);
                    }

                    if (!signal.aborted) {
                        this.game.clearRobotRouteLines(robotId);
                        this.game.state.activeRoutes.delete(robotId);
                        robot.route = null;

                        const finalCell = this.game.cellManager.getCell(robot.row, robot.col);
                        if (finalCell) {
                            const finalKey = `${robot.row},${robot.col}`;
                            let shouldUpdateVisual = false;

                            if (!robot.hasShelf && this.game.state.shelves.has(finalKey)) {
                                robot.hasShelf = true;
                                this.game.state.shelves.delete(finalKey);

                                if (this.game.state.parkingCells.has(finalKey)) {
                                    const state = this.game.state.parkingCellStates.get(finalKey) || { hasShelf: false, robotId: null };
                                    this.game.state.parkingCellStates.set(finalKey, {
                                        hasShelf: false,
                                        robotId: robot.id
                                    });
                                }

                                shouldUpdateVisual = true;
                            } else if (robot.hasShelf && this.game.state.parkingCells.has(finalKey)) {
                                robot.hasShelf = false;
                                this.game.state.shelves.add(finalKey);
                                this.game.state.parkingCellStates.set(finalKey, {
                                    hasShelf: true,
                                    robotId: robot.id
                                });
                                shouldUpdateVisual = true;
                            }

                            if (shouldUpdateVisual) {
                                this.game.cellManager.restoreCellState(finalCell, robot.row, robot.col);
                            } else {
                                this.game.cellManager.restoreCellBackground(finalCell, robot.row, robot.col);
                            }

                            this.game.animationManager.addRobotImage(finalCell, this.game.animationManager.getRobotImageType(robot, robot.row, robot.col));
                            this.game.animationManager.addChargeBar(finalCell, robot.charge);

                            if (this.game.selectedRobot === robotId) {
                                finalCell.classList.add('selected');
                            }

                            if (this.game.state.chargingStations.has(finalKey)) {
                                this.startCharging(robotId);
                            }
                        }

                        if (this.game.selectedRobot === robotId) {
                            this.game.movesElement.textContent = `Заряд робота: ${robot.charge}%`;
                        }

                        if (this.game.selectedRobot === robotId) {
                            this.game.startTargetBlinking(robot);
                        }

                        this.game.checkVictoryCondition();
                    }
                } catch (error) {
                    if (error.name !== 'AbortError') throw error;
                } finally {
                    this.game.state.movingRobots.delete(robotId);
                    if (this.game.abortControllers.get(robotId) === abortController) {
                        this.game.abortControllers.delete(robotId);
                    }
                }
            }
        }

        class LogisticsGame {
            constructor() {
                this.board = document.getElementById('game-board');
                this.movesElement = document.getElementById('moves');
                this.timerElement = document.getElementById('timer');
                this.resetBtn = document.getElementById('reset-btn');

                this.rows = 10;
                this.cols = 8;
                this.totalTime = 3 * 60;
                this.elapsedTime = 0;
                this.timerInterval = null;
                this.gameStarted = false;
                this.selectedRobot = null;
                this.abortControllers = new Map();
                this.warningCount = new Map();
                this.gameOver = false;
                this.constantBlinkInterval = null;

                this.GAME_CONSTANTS = {
                    ROBOT_SPEED: 250,
                    CHARGE_DEPLETION_PER_CELL: 2,
                    CHARGE_GAIN_PER_SECOND: 10,
                    LOW_CHARGE_THRESHOLD: 25,
                    CRITICAL_CHARGE_THRESHOLD: 15,
                    MAX_WARNING_COUNT: 3,
                    GAME_DURATION: 5 * 60
                };

                this.gameParams = {
                    rows: this.rows,
                    cols: this.cols,
                    columnsCount: 6,
                    chargingStationsCount: 2,
                    robotsCount: 2,
                    shelvesCount: this.cols,
                    minDistance: {
                        robotToRobot: 4,
                        chargingToCharging: 3,
                        columnToColumn: 3,
                        shelfToShelf: 2,
                        chargingToShelf: 2,
                        robotToShelf: 2
                    },
                    columnRows: { min: 2, max: this.rows - 2 },
                    columnCols: { min: 1, max: this.cols - 1 },
                    chargingRows: { min: 3, max: this.rows - 3 },
                    chargingCols: { min: 3, max: this.cols - 3 },
                    robotRows: { min: 2, max: this.rows - 2 },
                    robotCols: { min: 0, max: this.cols - 1 },
                    shelfRows: { min: 3, max: this.rows - 2 },
                    shelfCols: { min: 0, max: this.cols - 1 }
                };

                this.state = {
                    robots: new Map(),
                    chargingStations: new Set(),
                    shelves: new Set(),
                    parkingCells: new Set(),
                    obstacles: new Set(),
                    activeRoutes: new Map(),
                    movingRobots: new Set(),
                    routeLines: new Map(),
                    chargingIntervals: new Map(),
                    parkingCellStates: new Map()
                };

                this.pathfinder = new Pathfinder(this);
                this.cellManager = new CellManager(this);
                this.animationManager = new AnimationManager(this);
                this.robotManager = new RobotManager(this);

                this.init();
            }

            init() {
                this.updateBoardSize();
                this.showSplashScreen();
                this.resetBtn.addEventListener('click', () => this.startNewGame());
                window.addEventListener('resize', () => this.updateBoardSize());
            }

            updateBoardSize() {
                const vw = window.innerWidth * 0.94;
                const vh = window.innerHeight * 0.94;
                const width = Math.min(vw, vh * (this.cols / this.rows));
                const height = width * (this.rows / this.cols);

                this.board.style.width = `${width}px`;
                this.board.style.height = `${height}px`;
                this.board.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`;
                this.board.style.gridTemplateRows = `repeat(${this.rows}, 1fr)`;

                const fontSize = width / this.cols * 0.4;
                this.board.querySelectorAll('.cell').forEach(cell => {
                    cell.style.fontSize = `${fontSize}px`;
                });
            }

            showSplashScreen() {
                const splash = this.board.querySelector('.splash-screen');
                if (splash) splash.style.display = 'flex';
                this.hideStats();
            }

            hideSplashScreen() {
                const splash = this.board.querySelector('.splash-screen');
                if (splash) splash.remove();
            }

            async startNewGame() {
                this.animationManager.stopAllBlinking();

                if (this.constantBlinkInterval) {
                    clearInterval(this.constantBlinkInterval);
                    this.constantBlinkInterval = null;
                }

                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }

                for (const [id, controller] of this.abortControllers) {
                    controller.abort();
                }
                this.abortControllers.clear();

                this.state.robots.clear();
                this.state.chargingStations.clear();
                this.state.shelves.clear();
                this.state.parkingCells.clear();
                this.state.obstacles.clear();
                this.state.activeRoutes.clear();
                this.state.movingRobots.clear();
                this.state.routeLines.clear();
                this.state.chargingIntervals.clear();
                this.state.parkingCellStates.clear();
                this.warningCount.clear();
                this.gameOver = false;

                const overlay = this.board.querySelector('.game-over-overlay');
                if (overlay) overlay.remove();

                this.board.style.pointerEvents = 'auto';
                this.createBoard();
                this.gameStarted = false;
                this.selectedRobot = null;
                this.elapsedTime = 0;
                this.updateTimerDisplay();
                this.movesElement.textContent = 'Заряд робота';
                this.movesElement.style.backgroundColor = '';

                this.showStats();

                for (let col = 0; col < this.cols; col++) {
                    const key = `0,${col}`;
                    this.state.parkingCells.add(key);
                    this.state.parkingCellStates.set(key, { hasShelf: false, robotId: null });
                }

                await new Promise(resolve => setTimeout(resolve, 200));
                await this.generateFieldWithAnimation();
                this.setupEventListeners();
            }

            createBoard() {
                this.board.innerHTML = '';
                this.cellManager.cellCache.clear();

                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell empty';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        this.board.appendChild(cell);
                        this.cellManager.cacheCell(row, col, cell);
                    }
                }
                this.updateBoardSize();
            }

            async generateFieldWithAnimation() {
                this.hideSplashScreen();
                let isValidField = false;
                let attempt = 0;
                const maxAttempts = 50;

                while (!isValidField && attempt < maxAttempts) {
                    attempt++;
                    this.state.obstacles.clear();
                    this.state.chargingStations.clear();
                    this.state.shelves.clear();
                    this.state.robots.clear();
                    this.state.parkingCellStates.clear();

                    // Сбрасываем parkingCells и заново добавляем верхний ряд
                    this.state.parkingCells.clear();
                    for (let col = 0; col < this.cols; col++) {
                        const key = `0,${col}`;
                        this.state.parkingCells.add(key);
                        this.state.parkingCellStates.set(key, { hasShelf: false, robotId: null });
                    }

                    isValidField = await this.generateObjectsInMemory();

                    if (isValidField) {
                        isValidField = this.validateFieldUniqueness();
                    }
                }

                if (!isValidField) {
                    console.error(`Не удалось сгенерировать поле без наложений после ${maxAttempts} попыток.`);
                    // Создаём минимальное валидное поле вручную
                    this.createFallbackField();
                }

                this.renderAllObjects();
            }

            validateFieldUniqueness() {
                const allPositions = new Set();

                for (const key of this.state.obstacles) {
                    if (allPositions.has(key)) return false;
                    allPositions.add(key);
                }

                for (const key of this.state.chargingStations) {
                    if (allPositions.has(key)) return false;
                    allPositions.add(key);
                }

                for (const key of this.state.shelves) {
                    if (allPositions.has(key)) return false;
                    allPositions.add(key);
                }

                for (const [id, robot] of this.state.robots) {
                    const key = `${robot.row},${robot.col}`;
                    if (allPositions.has(key)) return false;
                    allPositions.add(key);
                }

                return true;
            }

            createFallbackField() {
                // Резервное создание поля если автоматическая генерация fails
                console.log("Создание резервного поля...");

                // Очищаем всё
                this.state.obstacles.clear();
                this.state.chargingStations.clear();
                this.state.shelves.clear();
                this.state.robots.clear();

                // Добавляем несколько препятствий
                const obstaclePositions = [
                    {row: 2, col: 2}, {row: 2, col: 5},
                    {row: 5, col: 2}, {row: 5, col: 5},
                    {row: 7, col: 3}, {row: 7, col: 4}
                ];

                obstaclePositions.forEach(pos => {
                    if (pos.row < this.rows && pos.col < this.cols) {
                        this.state.obstacles.add(`${pos.row},${pos.col}`);
                    }
                });

                // Добавляем зарядные станции
                const chargingPositions = [
                    {row: 3, col: 1}, {row: 3, col: 6}
                ];

                chargingPositions.forEach(pos => {
                    if (pos.row < this.rows && pos.col < this.cols) {
                        this.state.chargingStations.add(`${pos.row},${pos.col}`);
                    }
                });

                // Добавляем столы
                for (let i = 0; i < this.gameParams.shelvesCount; i++) {
                    const row = Math.floor(Math.random() * (this.rows - 3)) + 3;
                    const col = Math.floor(Math.random() * this.cols);
                    const key = `${row},${col}`;

                    if (!this.state.obstacles.has(key) && !this.state.chargingStations.has(key)) {
                        this.state.shelves.add(key);
                    }
                }

                // Добавляем роботов
                for (let i = 0; i < this.gameParams.robotsCount; i++) {
                    let row, col;
                    do {
                        row = Math.floor(Math.random() * (this.rows - 2)) + 1;
                        col = Math.floor(Math.random() * this.cols);
                    } while (this.isCellOccupiedInMemory(`${row},${col}`));

                    this.state.robots.set(i, {
                        row: row,
                        col: col,
                        charge: Math.floor(Math.random() * 76) + 25,
                        hasShelf: false,
                        route: null,
                        isCharging: false,
                        id: i
                    });
                }
            }

            async generateObjectsInMemory() {
                const obstaclesGrid = this.generateGrid(this.gameParams.columnRows, this.gameParams.columnCols);
                this.shuffleArray(obstaclesGrid);

                let obstaclesPlaced = 0;
                for (const pos of obstaclesGrid) {
                    if (obstaclesPlaced >= this.gameParams.columnsCount) break;
                    if (this.isPositionValid(pos, this.state.obstacles, this.gameParams.minDistance.columnToColumn)) {
                        this.state.obstacles.add(`${pos.row},${pos.col}`);
                        obstaclesPlaced++;
                    }
                }

                const chargingCandidates = [];
                for (const key of this.state.obstacles) {
                    const [r, c] = key.split(',').map(Number);
                    const directions = [
                        { row: -1, col: 0 }, { row: 0, col: 1 },
                        { row: 1, col: 0 }, { row: 0, col: -1 }
                    ];

                    for (const dir of directions) {
                        const nr = r + dir.row;
                        const nc = c + dir.col;
                        if (nr >= this.gameParams.chargingRows.min && nr <= this.gameParams.chargingRows.max &&
                            nc >= this.gameParams.chargingCols.min && nc <= this.gameParams.chargingCols.max) {
                            chargingCandidates.push({ row: nr, col: nc });
                        }
                    }
                }

                this.shuffleArray(chargingCandidates);
                let chargingPlaced = 0;

                for (const pos of chargingCandidates) {
                    if (chargingPlaced >= this.gameParams.chargingStationsCount) break;
                    if (this.isPositionValid(pos, this.state.chargingStations, this.gameParams.minDistance.chargingToCharging) &&
                        !this.state.obstacles.has(`${pos.row},${pos.col}`)) {
                        this.state.chargingStations.add(`${pos.row},${pos.col}`);
                        chargingPlaced++;
                    }
                }

                const shelvesGrid = this.generateGrid(this.gameParams.shelfRows, this.gameParams.shelfCols);
                this.shuffleArray(shelvesGrid);
                let shelvesPlaced = 0;

                for (const pos of shelvesGrid) {
                    if (shelvesPlaced >= this.gameParams.shelvesCount) break;
                    if (this.isPositionValid(pos, this.state.chargingStations, this.gameParams.minDistance.chargingToShelf) &&
                        this.isPositionValid(pos, this.state.obstacles, 2) &&
                        !this.state.chargingStations.has(`${pos.row},${pos.col}`) &&
                        !this.state.obstacles.has(`${pos.row},${pos.col}`)) {
                        this.state.shelves.add(`${pos.row},${pos.col}`);
                        shelvesPlaced++;
                    }
                }

                const robotsGrid = this.generateGrid(this.gameParams.robotRows, this.gameParams.robotCols);
                this.shuffleArray(robotsGrid);
                let robotId = 0;
                let lowChargePlaced = false;

                for (const pos of robotsGrid) {
                    if (robotId >= this.gameParams.robotsCount) break;
                    const key = `${pos.row},${pos.col}`;
                    if (!this.isCellOccupiedInMemory(key)) {
                        let charge = !lowChargePlaced ?
                            Math.floor(Math.random() * 11) + this.GAME_CONSTANTS.CRITICAL_CHARGE_THRESHOLD :
                            Math.floor(Math.random() * 76) + 25;
                        if (!lowChargePlaced) lowChargePlaced = true;

                        this.state.robots.set(robotId, {
                            row: pos.row,
                            col: pos.col,
                            charge,
                            hasShelf: false,
                            route: null,
                            isCharging: false,
                            id: robotId
                        });
                        robotId++;
                    }
                }

                return obstaclesPlaced >= this.gameParams.columnsCount &&
                       chargingPlaced >= this.gameParams.chargingStationsCount &&
                       shelvesPlaced >= this.gameParams.shelvesCount &&
                       robotId >= this.gameParams.robotsCount;
            }

            isCellOccupiedInMemory(key) {
                if (this.state.obstacles.has(key)) return true;
                if (this.state.chargingStations.has(key)) return true;
                if (this.state.shelves.has(key)) return true;

                for (const [id, robot] of this.state.robots) {
                    if (`${robot.row},${robot.col}` === key) return true;
                }

                return false;
            }

            renderAllObjects() {
                for (let col = 0; col < this.cols; col++) {
                    const cell = this.cellManager.getCell(0, col);
                    if (cell) {
                        cell.className = 'cell parking';
                    }
                }

                for (const key of this.state.obstacles) {
                    const [row, col] = key.split(',').map(Number);
                    const cell = this.cellManager.getCell(row, col);
                    if (cell) {
                        cell.className = 'cell column';
                    }
                }

                for (const key of this.state.chargingStations) {
                    const [row, col] = key.split(',').map(Number);
                    const cell = this.cellManager.getCell(row, col);
                    if (cell) {
                        cell.className = 'cell charging-station';
                    }
                }

                for (const key of this.state.shelves) {
                    const [row, col] = key.split(',').map(Number);
                    const cell = this.cellManager.getCell(row, col);
                    if (cell) {
                        cell.className = 'cell shelf';
                    }
                }

                for (const [id, robot] of this.state.robots) {
                    const cell = this.cellManager.getCell(robot.row, robot.col);
                    if (cell) {
                        cell.className = 'cell';
                        this.animationManager.addRobotImage(cell, 'Robot.png');
                        this.animationManager.addChargeBar(cell, robot.charge);

                        const key = `${robot.row},${robot.col}`;
                        if (this.state.parkingCells.has(key)) {
                            const state = this.state.parkingCellStates.get(key) || { hasShelf: false, robotId: null };
                            this.state.parkingCellStates.set(key, {
                                hasShelf: state.hasShelf,
                                robotId: id
                            });
                        }
                    }
                }
            }

            generateGrid(range, cols) {
                const grid = [];
                for (let r = range.min; r <= range.max; r++) {
                    for (let c = cols.min; c <= cols.max; c++) {
                        grid.push({ row: r, col: c });
                    }
                }
                return grid;
            }

            isPositionValid(pos, set, minDistance) {
                for (const key of set) {
                    const [r, c] = key.split(',').map(Number);
                    const d = Math.abs(pos.row - r) + Math.abs(pos.col - c);
                    if (d < minDistance) return false;
                }
                return true;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            updateTimerDisplay() {
                const minutes = Math.floor(this.elapsedTime / 60);
                const seconds = this.elapsedTime % 60;
                this.timerElement.textContent = `Время: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            setupEventListeners() {
                this.board.addEventListener('click', (e) => {
                    if (this.gameOver) return;

                    let cell = e.target.closest('.cell');
                    if (!cell) {
                        let parent = e.target.parentElement;
                        while (parent && !cell) {
                            if (parent.classList && parent.classList.contains('cell')) {
                                cell = parent;
                            } else {
                                parent = parent.parentElement;
                            }
                        }
                    }

                    if (!cell) return;

                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const key = `${row},${col}`;

                    if (this.state.obstacles.has(key)) return;

                    let clickedRobotId = null;
                    for (const [id, robot] of this.state.robots) {
                        if (robot.row === row && robot.col === col) {
                            clickedRobotId = id;
                            break;
                        }
                    }

                    if (clickedRobotId !== null) {
                        this.handleRobotClick(clickedRobotId, row, col);
                    } else if (this.selectedRobot !== null) {
                        this.setRobotTarget(this.selectedRobot, row, col);
                    }
                });
            }

            handleRobotClick(robotId, row, col) {
                const robot = this.state.robots.get(robotId);

                if (this.selectedRobot !== robotId && this.constantBlinkInterval) {
                    clearInterval(this.constantBlinkInterval);
                    this.constantBlinkInterval = null;
                    this.movesElement.style.backgroundColor = '';
                }

                if (this.selectedRobot === robotId) {
                    this.robotManager.handleManualShelfInteraction(robot, row, col);
                    this.startTargetBlinking(robot);
                    this.movesElement.textContent = `Заряд робота: ${robot.charge}%`;
                    return;
                }

                if (this.selectedRobot !== null) {
                    const prevRobot = this.state.robots.get(this.selectedRobot);
                    const prevCell = this.cellManager.getCell(prevRobot.row, prevRobot.col);
                    if (prevCell) prevCell.classList.remove('selected');
                }

                this.selectedRobot = robotId;
                this.movesElement.textContent = `Заряд робота: ${robot.charge}%`;
                const robotCell = this.cellManager.getCell(robot.row, robot.col);
                if (robotCell) {
                    robotCell.classList.add('selected');
                }

                if (!this.gameStarted) {
                    this.startGameTimer();
                }

                this.startTargetBlinking(robot);
            }

            startGameTimer() {
                this.gameStarted = true;
                this.timerInterval = setInterval(() => {
                    this.elapsedTime++;
                    this.updateTimerDisplay();

                    if (this.elapsedTime >= this.GAME_CONSTANTS.GAME_DURATION) {
                        this.triggerGameOver();
                    }
                }, 1000);
            }

            startTargetBlinking(robot) {
                this.animationManager.stopAllBlinking();
                let targets;

                if (robot.hasShelf) {
                    targets = robot.charge < this.GAME_CONSTANTS.LOW_CHARGE_THRESHOLD ? this.state.chargingStations : this.state.parkingCells;
                } else {
                    targets = robot.charge < this.GAME_CONSTANTS.LOW_CHARGE_THRESHOLD ? this.state.chargingStations : this.state.shelves;
                }

                for (const key of targets) {
                    const [r, c] = key.split(',').map(Number);
                    const cell = this.cellManager.getCell(r, c);
                    if (cell && this.cellManager.isCellAvailableForTarget(key)) {
                        cell.classList.add('target-cell');
                        this.animationManager.addBlinkingAnimation(cell);
                    }
                }
            }

            setRobotTarget(robotId, targetRow, targetCol) {
                if (this.gameOver) return;

                const robot = this.state.robots.get(robotId);
                if (!robot) return;

                const targetKey = `${targetRow},${targetCol}`;
                const currentClickTarget = `${robotId}:${targetKey}`;

                let count = this.warningCount.get(currentClickTarget) || 0;

                if (this.state.movingRobots.has(robotId)) {
                    if (this.abortControllers.has(robotId)) {
                        this.abortControllers.get(robotId).abort();
                    }
                    this.state.movingRobots.delete(robotId);
                }

                this.clearRobotRoute(robotId);
                this.animationManager.stopAllBlinking();

                const targetCell = this.cellManager.getCell(targetRow, targetCol);
                if (!targetCell) return;

                if (this.state.obstacles.has(targetKey)) {
                    this.animationManager.blinkElement(this.movesElement, '#ff0000', 3);
                    return;
                }

                const result = this.pathfinder.findPath(
                    robot.row, robot.col,
                    targetRow, targetCol,
                    robot.hasShelf,
                    robotId
                );

                if (!result.route || result.route.length === 0) {
                    this.animationManager.blinkObstacleCells(result.obstacles.map(key => {
                        const [r, c] = key.split(',').map(Number);
                        return { row: r, col: c };
                    }));
                    return;
                }

                const route = result.route;
                const routeLength = route.length - 1;
                const requiredCharge = routeLength * 2;
                const finalCharge = robot.charge - requiredCharge;

                if (finalCharge < this.GAME_CONSTANTS.LOW_CHARGE_THRESHOLD) {
                    count++;
                    this.warningCount.set(currentClickTarget, count);

                    if (count === 1) {
                        this.animationManager.blinkElement(this.movesElement, '#ff0000', 3);
                        const emptyChargers = [];
                        for (const key of this.state.chargingStations) {
                            if (!this.cellManager.isCellOccupied(key)) {
                                const [r, c] = key.split(',').map(Number);
                                emptyChargers.push({ row: r, col: c });
                            }
                        }
                        this.animationManager.blinkObstacleCells(emptyChargers, '#00ff00');
                        return;
                    } else if (count >= 2) {
                        this.animationManager.blinkElement(this.movesElement, '#ff0000', 3);
                        return;
                    }
                } else {
                    this.warningCount.set(currentClickTarget, 0);
                    if (this.constantBlinkInterval) {
                        clearInterval(this.constantBlinkInterval);
                        this.constantBlinkInterval = null;
                        this.movesElement.style.backgroundColor = '';
                    }
                }

                this.buildAndStartRoute(robotId, route);
            }

            buildAndStartRoute(robotId, route) {
                const robot = this.state.robots.get(robotId);
                if (!robot) return;

                robot.route = route;
                this.state.activeRoutes.set(robotId, route);
                this.drawRoute(robotId, route);
                this.robotManager.startRobotMovement(robotId);
            }

            drawRoute(robotId, route) {
                this.clearRobotRouteLines(robotId);
                const lines = [];

                for (let i = 0; i < route.length - 1; i++) {
                    const from = route[i];
                    const to = route[i + 1];
                    const line = this.animationManager.drawLineBetweenCells(from.row, from.col, to.row, to.col);
                    if (line) {
                        lines.push(line);
                        this.board.appendChild(line);
                        this.state.routeLines.set(robotId, lines);
                    }
                }
            }

            clearRobotRoute(robotId) {
                this.clearRobotRouteLines(robotId);
                this.state.activeRoutes.delete(robotId);
                const robot = this.state.robots.get(robotId);
                if (robot) robot.route = null;
            }

            clearRobotRouteLines(robotId) {
                const lines = this.state.routeLines.get(robotId);
                if (lines) {
                    lines.forEach(line => {
                        if (line && line.parentNode) {
                            line.remove();
                        }
                    });
                }
                this.state.routeLines.delete(robotId);
            }

            checkVictoryCondition() {
                let shelvesOnParking = 0;

                for (const shelfKey of this.state.shelves) {
                    if (this.state.parkingCells.has(shelfKey)) {
                        shelvesOnParking++;
                    }
                }

                for (const [id, robot] of this.state.robots) {
                    if (robot.hasShelf) {
                        const robotKey = `${robot.row},${robot.col}`;
                        if (this.state.parkingCells.has(robotKey)) {
                            shelvesOnParking++;
                        }
                    }
                }

                if (shelvesOnParking === this.gameParams.shelvesCount) {
                    this.triggerVictory();
                }
            }

            triggerVictory() {
                this.gameOver = true;
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                for (const [id, controller] of this.abortControllers) {
                    controller.abort();
                }
                this.abortControllers.clear();
                for (const [id, interval] of this.state.chargingIntervals) {
                    clearInterval(interval);
                }
                this.state.chargingIntervals.clear();
                this.board.style.pointerEvents = 'none';

                const overlay = document.createElement('div');
                overlay.className = 'game-over-overlay';
                overlay.style.color = 'yellow';
                overlay.textContent = 'ПОБЕДА!';

                const timeElement = document.createElement('div');
                timeElement.className = 'victory-time';
                const minutes = Math.floor(this.elapsedTime / 60);
                const seconds = this.elapsedTime % 60;
                if (minutes === 0) {
                    timeElement.textContent = `Вы справились за ${seconds} сек`;
                } else if (seconds === 0) {
                    timeElement.textContent = `Вы справились за ${minutes} мин`;
                } else {
                    timeElement.textContent = `Вы справились за ${minutes} мин ${seconds} сек`;
                }
                overlay.appendChild(timeElement);
                this.board.appendChild(overlay);

                this.movesElement.textContent = 'ПОБЕДА!';
                this.timerElement.textContent = 'ПОБЕДА!';
                this.hideStats();

                if (this.constantBlinkInterval) {
                    clearInterval(this.constantBlinkInterval);
                    this.constantBlinkInterval = null;
                }
            }

            triggerGameOver() {
                this.gameOver = true;
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                for (const [id, controller] of this.abortControllers) {
                    controller.abort();
                }
                this.abortControllers.clear();
                for (const [id, interval] of this.state.chargingIntervals) {
                    clearInterval(interval);
                }
                this.state.chargingIntervals.clear();
                this.board.style.pointerEvents = 'none';

                const overlay = document.createElement('div');
                overlay.className = 'game-over-overlay';
                overlay.textContent = 'GAME OVER';
                this.board.appendChild(overlay);

                this.movesElement.textContent = 'GAME OVER';
                this.timerElement.textContent = 'GAME OVER';
                this.hideStats();

                if (this.constantBlinkInterval) {
                    clearInterval(this.constantBlinkInterval);
                    this.constantBlinkInterval = null;
                }
            }

            showStats() {
                const statsContainer = document.querySelector('.stats-container');
                if (statsContainer) {
                    statsContainer.classList.remove('hidden');
                }
            }

            hideStats() {
                const statsContainer = document.querySelector('.stats-container');
                if (statsContainer) {
                    statsContainer.classList.add('hidden');
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                new LogisticsGame();
            } catch (error) {
                console.error('Ошибка при запуске игры:', error);
                alert('Произошла ошибка при запуске игры. Пожалуйста, обновите страницу.');
            }
        });
    </script>
</body>
</html>
