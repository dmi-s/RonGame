<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–õ–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ —Ä–æ–±–æ—Ç—ã</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }
        body {
            background: black;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: hidden;
            touch-action: manipulation;
        }
        .container {
            background: black;
            border-radius: 0;
            padding: 8px;
            box-shadow: none;
            text-align: center;
            width: 100vw;
            max-width: 100%;
            max-height: 100vh;
            margin: 4px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }
        .stats-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 0 6px;
            gap: 8px;
            width: 100%;
            max-width: 550px;
        }
        .stat-item {
            background: #ecf0f1;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: bold;
            font-size: min(0.9em, 4vw);
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 1px;
            overflow: hidden;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(13, 1fr);
            gap: 1px;
            width: min(94vw, 94vh * (10/13), 480px);
            height: min(94vh, 94vw * (13/10), 624px);
            max-width: 100%;
            max-height: 100%;
            border: 2px solid #34495e;
            background: #bdc3c7;
            position: relative;
            overflow: hidden;
            aspect-ratio: 10 / 13;
        }
        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(min(94vw, 94vh * (10/13), 480px) / 10 * 0.4);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
            border-radius: 1px;
            background-color: #ecf0f1;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        .cell:hover {
            transform: scale(0.95);
            opacity: 0.9;
            z-index: 2;
        }
        /* –§–æ–Ω–æ–≤—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è */
        .parking {
            background-image: url('Parking.png');
        }
        .column {
            background-image: url('Column.png');
        }
        .charging-station {
            background-image: url('Charging.png');
        }
        .shelf {
            background-image: url('Shelf.png'); /* –≠—Ç–æ –°–¢–û–õ–´ */
        }
        /* –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–æ–±–æ—Ç–∞ –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç */
        .robot-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 5; /* –í—Å–µ–≥–¥–∞ –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ */
            opacity: 1;
            transition: opacity 0.15s ease-in-out; /* –£—Å–∫–æ—Ä–µ–Ω–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è */
        }
        .charge-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background-color: #ccc;
            z-index: 3;
            opacity: 1;
            transition: opacity 0.15s ease-in-out; /* –£—Å–∫–æ—Ä–µ–Ω–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è */
        }
        .charge-level {
            height: 100%;
            transition: width 0.3s ease;
        }
        .charge-level.low { background-color: #e74c3c; }
        .charge-level.medium { background-color: #f39c12; }
        .charge-level.good { background-color: #f1c40f; }
        .charge-level.high { background-color: #27ae60; }
        /* === –ì–†–ê–î–ò–ï–ù–¢–ù–´–ô –§–û–ù –í–´–ë–†–ê–ù–ù–û–ì–û –†–û–ë–û–¢–ê === */
        .cell.selected::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000, #ffff00);
            background-size: 200% 200%;
            animation: pulseGradient 2s ease infinite;
            z-index: 1;
            border-radius: 1px;
            pointer-events: none;
        }
        @keyframes pulseGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        /* === –ö–õ–ï–¢–ö–ò –ù–ê–ó–ù–ê–ß–ï–ù–ò–Ø: –º–∏–≥–∞—é—Ç —Ñ–æ–Ω–æ–º #ecf0f1 ‚Üî #ffff77 === */
        .target-cell {
            animation: blinkTarget 1s ease infinite;
        }
        @keyframes blinkTarget {
            0%, 100% { background-color: #ecf0f1; }
            50% { background-color: #ffff77; }
        }
        /* === –ë–ï–ì–£–©–ò–ï –û–ì–ù–ò (–∫—Ä–∞—Å–Ω—ã–µ) === */
        .blinking-cell {
            position: relative;
            overflow: hidden;
        }
        .moving-part {
            position: absolute;
            background: red;
            pointer-events: none;
        }
        /* === –ú–ê–†–®–†–£–¢–ù–ê–Ø –õ–ò–ù–ò–Ø === */
        .route-line {
            position: absolute;
            background-color: yellow;
            z-index: 4;
            pointer-events: none;
        }
        button {
            background: yellow;
            color: black;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: min(1em, 4.5vw);
            font-weight: bold;
            transition: background 0.3s;
            margin-top: 12px;
            width: 100%;
            max-width: 550px;
        }
        button:hover {
            background: #ffeb3b;
        }
        .splash-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('Ronavi.png') no-repeat center center;
            background-size: cover;
            z-index: 900;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: red;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 10px yellow;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="stats-container">
            <div id="moves" class="stat-item">–ó–∞—Ä—è–¥ —Ä–æ–±–æ—Ç–∞: 100%</div>
            <div id="timer" class="stat-item">–í—Ä–µ–º—è: 20:00</div>
        </div>
        <div class="game-wrapper">
            <div class="game-board" id="game-board">
                <div class="splash-screen"></div>
            </div>
        </div>
        <button id="reset-btn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
    </div>
    <script>
        class LogisticsGame {
            constructor() {
                this.board = document.getElementById('game-board');
                this.movesElement = document.getElementById('moves');
                this.timerElement = document.getElementById('timer');
                this.resetBtn = document.getElementById('reset-btn');
                this.rows = 13;
                this.cols = 10;
                this.totalTime = 20 * 60;
                this.remainingTime = this.totalTime;
                this.timerInterval = null;
                this.gameStarted = false;
                this.selectedRobot = null;
                this.abortControllers = new Map(); // robotId -> AbortController
                this.warningCount = new Map(); // (robotId, targetKey) -> count
                this.gameOver = false; // —Ñ–ª–∞–≥ –æ–∫–æ–Ω—á–∞–Ω–∏—è –∏–≥—Ä—ã
                this.constantBlinkInterval = null; // –¥–ª—è –º–∏–≥–∞–Ω–∏—è –ø–æ–ª—è –∑–∞—Ä—è–¥–∞
                // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
                this.gameParams = {
                    columnsCount: 12,
                    chargingStationsCount: 3,
                    robotsCount: 3,
                    shelvesCount: 10,
                    minDistance: {
                        columnToColumn: 3,
                        chargingToCharging: 3,
                        shelfToShelf: 2,
                        robotToRobot: 4,
                        chargingToShelf: 2
                    },
                    columnRows: { min: 2, max: 11 },
                    columnCols: { min: 1, max: 8 },
                    chargingRows: { min: 4, max: 9 },
                    chargingCols: { min: 4, max: 7 },
                    robotRows: { min: 2, max: 12 },
                    robotCols: { min: 0, max: 9 },
                    shelfRows: { min: 3, max: 12 },
                    shelfCols: { min: 0, max: 9 }
                };
                // –†–µ–µ—Å—Ç—Ä—ã
                this.state = {
                    robots: new Map(), // { id: { row, col, charge, hasShelf, route, isCharging } }
                    chargingStations: new Set(),
                    shelves: new Set(), // –≠—Ç–æ –°–¢–û–õ–´
                    parkingCells: new Set(),
                    obstacles: new Set(), // —Å—Ç–æ–ª–±—ã
                    activeRoutes: new Map(), // robotId -> –º–∞—Å—Å–∏–≤ –∫–ª–µ—Ç–æ–∫ –º–∞—Ä—à—Ä—É—Ç–∞ (–≤–∫–ª—é—á–∞—è —Ü–µ–ª—å)
                    movingRobots: new Set(), // robotId, –∫–æ—Ç–æ—Ä—ã–µ —Å–µ–π—á–∞—Å –≤ –¥–≤–∏–∂–µ–Ω–∏–∏
                    routeLines: new Map(), // robotId -> –º–∞—Å—Å–∏–≤ DOM-—ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ª–∏–Ω–∏–π
                    chargingIntervals: new Map() // robotId -> intervalId
                };
                this.init();
            }
            init() {
                this.showSplashScreen();
                this.resetBtn.addEventListener('click', () => this.startNewGame());
            }
            showSplashScreen() {
                const splash = this.board.querySelector('.splash-screen');
                if (splash) splash.style.display = 'flex';
            }
            hideSplashScreen() {
                const splash = this.board.querySelector('.splash-screen');
                if (splash) splash.remove();
            }
            async startNewGame() {
                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å—ë
                this.stopAllBlinking();
                if (this.constantBlinkInterval) {
                    clearInterval(this.constantBlinkInterval);
                    this.constantBlinkInterval = null;
                }
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                for (const [id, controller] of this.abortControllers) {
                    controller.abort();
                }
                this.abortControllers.clear();
                // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                this.state.robots.clear();
                this.state.chargingStations.clear();
                this.state.shelves.clear();
                this.state.parkingCells.clear();
                this.state.obstacles.clear();
                this.state.activeRoutes.clear();
                this.state.movingRobots.clear();
                this.state.routeLines.clear();
                this.state.chargingIntervals.clear();
                this.warningCount.clear();
                this.gameOver = false;
                // –£–±–∏—Ä–∞–µ–º overlay GAME OVER, –µ—Å–ª–∏ –µ—Å—Ç—å
                const overlay = this.board.querySelector('.game-over-overlay');
                if (overlay) overlay.remove();
                // –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º –¥–æ—Å–∫—É
                this.board.style.pointerEvents = 'auto';
                // –°–æ–∑–¥–∞—ë–º –ø—É—Å—Ç—É—é –¥–æ—Å–∫—É
                this.createBoard();
                this.gameStarted = false;
                this.selectedRobot = null;
                this.remainingTime = this.totalTime;
                this.updateTimerDisplay();
                this.movesElement.textContent = '–ó–∞—Ä—è–¥ —Ä–æ–±–æ—Ç–∞: 100%';
                this.movesElement.style.backgroundColor = ''; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –º–∏–≥–∞–Ω–∏–µ
                // –ü–∞—Ä–∫–æ–≤–∫–∞
                for (let col = 0; col < this.cols; col++) {
                    const cell = this.getCell(0, col);
                    cell.className = 'cell parking';
                    this.state.parkingCells.add(`${0},${col}`);
                }
                // –ñ–¥—ë–º 200 –º—Å –ø–µ—Ä–µ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π –ø–æ–ª—è
                await new Promise(resolve => setTimeout(resolve, 200));
                await this.generateFieldWithAnimation();
                this.setupEventListeners();
            }
            createBoard() {
                this.board.innerHTML = '';
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell empty';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        this.board.appendChild(cell);
                    }
                }
            }
            async generateFieldWithAnimation() {
                this.hideSplashScreen();
                // –ü–ª–∞–≤–Ω–∞—è —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞: —Å—Ç–æ–ª–±—ã ‚Üí –∑–∞—Ä—è–¥–∫–∏ ‚Üí —Å—Ç–æ–ª—ã ‚Üí —Ä–æ–±–æ—Ç—ã (–ø–æ 30 –º—Å)
                await this.placeObstaclesWithDelay(30);
                await this.placeChargingStationsWithDelay(30);
                await this.placeShelvesWithDelay(30);
                await this.placeRobotsWithDelay(30);
            }
            async placeObstaclesWithDelay(delayMs) {
                const grid = this.generateGrid(this.gameParams.columnRows, this.gameParams.columnCols);
                this.shuffleArray(grid);
                let placed = 0;
                for (const pos of grid) {
                    if (placed >= this.gameParams.columnsCount) break;
                    if (this.isPositionValid(pos, this.state.obstacles, this.gameParams.minDistance.columnToColumn)) {
                        const cell = this.getCell(pos.row, pos.col);
                        if (cell && cell.classList.contains('empty')) {
                            cell.className = 'cell column';
                            this.state.obstacles.add(`${pos.row},${pos.col}`);
                            placed++;
                            await new Promise(resolve => setTimeout(resolve, delayMs));
                        }
                    }
                }
            }
            async placeChargingStationsWithDelay(delayMs) {
                const candidates = [];
                for (const key of this.state.obstacles) {
                    const [r, c] = key.split(',').map(Number);
                    const directions = [
                        { row: -1, col: 0 }, { row: 0, col: 1 },
                        { row: 1, col: 0 }, { row: 0, col: -1 }
                    ];
                    for (const dir of directions) {
                        const nr = r + dir.row;
                        const nc = c + dir.col;
                        if (nr >= this.gameParams.chargingRows.min && nr <= this.gameParams.chargingRows.max &&
                            nc >= this.gameParams.chargingCols.min && nc <= this.gameParams.chargingCols.max) {
                            candidates.push({ row: nr, col: nc });
                        }
                    }
                }
                this.shuffleArray(candidates);
                let placed = 0;
                for (const pos of candidates) {
                    if (placed >= this.gameParams.chargingStationsCount) break;
                    if (this.isPositionValid(pos, this.state.chargingStations, this.gameParams.minDistance.chargingToCharging) &&
                        this.getCell(pos.row, pos.col)?.classList.contains('empty')) {
                        this.state.chargingStations.add(`${pos.row},${pos.col}`);
                        this.getCell(pos.row, pos.col).className = 'cell charging-station';
                        placed++;
                        await new Promise(resolve => setTimeout(resolve, delayMs));
                    }
                }
            }
            async placeShelvesWithDelay(delayMs) {
                const grid = this.generateGrid(this.gameParams.shelfRows, this.gameParams.shelfCols);
                this.shuffleArray(grid);
                let placed = 0;
                for (const pos of grid) {
                    if (placed >= this.gameParams.shelvesCount) break;
                    if (this.isPositionValid(pos, this.state.chargingStations, this.gameParams.minDistance.chargingToShelf) &&
                        this.isPositionValid(pos, this.state.obstacles, 2) &&
                        this.getCell(pos.row, pos.col)?.classList.contains('empty')) {
                        this.state.shelves.add(`${pos.row},${pos.col}`);
                        this.getCell(pos.row, pos.col).className = 'cell shelf';
                        placed++;
                        await new Promise(resolve => setTimeout(resolve, delayMs));
                    }
                }
            }
            async placeRobotsWithDelay(delayMs) {
                const grid = this.generateGrid(this.gameParams.robotRows, this.gameParams.robotCols);
                this.shuffleArray(grid);
                let robotId = 0;
                let lowChargePlaced = false;
                for (const pos of grid) {
                    if (robotId >= this.gameParams.robotsCount) break;
                    const key = `${pos.row},${pos.col}`;
                    if (!this.isCellOccupied(key)) {
                        let charge = !lowChargePlaced ?
                            Math.floor(Math.random() * 11) + 15 :
                            Math.floor(Math.random() * 76) + 25;
                        if (!lowChargePlaced) lowChargePlaced = true;
                        this.state.robots.set(robotId, {
                            row: pos.row,
                            col: pos.col,
                            charge,
                            hasShelf: false,
                            route: null,
                            isCharging: false
                        });
                        const cell = this.getCell(pos.row, pos.col);
                        cell.className = 'cell';
                        this.addRobotImage(cell, 'Robot.png');
                        this.addChargeBar(cell, charge);
                        robotId++;
                        await new Promise(resolve => setTimeout(resolve, delayMs));
                    }
                }
            }
            generateGrid(range, cols) {
                const grid = [];
                for (let r = range.min; r <= range.max; r++) {
                    for (let c = cols.min; c <= cols.max; c++) {
                        grid.push({ row: r, col: c });
                    }
                }
                return grid;
            }
            isPositionValid(pos, set, minDistance) {
                for (const key of set) {
                    const [r, c] = key.split(',').map(Number);
                    const d = Math.abs(pos.row - r) + Math.abs(pos.col - c);
                    if (d < minDistance) return false;
                }
                return true;
            }
            isCellOccupied(key) {
                for (const [id, robot] of this.state.robots) {
                    if (`${robot.row},${robot.col}` === key) return true;
                }
                return false;
            }
            getCell(row, col) {
                return this.board.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            }
            addRobotImage(cell, imageUrl) {
                // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–æ–±–æ—Ç–∞, –µ—Å–ª–∏ –µ—Å—Ç—å
                const existingImage = cell.querySelector('.robot-image');
                if (existingImage) cell.removeChild(existingImage);
                const robotImage = document.createElement('div');
                robotImage.className = 'robot-image';
                robotImage.style.backgroundImage = `url('${imageUrl}')`;
                cell.appendChild(robotImage);
                return robotImage;
            }
            addChargeBar(cell, charge) {
                // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é –ø–æ–ª–æ—Å—É –∑–∞—Ä—è–¥–∞, –µ—Å–ª–∏ –µ—Å—Ç—å
                const chargeBar = cell.querySelector('.charge-bar');
                if (chargeBar) cell.removeChild(chargeBar);
                const newBar = document.createElement('div');
                newBar.className = 'charge-bar';
                const level = document.createElement('div');
                level.className = 'charge-level';
                if (charge < 25) level.classList.add('low');
                else if (charge < 50) level.classList.add('medium');
                else if (charge < 75) level.classList.add('good');
                else level.classList.add('high');
                level.style.width = charge + '%';
                newBar.appendChild(level);
                cell.appendChild(newBar);
                return newBar;
            }
            updateTimerDisplay() {
                const minutes = Math.floor(this.remainingTime / 60);
                const seconds = this.remainingTime % 60;
                this.timerElement.textContent = `–í—Ä–µ–º—è: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            setupEventListeners() {
                this.board.addEventListener('click', (e) => {
                    if (this.gameOver) return; // –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞ ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
                    // üéØ –°–¢–ê–ë–ò–õ–¨–ù–´–ô –í–´–ë–û–† –†–û–ë–û–¢–ê: –ø–æ–ª—É—á–∞–µ–º –∫–ª–µ—Ç–∫—É ‚Äî –í–°–ï–ì–î–ê —á–µ—Ä–µ–∑ closest('.cell')
                    let cell = e.target.closest('.cell');
                    if (!cell) {
                        // –ü–æ–¥–Ω–∏–º–∞–µ–º—Å—è –ø–æ DOM-–¥–µ—Ä–µ–≤—É, –ø–æ–∫–∞ –Ω–µ –Ω–∞–π–¥—ë–º .cell
                        let parent = e.target.parentElement;
                        while (parent && !cell) {
                            if (parent.classList && parent.classList.contains('cell')) {
                                cell = parent;
                            } else {
                                parent = parent.parentElement;
                            }
                        }
                    }
                    if (!cell) return;
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const key = `${row},${col}`;
                    // –ï—Å–ª–∏ –∫–ª–∏–∫ –ø–æ —Å—Ç–æ–ª–±—É ‚Äî –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
                    if (this.state.obstacles.has(key)) return;
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ä–æ–±–æ—Ç –≤ —ç—Ç–æ–π –∫–ª–µ—Ç–∫–µ ‚Äî –í–°–ï–ì–î–ê –≤—ã–±–∏—Ä–∞–µ–º –µ–≥–æ –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ –∫–ª–µ—Ç–∫—É
                    let clickedRobotId = null;
                    for (const [id, robot] of this.state.robots) {
                        if (robot.row === row && robot.col === col) {
                            clickedRobotId = id;
                            break;
                        }
                    }
                    if (clickedRobotId !== null) {
                        const robot = this.state.robots.get(clickedRobotId);
                        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ –º–∏–≥–∞–Ω–∏–µ –ø—Ä–∏ —Å–º–µ–Ω–µ —Ä–æ–±–æ—Ç–∞
                        if (this.selectedRobot !== clickedRobotId && this.constantBlinkInterval) {
                            clearInterval(this.constantBlinkInterval);
                            this.constantBlinkInterval = null;
                            this.movesElement.style.backgroundColor = '';
                        }
                        // –ï—Å–ª–∏ –∫–ª–∏–∫ –ø–æ —É–∂–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Ä–æ–±–æ—Ç—É ‚Äî –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Ü–µ–ª–∏
                        if (this.selectedRobot === clickedRobotId) {
                            this.startTargetBlinking(robot);
                            this.movesElement.textContent = `–ó–∞—Ä—è–¥ —Ä–æ–±–æ—Ç–∞: ${robot.charge}%`;
                            return;
                        }
                        // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Ä–æ–±–æ—Ç–∞
                        if (this.selectedRobot !== null) {
                            const prevRobot = this.state.robots.get(this.selectedRobot);
                            const prevCell = this.getCell(prevRobot.row, prevRobot.col);
                            if (prevCell) prevCell.classList.remove('selected');
                        }
                        this.selectedRobot = clickedRobotId;
                        this.movesElement.textContent = `–ó–∞—Ä—è–¥ —Ä–æ–±–æ—Ç–∞: ${robot.charge}%`;
                        const robotCell = this.getCell(robot.row, robot.col);
                        if (robotCell) {
                            robotCell.classList.add('selected');
                        }
                        if (!this.gameStarted) {
                            this.gameStarted = true;
                            this.timerInterval = setInterval(() => {
                                this.remainingTime--;
                                this.updateTimerDisplay();
                                if (this.remainingTime <= 0) {
                                    clearInterval(this.timerInterval);
                                }
                            }, 1000);
                        }
                        this.startTargetBlinking(robot);
                    }
                    // –ö–ª–∏–∫ –ø–æ –∫–ª–µ—Ç–∫–µ ‚Äî –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Ä—à—Ä—É—Ç–∞ (–¥–∞–∂–µ –µ—Å–ª–∏ —Ç–∞–º —Ä–æ–±–æ—Ç ‚Äî —Å–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–µ—Ç—Å—è —Ä–æ–±–æ—Ç, –Ω–æ –µ—Å–ª–∏ –æ–Ω —É–∂–µ –≤—ã–±—Ä–∞–Ω ‚Äî —Å—Ç—Ä–æ–∏–º –º–∞—Ä—à—Ä—É—Ç)
                    else if (this.selectedRobot !== null) {
                        this.setRobotTarget(this.selectedRobot, row, col);
                    }
                });
            }
            startTargetBlinking(robot) {
                this.stopAllBlinking();
                let targets;
                if (robot.hasShelf) {
                    targets = robot.charge < 25 ? this.state.chargingStations : this.state.parkingCells;
                } else {
                    // –î–ª—è –ø—É—Å—Ç–æ–≥–æ —Ä–æ–±–æ—Ç–∞: –∑–∞—Ä—è–¥–∫–∞ (–µ—Å–ª–∏ –º–∞–ª–æ –∑–∞—Ä—è–¥–∞) –∏–ª–∏ —Å—Ç–æ–ª—ã (shelf)
                    targets = robot.charge < 25 ? this.state.chargingStations : this.state.shelves;
                }
                for (const key of targets) {
                    const [r, c] = key.split(',').map(Number);
                    const cell = this.getCell(r, c);
                    if (cell && this.isCellAvailableForTarget(key)) {
                        cell.classList.add('target-cell');
                        this.addBlinkingAnimation(cell);
                    }
                }
            }
            isCellAvailableForTarget(key) {
                // –ó–∞–Ω—è—Ç–∞ —Ä–æ–±–æ—Ç–æ–º?
                if (this.isCellOccupied(key)) return false;
                // –ó–∞–Ω—è—Ç–∞ —á—É–∂–∏–º –º–∞—Ä—à—Ä—É—Ç–æ–º?
                for (const [otherId, route] of this.state.activeRoutes) {
                    if (otherId === this.selectedRobot) continue; // —Å–≤–æ–π –º–∞—Ä—à—Ä—É—Ç ‚Äî –º–æ–∂–Ω–æ
                    if (route && route.some(step => `${step.row},${step.col}` === key)) {
                        return false;
                    }
                }
                return true;
            }
            addBlinkingAnimation(cell) {
                if (cell.classList.contains('blinking-cell')) return;
                cell.classList.add('blinking-cell');
                const parts = ['top', 'right', 'bottom', 'left'].map((side, i) => {
                    const part = document.createElement('div');
                    part.className = 'moving-part';
                    part.style[side] = '0';
                    part.style.width = ['top', 'bottom'].includes(side) ? '20%' : '2px';
                    part.style.height = ['left', 'right'].includes(side) ? '20%' : '2px';
                    cell.appendChild(part);
                    return part;
                });
                let step = 0;
                const interval = setInterval(() => {
                    parts.forEach((part, i) => {
                        const pos = (step * 25) + '%';
                        if (i === 0) part.style.left = pos;
                        if (i === 1) part.style.top = pos;
                        if (i === 2) part.style.right = pos;
                        if (i === 3) part.style.bottom = pos;
                    });
                    step = (step + 1) % 4;
                }, 150);
                this.state.activeAnimations = this.state.activeAnimations || new Set();
                this.state.activeAnimations.add({ cell, interval, type: 'blink' });
            }
            stopAllBlinking() {
                if (!this.state.activeAnimations) return;
                this.state.activeAnimations.forEach(data => {
                    if (data.type === 'blink') {
                        clearInterval(data.interval);
                        data.cell.classList.remove('blinking-cell');
                        data.cell.querySelectorAll('.moving-part').forEach(el => el.remove());
                    }
                });
                this.state.activeAnimations.clear();
                const cells = this.board.querySelectorAll('.cell');
                cells.forEach(cell => {
                    cell.classList.remove('target-cell');
                    cell.querySelectorAll('.moving-part').forEach(el => el.remove());
                });
            }
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
            // === –û–°–ù–û–í–ù–ê–Ø –õ–û–ì–ò–ö–ê –ú–ê–†–®–†–£–¢–ê ===
            async blinkElement(element, color = '#ff0000', times = 3) {
                for (let i = 0; i < times; i++) {
                    element.style.backgroundColor = color;
                    await new Promise(resolve => setTimeout(resolve, 150));
                    element.style.backgroundColor = '';
                    await new Promise(resolve => setTimeout(resolve, 150));
                }
            }
            setRobotTarget(robotId, targetRow, targetCol) {
                if (this.gameOver) return;
                const robot = this.state.robots.get(robotId);
                if (!robot) return;
                const targetKey = `${targetRow},${targetCol}`;
                const currentClickTarget = `${robotId}:${targetKey}`;
                // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –¥–ª—è —ç—Ç–æ–π –ø–∞—Ä—ã
                let count = this.warningCount.get(currentClickTarget) || 0;
                // –ü—Ä–µ—Ä—ã–≤–∞–µ–º —Ç–µ–∫—É—â–µ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
                if (this.state.movingRobots.has(robotId)) {
                    if (this.abortControllers.has(robotId)) {
                        this.abortControllers.get(robotId).abort();
                    }
                    this.state.movingRobots.delete(robotId);
                }
                // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –º–∞—Ä—à—Ä—É—Ç –∏ –ª–∏–Ω–∏–∏
                this.clearRobotRoute(robotId);
                this.stopAllBlinking();
                const targetCell = this.getCell(targetRow, targetCol);
                if (!targetCell) return;
                // –°—Ç–æ–ª–±—ã ‚Äî –Ω–µ–ª—å–∑—è
                if (this.state.obstacles.has(targetKey)) {
                    this.blinkElement(this.movesElement, '#ff0000', 3);
                    return;
                }
                // üî•üî•üî• –ì–õ–ê–í–ù–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –µ—Å–ª–∏ —Ü–µ–ª—å ‚Äî –∑–∞—Ä—è–¥–∫–∞ ‚Äî —Å—Ç—Ä–æ–∏–º –º–∞—Ä—à—Ä—É—Ç –í–°–ï–ì–î–ê, –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–æ–∫ –∑–∞—Ä—è–¥–∞
                if (this.state.chargingStations.has(targetKey)) {
                    console.log(`[DEBUG] –¶–µ–ª—å ‚Äî –∑–∞—Ä—è–¥–∫–∞ (${targetRow}, ${targetCol}). –°—Ç—Ä–æ–∏–º –º–∞—Ä—à—Ä—É—Ç.`);
                    this.warningCount.set(currentClickTarget, 0);
                    if (this.constantBlinkInterval) {
                        clearInterval(this.constantBlinkInterval);
                        this.constantBlinkInterval = null;
                        this.movesElement.style.backgroundColor = '';
                    }
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞—Ä—è–¥–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ —Ü–µ–ª—å
                    if (!this.isCellPassable(targetRow, targetCol, robot.hasShelf, true, true, robotId)) {
                        console.log(`[DEBUG] –ó–∞—Ä—è–¥–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ —Ü–µ–ª—å.`);
                        return;
                    }
                    // üî•üî•üî• –í–†–ï–ú–ï–ù–ù–û –£–î–ê–õ–Ø–ï–ú –î–†–£–ì–ò–ï –ó–ê–†–Ø–î–ö–ò
                    const tempChargingStations = new Set(this.state.chargingStations);
                    // –û—Å—Ç–∞–≤–ª—è–µ–º –≤ —Ä–µ–µ—Å—Ç—Ä–µ –¢–û–õ–¨–ö–û —Ü–µ–ª–µ–≤—É—é –∑–∞—Ä—è–¥–∫—É
                    this.state.chargingStations.clear();
                    this.state.chargingStations.add(targetKey);
                    // –°—Ç—Ä–æ–∏–º –ø—É—Ç—å
                    const result = this.findPath(
                        robot.row, robot.col,
                        targetRow, targetCol,
                        robot.hasShelf,
                        robotId
                    );
                    // üî•üî•üî• –í–û–°–°–¢–ê–ù–ê–í–õ–ò–í–ê–ï–ú –ó–ê–†–Ø–î–ö–ò –ü–û–°–õ–ï –ü–û–°–¢–†–û–ï–ù–ò–Ø –ú–ê–†–®–†–£–¢–ê, –ù–û –ü–ï–†–ï–î –ï–ì–û –ó–ê–ü–£–°–ö–û–ú
                    if (!result.route || result.route.length === 0) {
                        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞—Ä—è–¥–∫–∏ –î–û –≤—ã—Ö–æ–¥–∞, –µ—Å–ª–∏ –º–∞—Ä—à—Ä—É—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
                        this.state.chargingStations = tempChargingStations;
                        console.log(`[DEBUG] –ú–∞—Ä—à—Ä—É—Ç –Ω–∞ –∑–∞—Ä—è–¥–∫—É –ù–ï –ø–æ—Å—Ç—Ä–æ–µ–Ω.`);
                        this.blinkObstacleCells(result.obstacles.map(key => {
                            const [r, c] = key.split(',').map(Number);
                            return { row: r, col: c };
                        }));
                        return;
                    }
                    console.log(`[DEBUG] –ú–∞—Ä—à—Ä—É—Ç –Ω–∞ –∑–∞—Ä—è–¥–∫—É –£–°–ü–ï–®–ù–û –ø–æ—Å—Ç—Ä–æ–µ–Ω. –î–ª–∏–Ω–∞: ${result.route.length}`);
                    // –ü–µ—Ä–µ–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ä–µ–µ—Å—Ç—Ä –∑–∞—Ä—è–¥–æ–∫ –≤ buildAndStartRoute
                    this.buildAndStartRoute(robotId, result.route, tempChargingStations);
                    return;
                }
                // –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ü–µ–ª–µ–π ‚Äî –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞—Ä—è–¥–∞
                const result = this.findPath(
                    robot.row, robot.col,
                    targetRow, targetCol,
                    robot.hasShelf,
                    robotId
                );
                if (!result.route || result.route.length === 0) {
                    console.log("[DEBUG] –ú–∞—Ä—à—Ä—É—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω (–æ—Å–Ω–æ–≤–Ω–æ–π –∞–ª–≥–æ—Ä–∏—Ç–º)");
                    this.blinkObstacleCells(result.obstacles.map(key => {
                        const [r, c] = key.split(',').map(Number);
                        return { row: r, col: c };
                    }));
                    return;
                }
                const route = result.route;
                const routeLength = route.length - 1;
                const requiredCharge = routeLength * 2;
                const finalCharge = robot.charge - requiredCharge;
                if (finalCharge < 25) {
                    count++;
                    this.warningCount.set(currentClickTarget, count);
                    if (count === 1) {
                        this.blinkElement(this.movesElement, '#ff0000', 3);
                        const emptyChargers = [];
                        for (const key of this.state.chargingStations) {
                            if (!this.isCellOccupied(key)) {
                                const [r, c] = key.split(',').map(Number);
                                emptyChargers.push({ row: r, col: c });
                            }
                        }
                        this.blinkObstacleCells(emptyChargers, '#00ff00');
                        return;
                    } else if (count === 2) {
                        this.blinkElement(this.movesElement, '#ff0000', 3);
                        return;
                    } else if (count === 3) {
                        this.blinkElement(this.movesElement, '#ff0000', 3);
                        return;
                    } else {
                        this.startConstantBlinking(this.movesElement, '#ff0000');
                    }
                } else {
                    this.warningCount.set(currentClickTarget, 0);
                    if (this.constantBlinkInterval) {
                        clearInterval(this.constantBlinkInterval);
                        this.constantBlinkInterval = null;
                        this.movesElement.style.backgroundColor = '';
                    }
                }
                this.buildAndStartRoute(robotId, route);
            }
            // üî•üî•üî• –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä tempChargingStations
            buildAndStartRoute(robotId, route, tempChargingStations = null) {
                const robot = this.state.robots.get(robotId);
                if (!robot) return;
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∞—Ä—à—Ä—É—Ç
                robot.route = route;
                this.state.activeRoutes.set(robotId, route);
                // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º –º–∞—Ä—à—Ä—É—Ç
                this.drawRoute(robotId, route);
                // üî•üî•üî• –í–û–°–°–¢–ê–ù–ê–í–õ–ò–í–ê–ï–ú –ó–ê–†–Ø–î–ö–ò –ü–ï–†–ï–î –ó–ê–ü–£–°–ö–û–ú –î–í–ò–ñ–ï–ù–ò–Ø
                if (tempChargingStations) {
                    this.state.chargingStations = tempChargingStations;
                }
                // –ó–∞–ø—É—Å–∫–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ
                this.startRobotMovement(robotId);
            }
            startConstantBlinking(element, color = '#ff0000') {
                if (this.constantBlinkInterval) {
                    clearInterval(this.constantBlinkInterval);
                }
                let isOn = true;
                this.constantBlinkInterval = setInterval(() => {
                    if (isOn) {
                        element.style.backgroundColor = color;
                    } else {
                        element.style.backgroundColor = '';
                    }
                    isOn = !isOn;
                }, 250);
            }
            async blinkObstacleCells(cells, color = '#ff0000') {
                if (!cells || cells.length === 0) return;
                const uniqueCells = Array.from(new Set(cells.map(c => `${c.row},${c.col}`)))
                    .map(key => {
                        const [r, c] = key.split(',').map(Number);
                        return { row: r, col: c };
                    });
                const blinkPromises = uniqueCells.map(({ row, col }) => {
                    return new Promise(resolve => {
                        const cell = this.getCell(row, col);
                        if (!cell) {
                            resolve();
                            return;
                        }
                        let count = 0;
                        const blink = () => {
                            if (count >= 3) {
                                resolve();
                                return;
                            }
                            cell.style.backgroundColor = color;
                            setTimeout(() => {
                                cell.style.backgroundColor = '';
                                setTimeout(blink, 150);
                                count++;
                            }, 150);
                        };
                        blink();
                    });
                });
                await Promise.all(blinkPromises);
            }
            // üî•üî•üî• –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î: –î–æ–±–∞–≤–ª–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä isFinalDestination
            isCellPassable(row, col, isRobotCarryingShelf, ignoreRoute = false, isFinalDestination = false, forRobotId = null) {
                const key = `${row},${col}`;
                const cell = this.getCell(row, col);
                if (!cell) {
                    console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ DOM.`);
                    return false;
                }
                // –°—Ç–æ–ª–±—ã ‚Äî –Ω–∏–∫–æ–≥–¥–∞
                if (this.state.obstacles.has(key)) {
                    console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî —Å—Ç–æ–ª–±. –ù–µ–ø—Ä–æ—Ö–æ–¥–∏–º–∞.`);
                    return false;
                }
                // –î—Ä—É–≥–∏–µ —Ä–æ–±–æ—Ç—ã ‚Äî –Ω–µ–ª—å–∑—è
                if (this.isCellOccupied(key)) {
                    console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) –∑–∞–Ω—è—Ç–∞ –¥—Ä—É–≥–∏–º —Ä–æ–±–æ—Ç–æ–º. –ù–µ–ø—Ä–æ—Ö–æ–¥–∏–º–∞.`);
                    return false;
                }
                // –ï—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ –∑–∞–Ω—è—Ç–∞ —á—É–∂–∏–º –º–∞—Ä—à—Ä—É—Ç–æ–º ‚Äî –Ω–µ–ª—å–∑—è (–µ—Å–ª–∏ –Ω–µ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º)
                if (!ignoreRoute) {
                    for (const [otherId, route] of this.state.activeRoutes) {
                        if (otherId === forRobotId) continue;
                        if (route && route.some(step => step.row === row && step.col === col)) {
                            console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) –∑–∞–Ω—è—Ç–∞ —á—É–∂–∏–º –º–∞—Ä—à—Ä—É—Ç–æ–º (—Ä–æ–±–æ—Ç ${otherId}). –ù–µ–ø—Ä–æ—Ö–æ–¥–∏–º–∞.`);
                            return false;
                        }
                    }
                }
                // üî•üî•üî• –û–°–ù–û–í–ù–ê–Ø –õ–û–ì–ò–ö–ê: –†–∞–∑–¥–µ–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –¥–ª—è "–ø—Ä–æ–µ–∑–¥–∞" –∏ "–æ—Å—Ç–∞–Ω–æ–≤–∫–∏"
                if (isFinalDestination) {
                    // –≠—Ç–æ –ö–û–ù–ï–ß–ù–ê–Ø –¶–ï–õ–¨ ‚Äî –ø—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –∑–¥–µ—Å—å –û–°–¢–ê–ù–û–í–ò–¢–¨–°–Ø
                    if (this.state.chargingStations.has(key)) {
                        // –ù–∞ –∑–∞—Ä—è–¥–∫—É –º–æ–∂–Ω–æ –≤—Å—Ç–∞—Ç—å –≤—Å–µ–≥–¥–∞ (—Ä–æ–±–æ—Ç —Å–∫–∏–Ω–µ—Ç –≥—Ä—É–∑, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
                        console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî –∑–∞—Ä—è–¥–∫–∞. –î–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ –¶–ï–õ–¨.`);
                        return true;
                    }
                    if (this.state.shelves.has(key)) {
                        // –ù–∞ —Å—Ç–æ–ª –º–æ–∂–Ω–æ –≤—Å—Ç–∞—Ç—å –¢–û–õ–¨–ö–û –µ—Å–ª–∏ —Ä–æ–±–æ—Ç –ë–ï–ó –≥—Ä—É–∑–∞
                        if (!isRobotCarryingShelf) {
                            console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî —Å—Ç–æ–ª. –î–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ –¶–ï–õ–¨ (—Ä–æ–±–æ—Ç –±–µ–∑ –≥—Ä—É–∑–∞).`);
                            return true;
                        } else {
                            console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî —Å—Ç–æ–ª. –ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ –¶–ï–õ–¨ (—Ä–æ–±–æ—Ç —Å –≥—Ä—É–∑–æ–º).`);
                            return false;
                        }
                    }
                    if (this.state.parkingCells.has(key)) {
                        // –ù–∞ –ø–∞—Ä–∫–æ–≤–∫—É –º–æ–∂–Ω–æ –≤—Å—Ç–∞—Ç—å –¢–û–õ–¨–ö–û –µ—Å–ª–∏ —Ä–æ–±–æ—Ç –° –≥—Ä—É–∑–æ–º
                        if (isRobotCarryingShelf) {
                            console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî –ø–∞—Ä–∫–æ–≤–∫–∞. –î–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ –¶–ï–õ–¨ (—Ä–æ–±–æ—Ç —Å –≥—Ä—É–∑–æ–º).`);
                            return true;
                        } else {
                            console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî –ø–∞—Ä–∫–æ–≤–∫–∞. –ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ –¶–ï–õ–¨ (—Ä–æ–±–æ—Ç –±–µ–∑ –≥—Ä—É–∑–∞).`);
                            return false;
                        }
                    }
                    // –õ—é–±–∞—è –¥—Ä—É–≥–∞—è –∫–ª–µ—Ç–∫–∞ (–ø—É—Å—Ç–∞—è) ‚Äî –º–æ–∂–Ω–æ –≤—Å—Ç–∞—Ç—å
                    console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî –ø—É—Å—Ç–∞—è. –î–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ –¶–ï–õ–¨.`);
                    return true;
                } else {
                    // –≠—Ç–æ –ü–†–û–ú–ï–ñ–£–¢–û–ß–ù–ê–Ø –∫–ª–µ—Ç–∫–∞ ‚Äî –ø—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ —á–µ—Ä–µ–∑ –Ω–µ—ë –ü–†–û–ï–•–ê–¢–¨
                    if (this.state.chargingStations.has(key)) {
                        // –ß–µ—Ä–µ–∑ –∑–∞—Ä—è–¥–∫—É –ù–ï–õ–¨–ó–Ø –ø—Ä–æ–µ–∑–∂–∞—Ç—å, –µ—Å–ª–∏ —Ç–æ–ª—å–∫–æ –æ–Ω–∞ –Ω–µ —Ü–µ–ª—å
                        console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî –∑–∞—Ä—è–¥–∫–∞. –ù–ï–ü–†–û–•–û–î–ò–ú–ê –¥–ª—è –ü–†–û–ï–ó–î–ê.`);
                        return false;
                    }
                    if (this.state.shelves.has(key)) {
                        // –ß–µ—Ä–µ–∑ —Å—Ç–æ–ª –ú–û–ñ–ù–û –ø—Ä–æ–µ–∑–∂–∞—Ç—å –¢–û–õ–¨–ö–û –µ—Å–ª–∏ —Ä–æ–±–æ—Ç –ë–ï–ó –≥—Ä—É–∑–∞
                        if (!isRobotCarryingShelf) {
                            console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî —Å—Ç–æ–ª. –î–æ—Å—Ç—É–ø–Ω–∞ –¥–ª—è –ü–†–û–ï–ó–î–ê (–ø—É—Å—Ç–æ–π —Ä–æ–±–æ—Ç).`);
                            return true;
                        } else {
                            console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî —Å—Ç–æ–ª. –ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –¥–ª—è –ü–†–û–ï–ó–î–ê (—Ä–æ–±–æ—Ç —Å –≥—Ä—É–∑–æ–º).`);
                            return false;
                        }
                    }
                    // –ü–∞—Ä–∫–æ–≤–∫–∞ –∏ –ø—É—Å—Ç—ã–µ –∫–ª–µ—Ç–∫–∏ ‚Äî –≤—Å–µ–≥–¥–∞ –º–æ–∂–Ω–æ –ø—Ä–æ–µ–∑–∂–∞—Ç—å
                    console.log(`[DEBUG] isCellPassable: –ö–ª–µ—Ç–∫–∞ (${row}, ${col}) ‚Äî –ø—É—Å—Ç–∞—è –∏–ª–∏ –ø–∞—Ä–∫–æ–≤–∫–∞. –î–æ—Å—Ç—É–ø–Ω–∞ –¥–ª—è –ü–†–û–ï–ó–î–ê.`);
                    return true;
                }
            }
            findPath(startRow, startCol, endRow, endCol, isRobotCarryingShelf, forRobotId) {
                const queue = [];
                const visited = new Set();
                const parent = {};
                const localObstacleCells = new Set();
                const endKey = `${endRow},${endCol}`;
                queue.push({ row: startRow, col: startCol });
                visited.add(`${startRow},${startCol}`);
                const directions = [
                    { row: 0, col: 1 },   // –≤–ø—Ä–∞–≤–æ
                    { row: 1, col: 0 },   // –≤–Ω–∏–∑
                    { row: 0, col: -1 },  // –≤–ª–µ–≤–æ
                    { row: -1, col: 0 }   // –≤–≤–µ—Ä—Ö
                ];
                while (queue.length > 0) {
                    const current = queue.shift();
                    const currentKey = `${current.row},${current.col}`;
                    // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï –ù–ê–ß–ê–õ–û ---
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ —Ç–µ–∫—É—â–∞—è –∫–ª–µ—Ç–∫–∞ - —ç—Ç–æ —Ü–µ–ª—å, –ø—É—Ç—å –Ω–∞–π–¥–µ–Ω.
                    // –≠—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–æ–∏–∑–æ–π—Ç–∏, –µ—Å–ª–∏ —Å—Ç–∞—Ä—Ç–æ–≤–∞—è –∫–ª–µ—Ç–∫–∞ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –∫–æ–Ω–µ—á–Ω–æ–π.
                    if (current.row === endRow && current.col === endCol) {
                         // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω–µ—á–Ω–∞—è –∫–ª–µ—Ç–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ —Ü–µ–ª—å
                        if (!this.isCellPassable(endRow, endCol, isRobotCarryingShelf, true, true, forRobotId)) {
                            localObstacleCells.add(endKey);
                            return { route: null, obstacles: Array.from(localObstacleCells) };
                        }
                        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—É—Ç—å
                        const path = [];
                        let step = current;
                        while (step) {
                            path.unshift(step);
                            const stepKey = `${step.row},${step.col}`;
                            step = parent[stepKey];
                        }
                        return { route: path, obstacles: [] };
                    }
                    // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï –ö–û–ù–ï–¶ ---
                    for (const dir of directions) {
                        const newRow = current.row + dir.row;
                        const newCol = current.col + dir.col;
                        if (newRow < 0 || newRow >= this.rows || newCol < 0 || newCol >= this.cols) continue;
                        const newKey = `${newRow},${newCol}`;
                        if (visited.has(newKey)) continue;
                        // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï –ù–ê–ß–ê–õ–û ---
                        // –ü—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ —Å–æ—Å–µ–¥–Ω—è—è –∫–ª–µ—Ç–∫–∞ - —ç—Ç–æ —Ü–µ–ª—å
                        if (newRow === endRow && newCol === endCol) {
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω–µ—á–Ω–∞—è –∫–ª–µ—Ç–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ —Ü–µ–ª—å
                            if (this.isCellPassable(endRow, endCol, isRobotCarryingShelf, true, true, forRobotId)) {
                                // –ï—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞, —Å—Ç—Ä–æ–∏–º –ø—É—Ç—å
                                const path = [];
                                const finalStep = { row: newRow, col: newCol };
                                let step = current; // –ù–∞—á–∏–Ω–∞–µ–º —Å —Ç–µ–∫—É—â–µ–π –∫–ª–µ—Ç–∫–∏ (–ø—Ä–µ–¥—à–µ—Å—Ç–≤–µ–Ω–Ω–∏–∫–∞ —Ü–µ–ª–∏)
                                while (step) {
                                    path.unshift(step);
                                    const stepKey = `${step.row},${step.col}`;
                                    step = parent[stepKey];
                                }
                                path.push(finalStep); // –î–æ–±–∞–≤–ª—è–µ–º —Å–∞–º—É —Ü–µ–ª—å –≤ –∫–æ–Ω–µ—Ü –ø—É—Ç–∏
                                return { route: path, obstacles: [] };
                            } else {
                                // –ï—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∫ —Ü–µ–ª—å, —Å—á–∏—Ç–∞–µ–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ–º
                                localObstacleCells.add(newKey);
                                // –ò –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å
                                continue;
                            }
                        }
                        // --- –ò–ó–ú–ï–ù–ï–ù–ò–ï –ö–û–ù–ï–¶ ---
                        // üî• –ü—Ä–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–∏ –ø—É—Ç–∏ –¥–ª—è –ü–†–û–ú–ï–ñ–£–¢–û–ß–ù–´–• –∫–ª–µ—Ç–æ–∫ –∏—Å–ø–æ–ª—å–∑—É–µ–º isFinalDestination = false
                        if (this.isCellPassable(newRow, newCol, isRobotCarryingShelf, false, false, forRobotId)) {
                            visited.add(newKey);
                            parent[newKey] = current;
                            queue.push({ row: newRow, col: newCol });
                        } else {
                            localObstacleCells.add(newKey);
                        }
                    }
                }
                return { route: null, obstacles: Array.from(localObstacleCells) };
            }
            // üî• –£–î–ê–õ–ï–ù –ú–ï–¢–û–î findPathSimple ‚Äî –æ–Ω –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–µ–Ω.
            // –í—Å–µ –º–∞—Ä—à—Ä—É—Ç—ã —Å—Ç—Ä–æ—è—Ç—Å—è —á–µ—Ä–µ–∑ BFS (findPath).
            drawRoute(robotId, route) {
                this.clearRobotRouteLines(robotId);
                const lines = [];
                for (let i = 0; i < route.length - 1; i++) {
                    const from = route[i];
                    const to = route[i + 1];
                    const line = this.drawLineBetweenCells(from.row, from.col, to.row, to.col);
                    if (line) {
                        lines.push(line);
                        this.board.appendChild(line);
                    }
                }
                this.state.routeLines.set(robotId, lines);
            }
            drawLineBetweenCells(row1, col1, row2, col2) {
                const cell1 = this.getCell(row1, col1);
                const cell2 = this.getCell(row2, col2);
                if (!cell1 || !cell2) return null;
                const rect1 = cell1.getBoundingClientRect();
                const rect2 = cell2.getBoundingClientRect();
                const boardRect = this.board.getBoundingClientRect();
                const x1 = rect1.left + rect1.width / 2 - boardRect.left;
                const y1 = rect1.top + rect1.height / 2 - boardRect.top;
                const x2 = rect2.left + rect2.width / 2 - boardRect.left;
                const y2 = rect2.top + rect2.height / 2 - boardRect.top;
                const line = document.createElement('div');
                line.className = 'route-line';
                const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                line.style.width = `${length}px`;
                line.style.height = '2px';
                line.style.left = `${x1}px`;
                line.style.top = `${y1}px`;
                line.style.transformOrigin = '0 0';
                line.style.transform = `rotate(${angle}deg)`;
                return line;
            }
            clearRobotRoute(robotId) {
                this.clearRobotRouteLines(robotId);
                this.state.activeRoutes.delete(robotId);
                const robot = this.state.robots.get(robotId);
                if (robot) robot.route = null;
            }
            clearRobotRouteLines(robotId) {
                const lines = this.state.routeLines.get(robotId);
                if (lines) {
                    lines.forEach(line => {
                        if (line && line.parentNode) {
                            line.remove();
                        }
                    });
                }
                this.state.routeLines.delete(robotId);
            }
            async startRobotMovement(robotId) {
                const robot = this.state.robots.get(robotId);
                if (!robot || !robot.route || robot.route.length <= 1) return;
                if (this.abortControllers.has(robotId)) {
                    this.abortControllers.get(robotId).abort();
                }
                const abortController = new AbortController();
                this.abortControllers.set(robotId, abortController);
                const signal = abortController.signal;
                this.state.movingRobots.add(robotId);
                const route = [...robot.route];
                const lines = this.state.routeLines.get(robotId) || [];
                try {
                    for (let i = 1; i < route.length; i++) {
                        if (signal.aborted) {
                            console.log(`–î–≤–∏–∂–µ–Ω–∏–µ —Ä–æ–±–æ—Ç–∞ ${robotId} –ø—Ä–µ—Ä–≤–∞–Ω–æ.`);
                            if (this.selectedRobot === robotId) {
                                this.stopAllBlinking();
                            }
                            // üî•üî•üî• –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö –∫–ª–µ—Ç–æ–∫ –º–∞—Ä—à—Ä—É—Ç–∞ –ø—Ä–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–∏
                            const currentRoute = this.state.activeRoutes.get(robotId);
                            if (currentRoute) {
                                for (const step of currentRoute) {
                                    const stepCell = this.getCell(step.row, step.col);
                                    if (stepCell) {
                                        this.restoreCellState(stepCell, step.row, step.col);
                                    }
                                }
                            }
                            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–æ–±–æ—Ç–∞ –≤ –µ–≥–æ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏
                            const currentCell = this.getCell(robot.row, robot.col);
                            if (currentCell) {
                                // –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –∫–ª–µ—Ç–∫–∏
                                while (currentCell.firstChild) {
                                    currentCell.removeChild(currentCell.firstChild);
                                }
                                currentCell.className = 'cell';
                                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–Ω –∫–ª–µ—Ç–∫–∏
                                const currentKey = `${robot.row},${robot.col}`;
                                if (this.state.parkingCells.has(currentKey)) currentCell.classList.add('parking');
                                else if (this.state.obstacles.has(currentKey)) currentCell.classList.add('column');
                                else if (this.state.chargingStations.has(currentKey)) currentCell.classList.add('charging-station');
                                else if (this.state.shelves.has(currentKey)) currentCell.classList.add('shelf');
                                // –î–æ–±–∞–≤–ª—è–µ–º —Ä–æ–±–æ—Ç–∞ –æ–±—Ä–∞—Ç–Ω–æ
                                this.addRobotImage(currentCell, 'Robot.png');
                                this.addChargeBar(currentCell, robot.charge);
                                // –ï—Å–ª–∏ —Ä–æ–±–æ—Ç –≤—ã–±—Ä–∞–Ω, –¥–æ–±–∞–≤–ª—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
                                if (this.selectedRobot === robotId) {
                                    currentCell.classList.add('selected');
                                }
                            }
                            break;
                        }
                        const prevStep = route[i - 1];
                        const nextStep = route[i];
                        const currentCell = this.getCell(prevStep.row, prevStep.col);
                        const nextCell = this.getCell(nextStep.row, nextStep.col);
                        if (!nextCell) break;

                        // –ü—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ —Å–ª–µ–¥—É—é—â–∞—è –∫–ª–µ—Ç–∫–∞ ‚Äî –∑–∞—Ä—è–¥–∫–∞ –∏ —Ä–æ–±–æ—Ç –≤–µ–∑—ë—Ç –≥—Ä—É–∑ ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –≥—Ä—É–∑ –∑–¥–µ—Å—å
                        if (this.state.chargingStations.has(`${nextStep.row},${nextStep.col}`) && robot.hasShelf) {
                            // –û—Å—Ç–∞–≤–ª—è–µ–º –≥—Ä—É–∑ –≤ –¢–ï–ö–£–©–ï–ô –∫–ª–µ—Ç–∫–µ (–ø–µ—Ä–µ–¥ –∑–∞–µ–∑–¥–æ–º –Ω–∞ –∑–∞—Ä—è–¥–∫—É)
                            if (currentCell) {
                                this.dropShelfHere(robot, currentCell, prevStep.row, prevStep.col);
                            }
                        }

                        // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é –∫–ª–µ—Ç–∫—É (—Ä–æ–±–æ—Ç –ø–æ–∫–∞ –Ω–µ–≤–∏–¥–∏–º)
                        while (nextCell.firstChild) {
                            nextCell.removeChild(nextCell.firstChild);
                        }
                        nextCell.className = 'cell';
                        const nextKey = `${nextStep.row},${nextStep.col}`;
                        if (this.state.parkingCells.has(nextKey)) nextCell.classList.add('parking');
                        else if (this.state.obstacles.has(nextKey)) nextCell.classList.add('column');
                        else if (this.state.chargingStations.has(nextKey)) nextCell.classList.add('charging-station');
                        else if (this.state.shelves.has(nextKey)) nextCell.classList.add('shelf');

                        this.addRobotImage(nextCell, 'Robot.png');
                        this.addChargeBar(nextCell, robot.charge);
                        const nextRobotImg = nextCell.querySelector('.robot-image');
                        const nextChargeBar = nextCell.querySelector('.charge-bar');
                        if (nextRobotImg) nextRobotImg.style.opacity = '0';
                        if (nextChargeBar) nextChargeBar.style.opacity = '0';

                        // –°–∫—Ä—ã–≤–∞–µ–º —Ä–æ–±–æ—Ç–∞ –≤ —Ç–µ–∫—É—â–µ–π –∫–ª–µ—Ç–∫–µ
                        if (currentCell) {
                            const currentRobotImg = currentCell.querySelector('.robot-image');
                            const currentChargeBar = currentCell.querySelector('.charge-bar');
                            if (currentRobotImg) currentRobotImg.style.opacity = '0';
                            if (currentChargeBar) currentChargeBar.style.opacity = '0';
                        }

                        // –ñ–¥—ë–º 100 –º—Å ‚Äî –∞–Ω–∏–º–∞—Ü–∏—è –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // –£–¥–∞–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç–µ–∫—É—â–µ–π –∫–ª–µ—Ç–∫–∏
                        if (currentCell) {
                            while (currentCell.firstChild) {
                                currentCell.removeChild(currentCell.firstChild);
                            }
                            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–Ω —Ç–µ–∫—É—â–µ–π –∫–ª–µ—Ç–∫–∏
                            currentCell.className = 'cell';
                            const currentKey = `${prevStep.row},${prevStep.col}`;
                            if (this.state.parkingCells.has(currentKey)) currentCell.classList.add('parking');
                            else if (this.state.obstacles.has(currentKey)) currentCell.classList.add('column');
                            else if (this.state.chargingStations.has(currentKey)) currentCell.classList.add('charging-station');
                            else if (this.state.shelves.has(currentKey)) currentCell.classList.add('shelf');
                        }

                        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–æ–±–æ—Ç–∞ –≤ —Å–ª–µ–¥—É—é—â–µ–π –∫–ª–µ—Ç–∫–µ
                        if (nextRobotImg) nextRobotImg.style.opacity = '1';
                        if (nextChargeBar) nextChargeBar.style.opacity = '1';

                        // –£–¥–∞–ª–µ–Ω–∏–µ –ª–∏–Ω–∏–∏ —à–∞–≥–∞
                        if (lines.length > 0) {
                            const lineToRemove = lines.shift();
                            if (lineToRemove && lineToRemove.parentNode) lineToRemove.remove();
                        }

                        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Ä–æ–±–æ—Ç–∞ –≤ –¥–∞–Ω–Ω—ã—Ö
                        robot.row = nextStep.row;
                        robot.col = nextStep.col;
                        // –†–∞—Å—Ö–æ–¥ –∑–∞—Ä—è–¥–∞: 1% –∑–∞ –∫–ª–µ—Ç–∫—É
                        robot.charge = Math.max(0, robot.charge - 1);
                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ game over
                        if (robot.charge <= 0) {
                            this.triggerGameOver();
                            return;
                        }
                        // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç –≤ —Ä–µ–µ—Å—Ç—Ä–µ
                        if (robot.route && robot.route.length > i) {
                            robot.route = robot.route.slice(i - 1);
                            this.state.activeRoutes.set(robotId, robot.route);
                        }
                        // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∑–∞—Ä—è–¥–∞
                        if (this.selectedRobot === robotId) {
                            this.movesElement.textContent = `–ó–∞—Ä—è–¥ —Ä–æ–±–æ—Ç–∞: ${robot.charge}%`;
                        }
                        // –ñ–¥—ë–º 150 –º—Å ‚Äî –æ—Å–Ω–æ–≤–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è
                        await new Promise(resolve => setTimeout(resolve, 150));
                    }
                    if (!signal.aborted) {
                        // –§–∏–Ω–∞–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞
                        this.clearRobotRouteLines(robotId);
                        this.state.activeRoutes.delete(robotId);
                        robot.route = null;
                        const finalCell = this.getCell(robot.row, robot.col);
                        if (finalCell) {
                            this.restoreCellState(finalCell, robot.row, robot.col);
                            // –î–æ–±–∞–≤–ª—è–µ–º —Ä–æ–±–æ—Ç–∞ –≤ —Ñ–∏–Ω–∞–ª—å–Ω—É—é –∫–ª–µ—Ç–∫—É
                            this.addRobotImage(finalCell, 'Robot.png');
                            this.addChargeBar(finalCell, robot.charge);
                            // –ï—Å–ª–∏ –ø—Ä–∏–±—ã–ª –Ω–∞ –∑–∞—Ä—è–¥–∫—É ‚Äî –Ω–∞—á–∏–Ω–∞–µ–º –∑–∞—Ä—è–∂–∞—Ç—å—Å—è
                            if (this.state.chargingStations.has(`${robot.row},${robot.col}`)) {
                                this.startCharging(robotId);
                            }
                            // –ï—Å–ª–∏ —Ä–æ–±–æ—Ç –≤—ã–±—Ä–∞–Ω, –¥–æ–±–∞–≤–ª—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
                            if (this.selectedRobot === robotId) {
                                finalCell.classList.add('selected');
                            }
                        }
                        // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∑–∞—Ä—è–¥–∞
                        if (this.selectedRobot === robotId) {
                            this.movesElement.textContent = `–ó–∞—Ä—è–¥ —Ä–æ–±–æ—Ç–∞: ${robot.charge}%`;
                        }
                        // üî•üî•üî• –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–µ–ª–∏ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è
                        if (this.selectedRobot === robotId) {
                             this.startTargetBlinking(robot);
                        }
                    }
                } catch (error) {
                    if (error.message !== 'aborted') throw error;
                } finally {
                    this.state.movingRobots.delete(robotId);
                    if (this.abortControllers.get(robotId) === abortController) {
                        this.abortControllers.delete(robotId);
                    }
                }
            }
            // üî•üî•üî• –ù–û–í–´–ô –ú–ï–¢–û–î: –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–ª–µ—Ç–∫–∏
            restoreCellState(cell, row, col) {
                const key = `${row},${col}`;
                // –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –∫–ª–µ—Ç–∫–∏
                while (cell.firstChild) {
                    cell.removeChild(cell.firstChild);
                }
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–ª–∞—Å—Å –∫–ª–µ—Ç–∫–∏
                cell.className = 'cell';
                if (this.state.parkingCells.has(key)) cell.classList.add('parking');
                else if (this.state.obstacles.has(key)) cell.classList.add('column');
                else if (this.state.chargingStations.has(key)) cell.classList.add('charging-station');
                else if (this.state.shelves.has(key)) cell.classList.add('shelf');
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ä–æ–±–æ—Ç –≤ —ç—Ç–æ–π –∫–ª–µ—Ç–∫–µ
                let robotHere = null;
                for (const [id, robot] of this.state.robots) {
                    if (robot.row === row && robot.col === col) {
                        robotHere = robot;
                        break;
                    }
                }
                // –ï—Å–ª–∏ —Ä–æ–±–æ—Ç –µ—Å—Ç—å, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                if (robotHere) {
                    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–æ–π —Ç–∏–ø –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä–æ–±–æ—Ç–∞ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å
                    let robotImage = 'Robot.png';
                    if (this.state.chargingStations.has(key) && robotHere.isCharging) {
                        robotImage = 'Robot_Charg.png';
                    }
                    this.addRobotImage(cell, robotImage);
                    this.addChargeBar(cell, robotHere.charge);
                }
            }
            dropShelfHere(robot, cell, row, col) {
                if (!robot.hasShelf) return;
                robot.hasShelf = false;
                const key = `${row},${col}`;
                // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–æ–ª –≤ —Ä–µ–µ—Å—Ç—Ä, –µ—Å–ª–∏ –µ–≥–æ —Ç–∞–º –µ—â—ë –Ω–µ—Ç
                if (!this.state.shelves.has(key)) {
                    this.state.shelves.add(key);
                }
                // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–ª–µ—Ç–∫–∏
                if (cell) {
                    while (cell.firstChild) {
                        cell.removeChild(cell.firstChild);
                    }
                    cell.className = 'cell shelf';
                    this.addRobotImage(cell, 'Robot.png');
                    this.addChargeBar(cell, robot.charge);
                }
                console.log(`–†–æ–±–æ—Ç –æ—Å—Ç–∞–≤–∏–ª —Å—Ç–æ–ª –Ω–∞ (${row}, ${col})`);
            }
            startCharging(robotId) {
                const robot = this.state.robots.get(robotId);
                if (!robot) return;
                // –û—Ç–º–µ—á–∞–µ–º, —á—Ç–æ —Ä–æ–±–æ—Ç –Ω–∞—á–∞–ª –∑–∞—Ä—è–¥–∫—É
                robot.isCharging = true;
                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –∑–∞—Ä—è–¥–∫–∏, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
                if (this.state.chargingIntervals.has(robotId)) {
                    clearInterval(this.state.chargingIntervals.get(robotId));
                }
                // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ —Å –∑–∞—Ä—è–¥–∫–æ–π
                const cell = this.getCell(robot.row, robot.col);
                if (cell) {
                    // –û—á–∏—â–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–ª–µ—Ç–∫–∏
                    while (cell.firstChild) {
                        cell.removeChild(cell.firstChild);
                    }
                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–µ–ª—ã–π —Ñ–æ–Ω
                    cell.className = 'cell';
                    // –î–æ–±–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–æ–±–æ—Ç–∞ –Ω–∞ –∑–∞—Ä—è–¥–∫–µ
                    this.addRobotImage(cell, 'Robot_Charg.png');
                    // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–æ—Å—É –∑–∞—Ä—è–¥–∞
                    this.addChargeBar(cell, robot.charge);
                    // –ï—Å–ª–∏ —Ä–æ–±–æ—Ç –≤—ã–±—Ä–∞–Ω, –¥–æ–±–∞–≤–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ñ–æ–Ω
                    if (this.selectedRobot === robotId) {
                        cell.classList.add('selected');
                    }
                }
                // –ó–∞—Ä—è–∂–∞–µ–º –ø–æ 10% –≤ —Å–µ–∫—É–Ω–¥—É
                const chargeInterval = setInterval(() => {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ä–æ–±–æ—Ç –≤—Å–µ –µ—â–µ –Ω–∞ –∑–∞—Ä—è–¥–∫–µ –∏ –Ω–µ –≤ –¥–≤–∏–∂–µ–Ω–∏–∏
                    if (!robot.isCharging || this.state.movingRobots.has(robotId)) {
                        clearInterval(chargeInterval);
                        this.state.chargingIntervals.delete(robotId);
                        return;
                    }
                    if (robot.charge >= 100) {
                        robot.charge = 100;
                        robot.isCharging = false; // –ó–∞—Ä—è–¥–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
                        clearInterval(chargeInterval);
                        this.state.chargingIntervals.delete(robotId);
                        // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ –ø–æ—Å–ª–µ –ø–æ–ª–Ω–æ–π –∑–∞—Ä—è–¥–∫–∏
                        const finalCell = this.getCell(robot.row, robot.col);
                        if (finalCell) {
                            // –û—á–∏—â–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–ª–µ—Ç–∫–∏
                            while (finalCell.firstChild) {
                                finalCell.removeChild(finalCell.firstChild);
                            }
                            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–µ–ª—ã–π —Ñ–æ–Ω
                            finalCell.className = 'cell';
                            // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—ã—á–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–æ–±–æ—Ç–∞
                            this.addRobotImage(finalCell, 'Robot.png');
                            // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–æ—Å—É –∑–∞—Ä—è–¥–∞
                            this.addChargeBar(finalCell, robot.charge);
                            // –ï—Å–ª–∏ —Ä–æ–±–æ—Ç –≤—ã–±—Ä–∞–Ω, –¥–æ–±–∞–≤–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ñ–æ–Ω –∏ –º–∏–≥–∞—é—â–∏–µ —Ü–µ–ª–∏
                            if (this.selectedRobot === robotId) {
                                finalCell.classList.add('selected');
                                this.startTargetBlinking(this.state.robots.get(robotId));
                            }
                        }
                        return;
                    }
                    robot.charge = Math.min(100, robot.charge + 10);
                    const chargeCell = this.getCell(robot.row, robot.col);
                    if (chargeCell) {
                        this.addChargeBar(chargeCell, robot.charge);
                    }
                    if (this.selectedRobot === robotId) {
                        this.movesElement.textContent = `–ó–∞—Ä—è–¥ —Ä–æ–±–æ—Ç–∞: ${robot.charge}%`;
                    }
                }, 1000);
                this.state.chargingIntervals.set(robotId, chargeInterval);
            }
            triggerGameOver() {
                this.gameOver = true;
                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ—Ö —Ä–æ–±–æ—Ç–æ–≤
                for (const [id, controller] of this.abortControllers) {
                    controller.abort();
                }
                this.abortControllers.clear();
                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã –∑–∞—Ä—è–¥–∫–∏
                for (const [id, interval] of this.state.chargingIntervals) {
                    clearInterval(interval);
                }
                this.state.chargingIntervals.clear();
                // –ë–ª–æ–∫–∏—Ä—É–µ–º –¥–æ—Å–∫—É
                this.board.style.pointerEvents = 'none';
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º GAME OVER
                const overlay = document.createElement('div');
                overlay.className = 'game-over-overlay';
                overlay.textContent = 'GAME OVER';
                this.board.appendChild(overlay);
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
                this.movesElement.textContent = 'GAME OVER';
                this.timerElement.textContent = 'GAME OVER';
                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ –º–∏–≥–∞–Ω–∏–µ
                if (this.constantBlinkInterval) {
                    clearInterval(this.constantBlinkInterval);
                    this.constantBlinkInterval = null;
                }
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            new LogisticsGame();
        });
    </script>
</body>
</html>
