<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      background: #0a0a0a;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      background-image:
        radial-gradient(circle at 10% 20%, rgba(30,30,40,0.3) 0%, transparent 40%),
        radial-gradient(circle at 90% 80%, rgba(20,20,30,0.3) 0%, transparent 40%);
    }

    #gameContainer {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      background:
        linear-gradient(135deg, #e6e6e6 0%, #d0d0d0 50%, #b8b8b8 100%),
        radial-gradient(ellipse at center, transparent 65%, rgba(0,0,0,0.25) 100%),
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.4) 0%, transparent 60%);
      box-shadow:
        inset 0 2px 8px rgba(0, 0, 0, 0.7),
        inset 0 -2px 8px rgba(255, 255, 255, 0.15),
        0 12px 24px rgba(0, 0, 0, 0.6),
        0 8px 10px rgba(0, 0, 0, 0.4),
        0 16px 0 rgba(80, 80, 80, 0.3),
        inset 0 -1px 0 rgba(255,255,255,0.5),
        inset 0 1px 0 rgba(255,255,255,0.2);
      border: 2px solid #999;
    }

    #gameContainer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 8px;
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.6),
        inset 0 -1px 0 rgba(0,0,0,0.2),
        inset 1px 0 0 rgba(255,255,255,0.3),
        inset -1px 0 0 rgba(0,0,0,0.1);
      pointer-events: none;
    }

    #gameCanvas {
      position: absolute;
      background: #111;
      border-radius: 6px;
      box-shadow:
        inset 0 0 20px rgba(0, 0, 0, 0.8),
        inset 0 2px 4px rgba(0, 0, 0, 0.9),
        0 0 8px rgba(0, 0, 0, 0.5),
        0 0 0 1px #000,
        0 0 0 2px rgba(255,255,255,0.05);
    }

    .control-btn {
      position: absolute;
      border-radius: 50%;
      background:
        radial-gradient(circle at 40% 40%, #ff8c8c, #e00000 60%, #a00000 100%);
      border: 2px solid #700000;
      box-shadow:
        0 6px 14px rgba(0, 0, 0, 0.6),
        0 4px 6px rgba(0, 0, 0, 0.5),
        0 8px 0 #500000,
        inset 0 -2px 6px rgba(0,0,0,0.4),
        inset 0 2px 4px rgba(255,255,255,0.2);
      outline: none;
      padding: 0;
      cursor: pointer;
      transition: all 0.12s cubic-bezier(0.3, 0, 0.3, 1.3);
    }

    .control-btn:active {
      transform: translateY(4px);
      box-shadow:
        0 2px 8px rgba(0, 0, 0, 0.5),
        0 1px 3px rgba(0, 0, 0, 0.4),
        0 3px 0 #500000,
        inset 0 -1px 4px rgba(0,0,0,0.3),
        inset 0 2px 3px rgba(255,255,255,0.15);
    }

    .control-btn::before {
      content: '';
      position: absolute;
      top: 6px;
      left: 6px;
      right: 6px;
      bottom: 6px;
      border-radius: 50%;
      background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.6), transparent 70%);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <button class="control-btn" id="btnLeft"></button>
    <button class="control-btn" id="btnLeft2"></button>
    <button class="control-btn" id="btnDown"></button>
    <button class="control-btn" id="btnUp"></button>
    <button class="control-btn" id="btnRight"></button>
    <button class="control-btn" id="btnRight2"></button>
  </div>

  <script>
    // === НАСТРОЙКИ ===
    const GAME_SETTINGS = {
      rounds: [
        { totalBoxes: 20, intervalSec: 2.0 },
        { totalBoxes: 40, intervalSec: 1.5 },
        { totalBoxes: 60, intervalSec: 1.0 },
        { totalBoxes: 80, intervalSec: 0.5 }
      ],
      roundDisplayTime: 1500 // ms
    };

    const UI_CONFIG = {
      buttonSize: 1.2,
      padX: 0.4,
      padYLow: 0.4,
      verticalGap: 2.0,
      extraVerticalGap: 2.0,
      showTopButtons: false,

      canvasWidth: 12,
      canvasHeight: 6,
      canvasMargin: 1.0
    };

    const container = document.getElementById('gameContainer');
    const gameCanvas = document.getElementById('gameCanvas');
    const ctx = gameCanvas.getContext('2d');

    const btnLeft = document.getElementById('btnLeft');
    const btnLeft2 = document.getElementById('btnLeft2');
    const btnDown = document.getElementById('btnDown');
    const btnUp = document.getElementById('btnUp');
    const btnRight = document.getElementById('btnRight');
    const btnRight2 = document.getElementById('btnRight2');

    let score = 0;
    let timeElapsed = 0;
    let timerRunning = false;
    let globalTimerInterval = null;
    let currentTimeout = null;
    let queue = [];
    let currentRound = 0;
    let boxesRemaining = 0;
    let gameStarted = false;
    let gameOver = false;
    let roundDisplayActive = false;
    let whiteSquareDigit = null;
    let timerStartTime = 0;
    let missedBoxes = 0; // <-- НОВОЕ: счётчик пропущенных

    const playerSize = 30;
    const whiteSquareSize = 50;
    const gapBetweenSquares = 5;
    const sideSquareSize = 30;
    const sideSquareGap = 10;

    const buttonMap = new Map([
      [btnLeft2, 1],
      [btnLeft, 2],
      [btnRight, 3],
      [btnUp, 4]
    ]);

    function getRandomDigit() {
      return Math.floor(Math.random() * 4) + 1;
    }

    function fillQueue() {
      queue = [];
      for (let i = 0; i < 3; i++) {
        queue.push(getRandomDigit());
      }
    }

    function clearCurrentTimeout() {
      if (currentTimeout) {
        clearTimeout(currentTimeout);
        currentTimeout = null;
      }
    }

    function scheduleNextBox() {
      if (gameOver || roundDisplayActive || boxesRemaining <= 0) return;
      const intervalMs = GAME_SETTINGS.rounds[currentRound].intervalSec * 1000;
      timerStartTime = Date.now();
      clearCurrentTimeout();
      currentTimeout = setTimeout(() => {
        // Автоматический пропуск
        missedBoxes++; // <-- увеличиваем счётчик пропусков

        // Каждые 2 пропуска → -1 очко
        if (missedBoxes >= 2) {
          score--;
          missedBoxes = 0; // сброс
          if (score < 0) {
            gameOver = true;
            clearCurrentTimeout();
            return;
          }
        }

        advanceQueue();
        boxesRemaining--;
        if (boxesRemaining <= 0) {
          endRound();
          return;
        }
        whiteSquareDigit = queue[0];
        scheduleNextBox();
      }, intervalMs);
    }

    function endRound() {
      clearCurrentTimeout();
      if (currentRound < GAME_SETTINGS.rounds.length - 1) {
        startRound(currentRound + 1);
      } else {
        gameOver = true;
      }
    }

    function advanceQueue() {
      queue.shift();
      queue.push(getRandomDigit());
    }

    function startRound(roundIndex) {
      clearCurrentTimeout();
      currentRound = roundIndex;
      boxesRemaining = GAME_SETTINGS.rounds[roundIndex].totalBoxes;
      fillQueue();
      roundDisplayActive = true;

      setTimeout(() => {
        roundDisplayActive = false;
        if (!gameStarted) {
          gameStarted = true;
          globalTimerInterval = setInterval(() => {
            timeElapsed++;
          }, 1000);
        }

        whiteSquareDigit = queue[0];
        advanceQueue();
        boxesRemaining--;

        if (boxesRemaining <= 0) {
          endRound();
        } else {
          scheduleNextBox();
        }
      }, GAME_SETTINGS.roundDisplayTime);
    }

    function resetGame() {
      if (globalTimerInterval) clearInterval(globalTimerInterval);
      clearCurrentTimeout();
      score = 0;
      timeElapsed = 0;
      timerRunning = false;
      gameStarted = false;
      gameOver = false;
      roundDisplayActive = false;
      currentRound = 0;
      boxesRemaining = 0;
      queue = [];
      whiteSquareDigit = null;
      timerStartTime = 0;
      missedBoxes = 0; // <-- сброс
    }

    function handleInput(button) {
      if (!gameStarted || gameOver || roundDisplayActive || whiteSquareDigit === null) return;
      const actual = buttonMap.get(button);
      if (actual === undefined) return;

      const expected = whiteSquareDigit;
      if (actual === expected) {
        score++;
      } else {
        score--;
        if (score < 0) {
          gameOver = true;
          clearCurrentTimeout();
          return;
        }
      }

      whiteSquareDigit = null;
      advanceQueue();
      boxesRemaining--;

      if (boxesRemaining <= 0) {
        endRound();
        return;
      }

      const now = Date.now();
      const elapsed = now - timerStartTime;
      const intervalMs = GAME_SETTINGS.rounds[currentRound].intervalSec * 1000;
      const remaining = Math.max(10, intervalMs - elapsed);

      clearCurrentTimeout();
      currentTimeout = setTimeout(() => {
        whiteSquareDigit = queue[0];
        advanceQueue();
        boxesRemaining--;
        if (boxesRemaining <= 0) {
          endRound();
        } else {
          scheduleNextBox();
        }
      }, remaining);
    }

    function drawUI() {
      const displayWidth = gameCanvas.width / window.devicePixelRatio;
      const displayHeight = gameCanvas.height / window.devicePixelRatio;

      ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

      if (gameOver) {
        ctx.fillStyle = '#fff';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (score < 0) {
          ctx.fillText('GAME OVER', displayWidth / 2, displayHeight / 2 - 20);
        } else {
          ctx.fillText('GAME COMPLETE', displayWidth / 2, displayHeight / 2 - 20);
        }
        ctx.font = '24px Arial';
        ctx.fillText(`Final Score: ${score}`, displayWidth / 2, displayHeight / 2 + 20);
        return;
      }

      if (roundDisplayActive) {
        ctx.fillStyle = '#fff';
        ctx.font = '36px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`ROUND ${currentRound + 1}`, displayWidth / 2, displayHeight / 2);
        return;
      }

      if (!gameStarted) {
        return;
      }

      // === ВЕРХНИЕ 3 КВАДРАТА (ОЧЕРЕДЬ) ===
      const topRowY = 0;
      const totalTopWidth = 3 * sideSquareSize + 2 * sideSquareGap;
      const startX = (displayWidth - totalTopWidth) / 2;

      ctx.fillStyle = '#666';
      for (let i = 0; i < 3; i++) {
        const x = startX + i * (sideSquareSize + sideSquareGap);
        ctx.fillRect(x, topRowY, sideSquareSize, sideSquareSize);
      }

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let i = 0; i < 3 && i < queue.length; i++) {
        const x = startX + i * (sideSquareSize + sideSquareGap) + sideSquareSize / 2;
        ctx.fillText(queue[i].toString(), x, topRowY + sideSquareSize / 2);
      }

      // === НАДПИСЬ "ROUND N" ПОД ОЧЕРЕДЬЮ ===
      const roundLabelY = topRowY + sideSquareSize + sideSquareGap;
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`ROUND ${currentRound + 1}`, startX + totalTopWidth / 2, roundLabelY);

      // === СЧЁТЧИК ОСТАВШИХСЯ КОРОБОК ===
      const counterX = startX + totalTopWidth + 10;
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(boxesRemaining.toString().padStart(2, '0'), counterX, topRowY + sideSquareSize / 2);

      // === БОКОВЫЕ КВАДРАТЫ ===
      const centerY = (displayHeight - sideSquareSize * 2 - sideSquareGap) / 2;
      const topY = centerY;
      const bottomY = centerY + sideSquareSize + sideSquareGap;

      ctx.fillStyle = '#666';
      ctx.fillRect(0, topY, sideSquareSize, sideSquareSize);
      ctx.fillRect(0, bottomY, sideSquareSize, sideSquareSize);
      const rightX = displayWidth - sideSquareSize;
      ctx.fillRect(rightX, topY, sideSquareSize, sideSquareSize);
      ctx.fillRect(rightX, bottomY, sideSquareSize, sideSquareSize);

      ctx.fillStyle = '#fff';
      ctx.fillText('1', sideSquareSize / 2, topY + sideSquareSize / 2);
      ctx.fillText('2', sideSquareSize / 2, bottomY + sideSquareSize / 2);
      ctx.fillText('3', rightX + sideSquareSize / 2, topY + sideSquareSize / 2);
      ctx.fillText('4', rightX + sideSquareSize / 2, bottomY + sideSquareSize / 2);

      // === СЧЁТ И ТАЙМЕР ===
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(score.toString().padStart(2, '0'), 10, 20);
      ctx.textAlign = 'right';
      ctx.fillText(timeElapsed.toString(), displayWidth - 10, 20);

      // === ЖЁЛТЫЙ ИГРОК ===
      const yellowX = (displayWidth - playerSize) / 2;
      const yellowY = displayHeight - playerSize;
      ctx.fillStyle = '#ff0';
      ctx.fillRect(yellowX, yellowY, playerSize, playerSize);

      // === БЕЛЫЙ КВАДРАТ ===
      const whiteX = (displayWidth - whiteSquareSize) / 2;
      const whiteY = yellowY - whiteSquareSize - gapBetweenSquares;
      ctx.fillStyle = '#fff';
      ctx.fillRect(whiteX, whiteY, whiteSquareSize, whiteSquareSize);
      if (whiteSquareDigit !== null) {
        ctx.fillStyle = '#000';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(whiteSquareDigit.toString(), whiteX + whiteSquareSize / 2, whiteY + whiteSquareSize / 2);
      }
    }

    function resize() {
      const maxWidth = 640;
      const maxHeight = 360;

      const scaleX = window.innerWidth / maxWidth;
      const scaleY = window.innerHeight / maxHeight;
      const scale = Math.min(scaleX, scaleY, 1);

      const containerWidth = maxWidth * scale;
      const containerHeight = maxHeight * scale;

      container.style.width = containerWidth + 'px';
      container.style.height = containerHeight + 'px';

      const unit = 40 * scale;
      const canvasWidthPx = UI_CONFIG.canvasWidth * unit;
      const canvasHeightPx = UI_CONFIG.canvasHeight * unit;
      const canvasLeft = (containerWidth - canvasWidthPx) / 2;
      const canvasTop = (containerHeight - canvasHeightPx) / 2;

      gameCanvas.style.width = canvasWidthPx + 'px';
      gameCanvas.style.height = canvasHeightPx + 'px';
      gameCanvas.style.left = canvasLeft + 'px';
      gameCanvas.style.top = canvasTop + 'px';

      gameCanvas.width = canvasWidthPx * window.devicePixelRatio;
      gameCanvas.height = canvasHeightPx * window.devicePixelRatio;

      const buttonSize = UI_CONFIG.buttonSize * unit;
      [btnLeft, btnLeft2, btnDown, btnUp, btnRight, btnRight2].forEach(btn => {
        btn.style.width = buttonSize + 'px';
        btn.style.height = buttonSize + 'px';
      });

      const padX = UI_CONFIG.padX * unit;
      const yLow = UI_CONFIG.padYLow * unit;
      const yMid = (UI_CONFIG.padYLow + UI_CONFIG.verticalGap) * unit;

      btnLeft2.style.left = padX + 'px';
      btnLeft2.style.bottom = yMid + 'px';
      btnLeft2.style.display = 'block';

      btnLeft.style.left = padX + 'px';
      btnLeft.style.bottom = yLow + 'px';
      btnLeft.style.display = 'block';

      btnRight.style.right = padX + 'px';
      btnRight.style.bottom = yMid + 'px';
      btnRight.style.display = 'block';

      btnUp.style.right = padX + 'px';
      btnUp.style.bottom = yLow + 'px';
      btnUp.style.display = 'block';

      btnDown.style.display = 'none';
      btnRight2.style.display = 'none';

      drawUI();
    }

    gameCanvas.addEventListener('pointerdown', () => {
      if (gameOver) {
        resetGame();
        resize();
      } else if (!gameStarted && !roundDisplayActive) {
        resetGame();
        startRound(0);
        resize();
      }
    });

    [btnLeft2, btnLeft, btnRight, btnUp].forEach(btn => {
      btn.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        handleInput(btn);
      });
    });

    setInterval(drawUI, 100);
    window.addEventListener('resize', resize);
    resize();
  </script>
</body>
</html>