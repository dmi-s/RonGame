<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      background: #0a0a0a;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      background-image:
        radial-gradient(circle at 10% 20%, rgba(30,30,40,0.3) 0%, transparent 40%),
        radial-gradient(circle at 90% 80%, rgba(20,20,30,0.3) 0%, transparent 40%);
    }

    #gameContainer {
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      background:
        linear-gradient(135deg, #e6e6e6 0%, #d0d0d0 50%, #b8b8b8 100%),
        radial-gradient(ellipse at center, transparent 65%, rgba(0,0,0,0.25) 100%),
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.4) 0%, transparent 60%);
      box-shadow:
        inset 0 2px 8px rgba(0, 0, 0, 0.7),
        inset 0 -2px 8px rgba(255, 255, 255, 0.15),
        0 12px 24px rgba(0, 0, 0, 0.6),
        0 8px 10px rgba(0, 0, 0, 0.4),
        0 16px 0 rgba(80, 80, 80, 0.3),
        inset 0 -1px 0 rgba(255,255,255,0.5),
        inset 0 1px 0 rgba(255,255,255,0.2);
      border: 2px solid #999;
    }

    #gameContainer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 8px;
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.6),
        inset 0 -1px 0 rgba(0,0,0,0.2),
        inset 1px 0 0 rgba(255,255,255,0.3),
        inset -1px 0 0 rgba(0,0,0,0.1);
      pointer-events: none;
    }

    #gameCanvas {
      position: absolute;
      background: #111;
      border-radius: 6px;
      box-shadow:
        inset 0 0 20px rgba(0, 0, 0, 0.8),
        inset 0 2px 4px rgba(0, 0, 0, 0.9),
        0 0 8px rgba(0, 0, 0, 0.5),
        0 0 0 1px #000,
        0 0 0 2px rgba(255,255,255,0.05);
    }

    .control-btn {
      position: absolute;
      border-radius: 50%;
      background:
        radial-gradient(circle at 40% 40%, #ff8c8c, #e00000 60%, #a00000 100%);
      border: 2px solid #700000;
      box-shadow:
        0 6px 14px rgba(0, 0, 0, 0.6),
        0 4px 6px rgba(0, 0, 0, 0.5),
        0 8px 0 #500000,
        inset 0 -2px 6px rgba(0,0,0,0.4),
        inset 0 2px 4px rgba(255,255,255,0.2);
      outline: none;
      padding: 0;
      cursor: pointer;
      transition: all 0.12s cubic-bezier(0.3, 0, 0.3, 1.3);
    }

    .control-btn:active {
      transform: translateY(4px);
      box-shadow:
        0 2px 8px rgba(0, 0, 0, 0.5),
        0 1px 3px rgba(0, 0, 0, 0.4),
        0 3px 0 #500000,
        inset 0 -1px 4px rgba(0,0,0,0.3),
        inset 0 2px 3px rgba(255,255,255,0.15);
    }

    .control-btn::before {
      content: '';
      position: absolute;
      top: 6px;
      left: 6px;
      right: 6px;
      bottom: 6px;
      border-radius: 50%;
      background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.6), transparent 70%);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <button class="control-btn" id="btnLeft"></button>
    <button class="control-btn" id="btnLeft2"></button>
    <button class="control-btn" id="btnDown"></button>
    <button class="control-btn" id="btnUp"></button>
    <button class="control-btn" id="btnRight"></button>
    <button class="control-btn" id="btnRight2"></button>
  </div>

  <script>
    const ROUND_DISPLAY_DURATION = 1500;
    const DIGIT_FLASH_PERIOD = 200;

    const GAME_SETTINGS = {
      rounds: [
        { totalBoxes: 10, intervalSec: 2.0 },
        { totalBoxes: 15, intervalSec: 1.6 },
        { totalBoxes: 20, intervalSec: 1.3 },
        { totalBoxes: 25, intervalSec: 1.0 }
      ]
    };

    const UI_CONFIG = {
      buttonSize: 1.2,
      padX: 0.4,
      verticalGap: 1.6,
      canvasWidth: 12,
      canvasHeight: 6,
      canvasMargin: 1.0
    };

    const container = document.getElementById('gameContainer');
    const gameCanvas = document.getElementById('gameCanvas');
    const ctx = gameCanvas.getContext('2d');

    const btnLeft = document.getElementById('btnLeft');
    const btnLeft2 = document.getElementById('btnLeft2');
    const btnDown = document.getElementById('btnDown');
    const btnUp = document.getElementById('btnUp');
    const btnRight = document.getElementById('btnRight');
    const btnRight2 = document.getElementById('btnRight2');

    let score = 0;
    let currentTimeout = null;
    let queue = [];
    let remainingDigits = [];
    let currentRound = 0;
    let gameStarted = false;
    let gameOver = false;
    let roundDisplayActive = false;
    let whiteSquareDigit = null;
    let boxStartTime = 0;
    let missedBoxes = 0;
    const activeButtons = new Set();

    const playerSize = 30;
    const whiteSquareSize = 50;
    const gapBetweenSquares = 5;
    const sideSquareSize = 30;
    const sideSquareGap = 10;

    const buttonMap = new Map([
      [btnLeft2, 1],
      [btnLeft, 2],
      [btnRight, 3],
      [btnUp, 4]
    ]);

    function getRandomDigit() {
      return Math.floor(Math.random() * 4) + 1;
    }

    function fillQueueAndRemaining(total) {
      const allDigits = [];
      for (let i = 0; i < total; i++) {
        allDigits.push(getRandomDigit());
      }
      queue = allDigits.slice(0, 3);
      remainingDigits = allDigits.slice(3);
    }

    function clearCurrentTimeout() {
      if (currentTimeout) {
        clearTimeout(currentTimeout);
        currentTimeout = null;
      }
    }

    function triggerGameOver() {
      gameOver = true;
      clearCurrentTimeout();
    }

    function endRound() {
      clearCurrentTimeout();
      if (currentRound < GAME_SETTINGS.rounds.length - 1) {
        startRound(currentRound + 1);
      } else {
        triggerGameOver();
      }
    }

    function scheduleNextBox() {
      if (gameOver || roundDisplayActive) return;

      if (queue.length === 0) {
        endRound();
        return;
      }

      whiteSquareDigit = queue[0];
      boxStartTime = Date.now();

      const intervalMs = GAME_SETTINGS.rounds[currentRound].intervalSec * 1000;

      clearCurrentTimeout();
      currentTimeout = setTimeout(() => {
        missedBoxes++;
        if (missedBoxes >= 2) {
          score--;
          missedBoxes = 0;
          if (score < 0) {
            triggerGameOver();
            return;
          }
        }

        advanceQueue();
        if (queue.length > 0) {
          scheduleNextBox();
        } else {
          endRound();
        }
      }, intervalMs);
    }

    function advanceQueue() {
      queue.shift();
      if (remainingDigits.length > 0) {
        queue.push(remainingDigits.shift());
      }
      whiteSquareDigit = null;
    }

    function startRound(roundIndex) {
      clearCurrentTimeout();
      currentRound = roundIndex;
      const total = GAME_SETTINGS.rounds[roundIndex].totalBoxes;
      fillQueueAndRemaining(total);
      roundDisplayActive = true;

      drawUI();

      setTimeout(() => {
        roundDisplayActive = false;
        if (!gameStarted) {
          gameStarted = true;
        }

        setTimeout(() => {
          if (!gameOver && gameStarted) {
            scheduleNextBox();
          }
        }, ROUND_DISPLAY_DURATION);

      }, ROUND_DISPLAY_DURATION);
    }

    function resetGame() {
      clearCurrentTimeout();
      score = 0;
      gameStarted = false;
      gameOver = false;
      roundDisplayActive = false;
      currentRound = 0;
      queue = [];
      remainingDigits = [];
      whiteSquareDigit = null;
      missedBoxes = 0;
      activeButtons.clear();
    }

    function handleInput(button) {
      if (!gameStarted || gameOver || roundDisplayActive || whiteSquareDigit === null) return;
      const actual = buttonMap.get(button);
      if (actual === undefined) return;

      const expected = whiteSquareDigit;
      if (actual === expected) {
        score++;
      } else {
        score--;
        if (score < 0) {
          triggerGameOver();
          return;
        }
      }

      clearCurrentTimeout();
      advanceQueue();

      const now = Date.now();
      const elapsed = now - boxStartTime;
      const intervalMs = GAME_SETTINGS.rounds[currentRound].intervalSec * 1000;
      const remaining = Math.max(10, intervalMs - elapsed);

      if (queue.length > 0) {
        currentTimeout = setTimeout(() => {
          if (!gameOver) {
            scheduleNextBox();
          }
        }, remaining);
      } else {
        endRound();
      }

      drawUI();
    }

    function getButtonId(btn) {
      if (btn === btnLeft2) return '1';
      if (btn === btnLeft) return '2';
      if (btn === btnRight) return '3';
      if (btn === btnUp) return '4';
      return null;
    }

    function drawUI() {
      const displayWidth = gameCanvas.width / window.devicePixelRatio;
      const displayHeight = gameCanvas.height / window.devicePixelRatio;

      ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

      if (gameOver) {
        ctx.fillStyle = '#fff';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (score < 0) {
          ctx.fillText('ИГРА ЗАВЕРШЕНА', displayWidth / 2, displayHeight / 2 - 20);
        } else {
          ctx.fillText('ПОБЕДА', displayWidth / 2, displayHeight / 2 - 20);
        }
        ctx.font = '24px Arial';
        ctx.fillText(`Ваш счет: ${score}`, displayWidth / 2, displayHeight / 2 + 20);
        return;
      }

      if (roundDisplayActive) {
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const roundInfo = GAME_SETTINGS.rounds[currentRound];
        const speed = roundInfo.intervalSec;
        const totalBoxes = roundInfo.totalBoxes;

        // Основная надпись: РАУНД N
        ctx.font = '36px Arial';
        ctx.fillText(`РАУНД ${currentRound + 1}`, displayWidth / 2, displayHeight / 2 - 40);

        // Скорость робота
        ctx.font = '20px Arial';
        ctx.fillText(`Скорость робота: ${speed.toFixed(1)} м/с`, displayWidth / 2, displayHeight / 2);

        // Отправлений
        ctx.fillText(`Отправлений: ${totalBoxes}`, displayWidth / 2, displayHeight / 2 + 30);

        return;
      }

      if (!gameStarted) {
        return;
      }

      const topRowY = 0;
      const totalTopWidth = 3 * sideSquareSize + 2 * sideSquareGap;
      const startX = (displayWidth - totalTopWidth) / 2;

      ctx.fillStyle = '#666';
      for (let i = 0; i < 3; i++) {
        const x = startX + i * (sideSquareSize + sideSquareGap);
        ctx.fillRect(x, topRowY, sideSquareSize, sideSquareSize);
      }

      // === ОЧЕРЕДЬ БЕЗ ТЕКУЩЕЙ ЦИФРЫ ===
      const displayQueue = [];
      if (whiteSquareDigit !== null) {
        if (queue.length > 1) displayQueue.push(queue[1]);
        if (queue.length > 2) displayQueue.push(queue[2]);
        if (displayQueue.length < 3 && remainingDigits.length > 0) {
          displayQueue.push(remainingDigits[0]);
        }
      } else {
        for (let i = 0; i < 3 && i < queue.length; i++) {
          displayQueue.push(queue[i]);
        }
      }

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      for (let i = 0; i < 3; i++) {
        if (i < displayQueue.length) {
          const x = startX + i * (sideSquareSize + sideSquareGap) + sideSquareSize / 2;
          ctx.fillText(displayQueue[i].toString(), x, topRowY + sideSquareSize / 2);
        }
      }
      // === КОНЕЦ ОЧЕРЕДИ ===

      const roundLabelY = topRowY + sideSquareSize + sideSquareGap;
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`ROUND ${currentRound + 1}`, startX + totalTopWidth / 2, roundLabelY);

      const totalRemaining = queue.length + remainingDigits.length;
      const counterX = startX + totalTopWidth + 10;
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(totalRemaining.toString().padStart(2, '0'), counterX, topRowY + sideSquareSize / 2);

      const canvasCenterY = displayHeight / 2;
      const baseUnit = 40;
      const verticalOffsetCanvas = (UI_CONFIG.verticalGap * baseUnit) * (displayHeight / (UI_CONFIG.canvasHeight * baseUnit));

      const sideSize = sideSquareSize;
      const leftX = 0;
      const rightX = displayWidth - sideSize;

      const topY = canvasCenterY - verticalOffsetCanvas;
      const bottomY = canvasCenterY + verticalOffsetCanvas;

      const squares = [
        { id: '1', x: leftX, y: topY },
        { id: '2', x: leftX, y: bottomY },
        { id: '3', x: rightX, y: topY },
        { id: '4', x: rightX, y: bottomY }
      ];

      squares.forEach(square => {
        if (activeButtons.has(square.id)) {
          ctx.fillStyle = 'rgba(102, 102, 102, 0.5)';
        } else {
          ctx.fillStyle = '#666';
        }
        ctx.fillRect(square.x, square.y - sideSize / 2, sideSize, sideSize);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(square.id, square.x + sideSize / 2, square.y);
      });

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(score.toString().padStart(2, '0'), 10, 20);

      const yellowX = (displayWidth - playerSize) / 2;
      const yellowY = displayHeight - playerSize;
      ctx.fillStyle = '#ff0';
      ctx.fillRect(yellowX, yellowY, playerSize, playerSize);

      if (whiteSquareDigit !== null) {
        const whiteX = (displayWidth - whiteSquareSize) / 2;
        const whiteY = yellowY - whiteSquareSize - gapBetweenSquares;

        ctx.fillStyle = '#fff';
        ctx.fillRect(whiteX, whiteY, whiteSquareSize, whiteSquareSize);

        const now = Date.now();
        const phase = (now % DIGIT_FLASH_PERIOD) / DIGIT_FLASH_PERIOD;
        const triangle = phase < 0.5 ? phase * 2 : (1 - phase) * 2;
        const digitAlpha = triangle;

        ctx.fillStyle = `rgba(0, 0, 0, ${digitAlpha})`;
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(whiteSquareDigit.toString(), whiteX + whiteSquareSize / 2, whiteY + whiteSquareSize / 2);
      }
    }

    function resize() {
      const maxWidth = 640;
      const maxHeight = 360;

      const scaleX = window.innerWidth / maxWidth;
      const scaleY = window.innerHeight / maxHeight;
      const scale = Math.min(scaleX, scaleY, 1);

      const containerWidth = maxWidth * scale;
      const containerHeight = maxHeight * scale;

      container.style.width = containerWidth + 'px';
      container.style.height = containerHeight + 'px';

      const unit = 40 * scale;
      const canvasWidthPx = UI_CONFIG.canvasWidth * unit;
      const canvasHeightPx = UI_CONFIG.canvasHeight * unit;
      const canvasLeft = (containerWidth - canvasWidthPx) / 2;
      const canvasTop = (containerHeight - canvasHeightPx) / 2;

      gameCanvas.style.width = canvasWidthPx + 'px';
      gameCanvas.style.height = canvasHeightPx + 'px';
      gameCanvas.style.left = canvasLeft + 'px';
      gameCanvas.style.top = canvasTop + 'px';

      gameCanvas.width = canvasWidthPx * window.devicePixelRatio;
      gameCanvas.height = canvasHeightPx * window.devicePixelRatio;

      const buttonSize = UI_CONFIG.buttonSize * unit;
      const padX = UI_CONFIG.padX * unit;
      const verticalOffset = UI_CONFIG.verticalGap * unit;
      const centerY = containerHeight / 2;

      [btnLeft, btnLeft2, btnDown, btnUp, btnRight, btnRight2].forEach(btn => {
        btn.style.width = buttonSize + 'px';
        btn.style.height = buttonSize + 'px';
        btn.style.position = 'absolute';
        btn.style.top = (centerY - buttonSize / 2) + 'px';
        btn.style.transform = 'translateY(0)';
      });

      btnLeft2.style.left = padX + 'px';
      btnLeft2.style.transform = `translateY(${-verticalOffset}px)`;
      btnLeft2.style.display = 'block';

      btnLeft.style.left = padX + 'px';
      btnLeft.style.transform = `translateY(${verticalOffset}px)`;
      btnLeft.style.display = 'block';

      btnRight.style.right = padX + 'px';
      btnRight.style.transform = `translateY(${-verticalOffset}px)`;
      btnRight.style.display = 'block';

      btnUp.style.right = padX + 'px';
      btnUp.style.transform = `translateY(${verticalOffset}px)`;
      btnUp.style.display = 'block';

      btnDown.style.display = 'none';
      btnRight2.style.display = 'none';

      drawUI();
    }

    gameCanvas.addEventListener('pointerdown', () => {
      if (gameOver) {
        resetGame();
        resize();
      } else if (!gameStarted && !roundDisplayActive) {
        resetGame();
        startRound(0);
        resize();
      }
    });

    [btnLeft2, btnLeft, btnRight, btnUp].forEach(btn => {
      const id = getButtonId(btn);
      if (!id) return;

      btn.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        activeButtons.add(id);
        handleInput(btn);
      });

      const releaseHandler = () => {
        activeButtons.delete(id);
      };

      btn.addEventListener('pointerup', releaseHandler);
      btn.addEventListener('pointercancel', releaseHandler);
    });

    setInterval(drawUI, 30);
    window.addEventListener('resize', resize);
    resize();
  </script>
</body>
</html>