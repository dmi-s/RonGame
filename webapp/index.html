<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–õ–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ —Ä–æ–±–æ—Ç—ã</title>
  <style>
    body {
      margin: 0;
      padding: 10px;
      font-family: Arial, sans-serif;
      background-color: black;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: white;
    }

    .game-info {
      display: flex;
      justify-content: space-around;
      width: min(95vw, 800px);
      max-width: 100%;
      margin-bottom: 10px;
      background-color: var(--info-bg, yellow);
      color: var(--info-text, black);
      padding: 12px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 1.2em;
    }

    .game-container {
      position: relative;
      width: min(95vw, 800px);
      max-width: 100%;
      aspect-ratio: calc(var(--cols) / var(--rows));
      margin-bottom: 20px;
    }

    .grid {
      display: grid;
      width: 100%;
      height: 100%;
      grid-template-columns: repeat(var(--cols), 1fr);
      grid-template-rows: repeat(var(--rows), 1fr);
      gap: 1px;
      background-color: gray;
      border: 2px solid gray;
    }

    .cell {
      background-color: white;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      position: relative;
      overflow: hidden;
    }

    .cell img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .charge-bar {
      position: absolute;
      top: 2px;
      left: 2px;
      right: 2px;
      height: 6px;
      border-radius: 3px;
      background-color: #ccc;
      overflow: hidden;
    }

    .charge-level {
      height: 100%;
      width: 0%;
    }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(128, 128, 128, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 3em;
      font-weight: bold;
      color: red;
      z-index: 10;
      display: none;
    }

    button {
      background-color: var(--btn-bg, yellow);
      color: var(--btn-text, black);
      border: none;
      padding: 12px 24px;
      font-size: 1.2em;
      font-weight: bold;
      border-radius: 8px;
      cursor: pointer;
      width: min(95vw, 800px);
      max-width: 100%;
    }

    button:hover {
      background-color: #ffcc00;
    }
  </style>
</head>
<body>

  <div class="game-info">
    <div>–ó–∞—Ä—è–¥: <span id="robot-charge">-</span></div>
    <div>–í—Ä–µ–º—è: <span id="game-timer">-</span></div>
  </div>

  <div class="game-container">
    <div class="grid" id="grid"></div>
    <div class="overlay" id="overlay">GAME OVER</div>
  </div>

  <button id="new-game">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>

  <script>
  // === –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò–ì–†–´ (–ú–û–ñ–ù–û –ú–ï–ù–Ø–¢–¨ –ó–î–ï–°–¨) ===
  const CONFIG = {
    // –†–∞–∑–º–µ—Ä—ã –ø–æ–ª—è
    rows: 13,
    cols: 10,

    // –í—Ä–µ–º—è –∏–≥—Ä—ã (–≤ –º–∏–Ω—É—Ç–∞—Ö)
    gameMinutes: 20,

    // –û–±—ä–µ–∫—Ç—ã
    numColumns: 8,
    numShelves: 10,
    numRobots: 3,
    numChargingStations: 3,

    // –î–∏–∞–ø–∞–∑–æ–Ω—ã —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
    shelfRows: { min: 3, max: 12 },
    shelfCols: { min: 0, max: 9 },
    robotRows: { min: 3, max: 12 },
    robotCols: { min: 0, max: 9 },
    columnRows: { min: 4, max: 11 },
    columnCols: { min: 0, max: 9 },
    chargingCenterRows: { min: 4, max: 8 },
    chargingCenterCols: { min: 3, max: 7 },

    // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
    minDistanceShelf: 2,
    minDistanceRobot: 4,
    minDistanceColumn: 4,

    // –ù–∞—á–∞–ª—å–Ω—ã–π –∑–∞—Ä—è–¥
    chargeRobotFirstMin: 25,
    chargeRobotFirstMax: 50,
    chargeOtherRobotsMin: 50,
    chargeOtherRobotsMax: 100,

    // –†–∞—Å—Ö–æ–¥ –∏ –∑–∞—Ä—è–¥–∫–∞
    chargeCostPerMove: 5,
    chargeGainPerTick: 2,
    criticalCharge: 25,

    // –ü—É—Ç–∏ –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º
    images: {
      parking: 'Parking.png',
      column: 'Column.png',
      robot: 'Robot.png',
      charging: 'Charging.png',
      robotCharging: 'Robot_Charg.png',
      shelf: 'Shelf.png',
      robotWithShelf: 'Robot_Shelf.png',
      parkedShelf: 'Parking_Shelf.png'
    },

    // –°—Ç–∏–ª–∏
    styles: {
      '--rows': 13,
      '--cols': 10,
      '--info-bg': 'yellow',
      '--info-text': 'black',
      '--btn-bg': 'yellow',
      '--btn-text': 'black'
    }
  };

  // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å—Ç–∏–ª–∏
  Object.keys(CONFIG.styles).forEach(key => {
    document.documentElement.style.setProperty(key, CONFIG.styles[key]);
  });

  // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
  const grid = document.getElementById("grid");
  const chargeDisplay = document.getElementById("robot-charge");
  const timerDisplay = document.getElementById("game-timer");
  const overlay = document.getElementById("overlay");
  const newGameBtn = document.getElementById("new-game");

  // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
  let cells = [];
  let robots = [];
  let shelves = [];
  let chargingStations = [];
  let columns = [];
  let parkingSpots = [];
  let robotCharge = [];
  let selectedRobot = null;
  let gameInterval = null;
  let timer = CONFIG.gameMinutes * 60;
  let gameStarted = false;
  let gameEnded = false;

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–ª—è
  function initGrid() {
    grid.innerHTML = "";
    const { rows, cols } = CONFIG;
    cells = Array(rows).fill().map(() => Array(cols).fill("free"));
    robots = [];
    shelves = [];
    chargingStations = [];
    columns = [];
    parkingSpots = [];
    robotCharge = [];

    // –ü–∞—Ä–∫–æ–≤–∫–∞ ‚Äî –≤–µ—Ä—Ö–Ω–∏–π —Ä—è–¥
    for (let c = 0; c < cols; c++) {
      parkingSpots.push({ r: 0, c });
      cells[0][c] = "parking";
    }

    // –°—Ç–æ–ª–±—ã
    while (columns.length < CONFIG.numColumns) {
      const r = rand(CONFIG.columnRows.min, CONFIG.columnRows.max);
      const c = rand(CONFIG.columnCols.min, CONFIG.columnCols.max);
      if (!isTooClose(columns, r, c, CONFIG.minDistanceColumn)) continue;
      if (cells[r][c] !== "free") continue;
      columns.push({ r, c });
      cells[r][c] = "column";
    }

    // –ó–∞—Ä—è–¥–∫–∏
    const centerColumns = columns.filter(col =>
      col.r >= CONFIG.chargingCenterRows.min && col.r <= CONFIG.chargingCenterRows.max &&
      col.c >= CONFIG.chargingCenterCols.min && col.c <= CONFIG.chargingCenterCols.max
    );
    const selectedForCharging = shuffle(centerColumns).slice(0, CONFIG.numChargingStations);
    for (const col of selectedForCharging) {
      const dirs = shuffle([{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }]);
      let placed = false;
      for (const dir of dirs) {
        const nr = col.r + dir.dr;
        const nc = col.c + dir.dc;
        if (isValid(nr, nc) && cells[nr][nc] === "free") {
          cells[nr][nc] = "charging";
          chargingStations.push({ r: nr, c: nc });
          placed = true;
          break;
        }
      }
      if (!placed) {
        const free = findFreeCell();
        if (free) {
          cells[free.r][free.c] = "charging";
          chargingStations.push(free);
        }
      }
    }

    // –°—Ç–æ–ª—ã
    while (shelves.length < CONFIG.numShelves) {
      const r = rand(CONFIG.shelfRows.min, CONFIG.shelfRows.max);
      const c = rand(CONFIG.shelfCols.min, CONFIG.shelfCols.max);
      if (!isTooClose(shelves, r, c, CONFIG.minDistanceShelf)) continue;
      if (cells[r][c] !== "free") continue;
      shelves.push({ r, c });
      cells[r][c] = "shelf";
    }

    // –†–æ–±–æ—Ç—ã
    while (robots.length < CONFIG.numRobots) {
      const r = rand(CONFIG.robotRows.min, CONFIG.robotRows.max);
      const c = rand(CONFIG.robotCols.min, CONFIG.robotCols.max);
      if (!isTooClose(robots, r, c, CONFIG.minDistanceRobot)) continue;
      if (cells[r][c] !== "free") continue;
      robots.push({ r, c });
      cells[r][c] = "robot";
      const charge = robots.length === 0
        ? rand(CONFIG.chargeRobotFirstMin, CONFIG.chargeRobotFirstMax)
        : rand(CONFIG.chargeOtherRobotsMin, CONFIG.chargeOtherRobotsMax);
      robotCharge.push(charge);
    }

    renderGrid();
    updateTimerDisplay();
  }

  function rand(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function isTooClose(list, r, c, minDist) {
    for (const item of list) {
      const dist = Math.abs(item.r - r) + Math.abs(item.c - c);
      if (dist < minDist) return false;
    }
    return true;
  }

  function isValid(r, c) {
    return r >= 0 && r < CONFIG.rows && c >= 0 && c < CONFIG.cols;
  }

  function findFreeCell() {
    for (let r = 0; r < CONFIG.rows; r++) {
      for (let c = 0; c < CONFIG.cols; c++) {
        if (cells[r][c] === "free") return { r, c };
      }
    }
    return null;
  }

  function shuffle(array) {
    return array.sort(() => Math.random() - 0.5);
  }

  // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
  function renderGrid() {
    grid.innerHTML = "";
    for (let r = 0; r < CONFIG.rows; r++) {
      for (let c = 0; c < CONFIG.cols; c++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.dataset.row = r;
        cell.dataset.col = c;

        const type = cells[r][c];
        if (type === "parking") {
          setImg(cell, CONFIG.images.parking);
        } else if (type === "column") {
          setImg(cell, CONFIG.images.column);
        } else if (type === "charging") {
          setImg(cell, CONFIG.images.charging);
        } else if (type === "shelf") {
          setImg(cell, CONFIG.images.shelf);
        } else if (type === "robot") {
          setImg(cell, CONFIG.images.robot);
          addChargeBar(cell, getRobotIndex(r, c));
        } else if (type === "robot_charging") {
          setImg(cell, CONFIG.images.robotCharging);
          addChargeBar(cell, getRobotIndex(r, c));
        } else if (type === "robot_with_shelf") {
          setImg(cell, CONFIG.images.robotWithShelf);
          addChargeBar(cell, getRobotIndex(r, c));
        } else if (type === "shelf_parked") {
          setImg(cell, CONFIG.images.parkedShelf);
        }

        cell.addEventListener("click", () => handleCellClick(r, c));
        grid.appendChild(cell);
      }
    }
  }

  function setImg(cell, src) {
    const img = document.createElement("img");
    img.src = src;
    cell.appendChild(img);
  }

  function addChargeBar(cell, robotIdx) {
    if (robotIdx === -1) return;
    const bar = document.createElement("div");
    bar.classList.add("charge-bar");
    const level = document.createElement("div");
    level.classList.add("charge-level");
    const charge = robotCharge[robotIdx];
    level.style.width = `${charge}%`;
    if (charge <= 25) level.style.backgroundColor = "red";
    else if (charge <= 50) level.style.backgroundColor = "orange";
    else if (charge <= 75) level.style.backgroundColor = "yellow";
    else level.style.backgroundColor = "green";
    bar.appendChild(level);
    cell.appendChild(bar);
  }

  function getRobotIndex(r, c) {
    for (let i = 0; i < robots.length; i++) {
      if (robots[i].r === r && robots[i].c === c) return i;
    }
    return -1;
  }

  // –õ–æ–≥–∏–∫–∞ –∫–ª–∏–∫–æ–≤
  function handleCellClick(r, c) {
    if (gameEnded) return;
    if (!gameStarted) startGame();

    const robotIdx = getRobotIndex(r, c);

    if (robotIdx !== -1 && !selectedRobot) {
      selectedRobot = { r, c, idx: robotIdx };
      highlightMoves(r, c);
      return;
    }

    if (selectedRobot) {
      if (isValidMove(selectedRobot.r, selectedRobot.c, r, c)) {
        moveRobot(selectedRobot.idx, r, c);
      }
      clearHighlights();
      selectedRobot = null;
    }
  }

  function highlightMoves(r, c) {
    clearHighlights();
    for (let nr = 0; nr < CONFIG.rows; nr++) {
      for (let nc = 0; nc < CONFIG.cols; nc++) {
        if (isValidMove(r, c, nr, nc)) {
          cells[nr][nc] = "trajectory";
        }
      }
    }
    renderGrid();
  }

  function clearHighlights() {
    for (let r = 0; r < CONFIG.rows; r++) {
      for (let c = 0; c < CONFIG.cols; c++) {
        if (cells[r][c] === "trajectory") {
          cells[r][c] = "free";
        }
      }
    }
  }

  function isValidMove(fromR, fromC, toR, toC) {
    if (!isValid(toR, toC) || (fromR === toR && fromC === toC)) return false;
    const dr = Math.abs(fromR - toR);
    const dc = Math.abs(fromC - toC);
    if (dr + dc !== 1) return false;

    const robotIdx = getRobotIndex(fromR, fromC);
    const hasShelf = cells[fromR][fromC] === "robot_with_shelf";
    const target = cells[toR][toC];

    if (["column", "robot", "free", "charging"].includes(target)) return true;
    if (hasShelf && ["shelf", "robot_with_shelf"].includes(target)) return true;
    if (hasShelf && target === "parking") return true;
    return false;
  }

  function moveRobot(idx, toR, toC) {
    const fromR = robots[idx].r;
    const fromC = robots[idx].c;
    const hasShelf = cells[fromR][fromC] === "robot_with_shelf";
    const target = cells[toR][toC];

    robotCharge[idx] = Math.max(0, robotCharge[idx] - CONFIG.chargeCostPerMove);
    if (robotCharge[idx] <= 0) {
      endGame(false);
      return;
    }

    // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
    if (hasShelf) {
      if (target === "parking") {
        cells[toR][toC] = "shelf_parked";
        shelves = shelves.filter(s => !(s.r === fromR && s.c === fromC));
      } else {
        cells[toR][toC] = "robot_with_shelf";
      }
      cells[fromR][fromC] = "free";
    } else {
      if (target === "shelf") {
        cells[toR][toC] = "robot_with_shelf";
      } else if (target === "charging") {
        cells[toR][toC] = "robot_charging";
      } else {
        cells[toR][toC] = "robot";
      }
      cells[fromR][fromC] = "free";
    }

    robots[idx] = { r: toR, c: toC };

    if (shelves.length === 0) endGame(true);
    renderGrid();
    updateChargeDisplay();
  }

  // === –¢–ê–ô–ú–ï–† –¢–ï–ü–ï–†–¨ –û–ë–ù–û–í–õ–Ø–ï–¢–°–Ø –†–û–í–ù–û –†–ê–ó –í –°–ï–ö–£–ù–î–£ ===
  function startGame() {
    if (gameStarted) return;
    gameStarted = true;
    updateChargeDisplay();
    gameInterval = setInterval(updateTimer, 1000); // üü¢ –¢–µ–ø–µ—Ä—å —Ä–æ–≤–Ω–æ 1 —Å–µ–∫—É–Ω–¥–∞
  }

  function updateTimer() {
    timer--;

    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏
    updateTimerDisplay();

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏
    if (timer <= 0) {
      endGame(false);
      return;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞—Ä—è–¥–∞
    for (const charge of robotCharge) {
      if (charge <= 0) {
        endGame(false);
        return;
      }
    }

    // –ü–æ–¥–∑–∞—Ä—è–¥–∫–∞ (—Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É)
    let chargingHappened = false;
    for (let i = 0; i < robots.length; i++) {
      const r = robots[i].r;
      const c = robots[i].c;
      if (cells[r][c] === "robot_charging" && robotCharge[i] < 100) {
        robotCharge[i] = Math.min(100, robotCharge[i] + CONFIG.chargeGainPerTick);
        chargingHappened = true;
      }
    }

    updateChargeDisplay();

    // –ï—Å–ª–∏ –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ (–∑–∞—Ä—è–¥–∫–∞), –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
    if (chargingHappened) {
      renderGrid();
    }
  }

  function updateTimerDisplay() {
    const mins = Math.floor(timer / 60).toString().padStart(2, '0');
    const secs = (timer % 60).toString().padStart(2, '0');
    timerDisplay.textContent = `${mins}:${secs}`;
  }

  function updateChargeDisplay() {
    const avg = robotCharge.length ? (robotCharge.reduce((a, b) => a + b, 0) / robotCharge.length) : 0;
    chargeDisplay.textContent = Math.round(avg) + "%";
  }

  function endGame(win) {
    clearInterval(gameInterval);
    gameEnded = true;
    overlay.style.display = "flex";
    overlay.textContent = win ? "–ü–û–ë–ï–î–ê!" : "GAME OVER";
  }

  function resetGame() {
    clearInterval(gameInterval);
    gameStarted = false;
    gameEnded = false;
    timer = CONFIG.gameMinutes * 60;
    selectedRobot = null;
    updateTimerDisplay();
    overlay.style.display = "none";
    chargeDisplay.textContent = "-";
    initGrid();
  }

  newGameBtn.addEventListener("click", resetGame);
  window.onload = resetGame;
</script>
</body>
</html>
