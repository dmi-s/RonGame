<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>–ü–∞–Ω–µ–ª—å –£–ø—Ä–∞–≤–ª–µ–Ω–∏—è –†–æ–±–æ—Ç–æ–º</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
      @font-face {
        font-family: 'NexaBold';
        src: url('Nexa-Bold.ttf') format('truetype');
        font-weight: bold;
        font-style: normal;
        font-display: swap;
    }
    body {
      overflow: hidden;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    #game-container {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      background: linear-gradient(135deg, #ccaa00, #ffdd00, #ffff00, #ffdd00, #ccaa00);
      border: 2px solid #222;
      box-shadow:
        0 0 20px #111,
        inset 0 0 20px rgba(255,255,255,0.05),
        inset 0 0 50px rgba(0,0,0,0.3);
      border-radius: 6px;
      image-rendering: pixelated;
      width: auto;
      height: auto;
      max-width: 100vw;
      max-height: 100vh;
    }

    /* –°—Ç–∏–ª—å –¥–ª—è —ç–∫—Ä–∞–Ω–∞ –æ—à–∏–±–∫–∏ –ø—Ä–∏ –ª–æ–∫–∞–ª—å–Ω–æ–º –∑–∞–ø—É—Å–∫–µ */
    #error-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #111;
      color: #ff3030;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 20px;
      z-index: 9999;
      font-family: 'Courier New', monospace;
    }
    #error-screen h1 {
      font-size: 2em;
      margin-bottom: 20px;
    }
    #error-screen p {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
  </style>

  <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>
  </div>

  <!-- –≠–∫—Ä–∞–Ω –æ—à–∏–±–∫–∏ –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ -->
  <div id="error-screen" style="display: none;">
    <h1>üö´ –î–û–°–¢–£–ü –ó–ê–ü–†–ï–©–ï–ù</h1>
    <p>–≠—Ç–∞ –∏–≥—Ä–∞ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –≤–Ω—É—Ç—Ä–∏ Telegram.</p>
    <p>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–∫—Ä–æ–π—Ç–µ –µ–µ —á–µ—Ä–µ–∑ –±–æ—Ç–∞ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ Telegram.</p>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    // === –†–ê–ó–ú–ï–†–´ –ü–ê–ù–ï–õ–ò ===
    const GAME_WIDTH = 420;  // –û–±—â–∏–π —Ä–∞–∑–º–µ—Ä canvas
    const GAME_HEIGHT = 650;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
    const TOP_MARGIN = 20;
    const PANEL_HEIGHT = 65;
    const GAP_TIMER_COUNTER = 10;
    const GAP_COUNTER_DISPLAY = 20;
    const DISPLAY_HEIGHT = 400; // –†–∞–∑–º–µ—Ä –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
    const BOTTOM_MARGIN = 20;
    const TIMER_Y = TOP_MARGIN;
    const COUNTER_Y = TIMER_Y + PANEL_HEIGHT + GAP_TIMER_COUNTER;
    const DISPLAY_Y = COUNTER_Y + PANEL_HEIGHT + GAP_COUNTER_DISPLAY;
    const PANEL_WIDTH = 126;
    const LEFT_MARGIN = 10;
    const GAP_VOLT_TIMER = 10;
    const VOLTMETER_X = LEFT_MARGIN;
    const VOLTMETER_Y = TIMER_Y;
    const VOLTMETER_WIDTH = PANEL_WIDTH;
    const VOLTMETER_HEIGHT = PANEL_HEIGHT;
    const TIMER_X = VOLTMETER_X + VOLTMETER_WIDTH + GAP_VOLT_TIMER;
    const TIMER_WIDTH = PANEL_WIDTH;
    const TIMER_HEIGHT = PANEL_HEIGHT;
    const COUNTER_X = TIMER_X;
    const COUNTER_WIDTH = PANEL_WIDTH;
    const COUNTER_HEIGHT = PANEL_HEIGHT;
    const LCD_X = VOLTMETER_X;
    const LCD_Y = COUNTER_Y;
    const LCD_WIDTH = PANEL_WIDTH;
    const LCD_HEIGHT = PANEL_HEIGHT;
    const DISPLAY_WIDTH = 400; // –†–∞–∑–º–µ—Ä –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
    const DISPLAY_X = 10;
    // === –ö–ù–û–ü–ö–ê POWER ===
    // –†–∞—Å—á–µ—Ç –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏ –∏ —Ä–∞–∑–º–µ—Ä–∞ –∫–Ω–æ–ø–∫–∏ POWER
    const POWER_BUTTON_HEIGHT = PANEL_HEIGHT; // –í—ã—Å–æ—Ç–∞ –∫–∞–∫ —É —Ç–∞–π–º–µ—Ä–∞
    const POWER_RIGHT_MARGIN = 10; // –û—Ç—Å—Ç—É–ø –æ—Ç –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è canvas
    const POWER_LEFT_MARGIN_FROM_TIMER = 10; // –û—Ç—Å—Ç—É–ø –æ—Ç –ø—Ä–∞–≤–æ–π —Å—Ç–æ—Ä–æ–Ω—ã —Ç–∞–π–º–µ—Ä–∞
    const POWER_X = TIMER_X + TIMER_WIDTH + POWER_LEFT_MARGIN_FROM_TIMER; // –õ–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ –∫–Ω–æ–ø–∫–∏
    const POWER_WIDTH = GAME_WIDTH - POWER_X - POWER_RIGHT_MARGIN; // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–∞—Å—á–µ—Ç —à–∏—Ä–∏–Ω—ã
    const POWER_Y = TIMER_Y;
    const POWER_CENTER_X = POWER_X + POWER_WIDTH / 2;
    const POWER_CENTER_Y = POWER_Y + POWER_BUTTON_HEIGHT / 2;
    // === –ö–ù–û–ü–ö–ò RESET –∏ PROG ===
    const FIELD_LEFT = COUNTER_X + COUNTER_WIDTH + 10;
    const FIELD_RIGHT = GAME_WIDTH - 10;
    const FIELD_TOP = COUNTER_Y;
    const FIELD_BOTTOM = COUNTER_Y + COUNTER_HEIGHT;
    const FIELD_WIDTH = FIELD_RIGHT - FIELD_LEFT;
    const FIELD_HEIGHT = FIELD_BOTTOM - FIELD_TOP;
    const SMALL_BUTTON_SIZE = 50;
    const GAP_BETWEEN_BUTTONS = 10;
    const FIELD_CENTER_X = (FIELD_LEFT + FIELD_RIGHT) / 2;
    const FIELD_CENTER_Y = (FIELD_TOP + FIELD_BOTTOM) / 2;
    const RST_X = FIELD_CENTER_X - SMALL_BUTTON_SIZE - GAP_BETWEEN_BUTTONS / 2;
    const RST_Y = FIELD_CENTER_Y - SMALL_BUTTON_SIZE / 2;
    const RST_CENTER_X = RST_X + SMALL_BUTTON_SIZE / 2;
    const RST_CENTER_Y = RST_Y + SMALL_BUTTON_SIZE / 2;
    const PRG_X = FIELD_CENTER_X + GAP_BETWEEN_BUTTONS / 2;
    const PRG_Y = FIELD_CENTER_Y - SMALL_BUTTON_SIZE / 2;
    const PRG_CENTER_X = PRG_X + SMALL_BUTTON_SIZE / 2;
    const PRG_CENTER_Y = PRG_Y + SMALL_BUTTON_SIZE / 2;
    // === –ó–ê–†–Ø–î –†–û–ë–û–¢–ê ===
    let robotCharge = 100;
    let lastChargeTick = 0;
    let isPowerOn = false;
    let isRSTPressed = false;
    let isPRGPressed = false;
    let powerOffBlink = 0;
    // let timerSeconds = 180; ‚Üê –£–î–ê–õ–ï–ù–û
    // let lastTickTime = 0; ‚Üê –£–î–ê–õ–ï–ù–û
    let counterValue = 0;
    let lastCounterTick = 0;
    let animatingDigit = null;
    let systemsActive = false;
    // === –¢–ï–ö–°–¢ –ó–ê–ì–†–£–ó–ö–ò ===
    const bootText = [
      ">>> INIT",
      ">>> CONNECT TO RONAVI_MCNS",
      ">>> LOW SIGNAL",
      ">>> SUDO START_GAME",
      ">>> GAME START IN",
      ">>> 3",
      ">>> 2",
      ">>> 1"
    ];
    let bootLineIndex = 0;
    let bootCharIndex = 0;
    let lastBootTick = 0;
    let bootActive = false;
    let bootCompleted = false;
    // ‚Üê GODMODE
    let prgPressCount = 0;
    let godmodeActive = false;
    let passwordMode = false;
    let inputCode = [];
    let lastPasswordTick = 0;
    let passwordLineIndex = 0;
    let passwordCharIndex = 0;
    const passwordText = [
      ">>>GODMODE_OFF",
      ">>>ENTER PASSWORD"
    ];
    // ‚Üê GODMODE: –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
    const KEYPAD_SIZE = 50;
    const KEYPAD_GAP = 10;
    const KEYPAD_ROWS = 4;
    const KEYPAD_COLS = 3;
    const KEYPAD_TOTAL_WIDTH = KEYPAD_COLS * KEYPAD_SIZE + (KEYPAD_COLS - 1) * KEYPAD_GAP;
    const KEYPAD_TOTAL_HEIGHT = KEYPAD_ROWS * KEYPAD_SIZE + (KEYPAD_ROWS - 1) * KEYPAD_GAP;
    const KEYPAD_START_X = DISPLAY_X + (DISPLAY_WIDTH - KEYPAD_TOTAL_WIDTH) / 2;
    const KEYPAD_START_Y = DISPLAY_Y + 120;
    let pressedKey = null;
    // ‚Üê GODMODE: –æ—à–∏–±–∫–∞
    let errorMode = false;
    let errorText = [
      ">>>GODMODE_OFF",
      ">>>ERROR",
      ">>>POWER_OFF"
    ];
    let errorLineIndex = 0;
    let errorCharIndex = 0;
    let lastErrorTick = 0;
    let errorCompleted = false;
    // ‚Üê GODMODE: —É—Å–ø–µ—à–Ω–∞—è –∞–∫—Ç–∏–≤–∞—Ü–∏—è
    let godmodeSuccess = false;
    let godmodeDisplayText = [">>>GODMODE_ON"];
    let godmodeDisplayLineIndex = 0;
    let godmodeDisplayCharIndex = 0;
    let lastGodmodeDisplayTick = 0;
    let godmodeDisplayCompleted = false;
    // ‚Üê –§–ª–∞–≥: GODMODE –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –∏ —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω (—Ç–µ–∫—Å—Ç –∏—Å—á–µ–∑, –≤—Å—ë –∑–∞–º–æ—Ä–æ–∂–µ–Ω–æ)
    let isGodmodeFinalized = false;
    // ‚Üê –§–ª–∞–≥: –≠–∫—Ä–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä—ã –∞–∫—Ç–∏–≤–µ–Ω (–∏—Å—Ç–µ–∫–ª–æ –≤—Ä–µ–º—è –∏–ª–∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω GODMODE)
    let isGameOverScreenActive = false;
    // === –ò–ì–†–ê "–†–û–ë–û–¢–´" ===
    const gridSize = 40;
    const gridWidth = 10; // 400 / 40
    const gridHeight = 10; // 400 / 40
    let snakes = [];
    let food = [];
    let obstacles = [];
    let chargingStations = [];
    let parkingSpots = [];
    let score = 0;
    let gameRunning = false;
    let gameStarted = false;
    let targetPoints = [];
    let selectedSnakeIndex = -1;
    let activeRobotIndex = -1;
    let gameInterval;
    let gameTimer;
    let timeLeft = 180;
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —Å—Ç–∞—Ä—Ç–æ–≤—ã–π –∑–∞—Ä—è–¥ –æ—Ç 25 –¥–æ 90 –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–æ–±–æ—Ç–∞
    let snakeCharges = [
        Math.floor(Math.random() * (90 - 25 + 1)) + 25,
        Math.floor(Math.random() * (90 - 25 + 1)) + 25,
        Math.floor(Math.random() * (90 - 25 + 1)) + 25
    ];
    let moveCounts = [0, 0, 0];
    let onChargingStation = [-1, -1, -1];
    let chargingTimers = [null, null, null];
    let hasCargo = [false, false, false];
    let cargoFood = [null, null, null];
    let onParking = [-1, -1, -1];
    let isBlinking = [false, false, false];
    let snakeRoutes = [[], [], []];
    let routeProgress = [0, 0, 0];
    let reservedTargets = {};
    let snakeRouteTimestamps = [0, 0, 0];
    // –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–≥–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–∂–¥–æ–≥–æ —Ä–æ–±–æ—Ç–∞
    let lastHorizontalDirection = ['right', 'right', 'right']; // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º 'right' –¥–ª—è –≤—Å–µ—Ö
    let snakeHeadImage = new Image();
    let snakeHeadLeftImage = new Image(); // –ù–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –≤–ª–µ–≤–æ
    let snakeHeadWithShelfImage = new Image();
    let snakeHeadWithShelfRightImage = new Image(); // –ù–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –≤–ø—Ä–∞–≤–æ —Å –≥—Ä—É–∑–æ–º
    let snakeHeadChargingImage = new Image();
    let snakeHeadChargingRightImage = new Image(); // –ù–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –≤–ø—Ä–∞–≤–æ –Ω–∞ –∑–∞—Ä—è–¥–∫–µ
    let foodImage = new Image();
    let chargingImage = new Image();
    let parkingImage = new Image();
    let obstacleImage = new Image();
    // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    snakeHeadImage.src = 'Robot.png';
    snakeHeadLeftImage.src = 'robot_left.png'; // –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    snakeHeadWithShelfImage.src = 'Robot_Shelf.png';
    snakeHeadWithShelfRightImage.src = 'Robot_Shelf_right.png'; // –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    snakeHeadChargingImage.src = 'Robot_Charg.png';
    snakeHeadChargingRightImage.src = 'Robot_Charg_right.png'; // –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    foodImage.src = 'Shelf.png';
    chargingImage.src = 'Charging.png';
    parkingImage.src = 'Parking.png';
    obstacleImage.src = 'Column.png';
    function isObstacle(x, y) {
        for (let obstacle of obstacles) {
            if (obstacle.x === x && obstacle.y === y) {
                return true;
            }
        }
        return false;
    }
    function isChargingStation(x, y) {
        for (let i = 0; i < chargingStations.length; i++) {
            if (chargingStations[i].x === x && chargingStations[i].y === y) {
                return i;
            }
        }
        return -1;
    }
    function isParkingSpot(x, y) {
        for (let i = 0; i < parkingSpots.length; i++) {
            if (parkingSpots[i].x === x && parkingSpots[i].y === y) {
                return i;
            }
        }
        return -1;
    }
    function isOtherSnake(x, y, snakeIndex) {
        for (let i = 0; i < snakes.length; i++) {
            if (i !== snakeIndex) {
                for (let segment of snakes[i]) {
                    if (segment.x === x && segment.y === y) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    function isFood(x, y) {
        for (let f of food) {
            if (f.x === x && f.y === y) {
                return true;
            }
        }
        return false;
    }
    function routesIntersect(snakeIndex1, snakeIndex2) {
        if (snakeRoutes[snakeIndex1].length === 0 || snakeRoutes[snakeIndex2].length === 0) {
            return false;
        }
        for (let i = routeProgress[snakeIndex1]; i < snakeRoutes[snakeIndex1].length; i++) {
            const point1 = snakeRoutes[snakeIndex1][i];
            for (let j = routeProgress[snakeIndex2]; j < snakeRoutes[snakeIndex2].length; j++) {
                const point2 = snakeRoutes[snakeIndex2][j];
                if (point1.x === point2.x && point1.y === point2.y) {
                    return true;
                }
            }
        }
        return false;
    }
    function aStar(startX, startY, endX, endY, snakeIndex) {
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }
        function canMoveTo(x, y, snakeIndex) {
            if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return false;
            if (isObstacle(x, y)) return false;
            if (isOtherSnake(x, y, snakeIndex)) return false;
            if (hasCargo[snakeIndex] && isChargingStation(x, y) !== -1) return false;
            if (hasCargo[snakeIndex] && isFood(x, y)) return false;
            const targetKey = `${x},${y}`;
            if (reservedTargets[targetKey] !== undefined && reservedTargets[targetKey] !== snakeIndex) {
                return false;
            }
            return true;
        }
        const start = {x: startX, y: startY};
        const end = {x: endX, y: endY};
        let openSet = [start];
        let closedSet = [];
        let cameFrom = {};
        let gScore = {};
        let fScore = {};
        gScore[startKey(start)] = 0;
        fScore[startKey(start)] = heuristic(start, end);
        while (openSet.length > 0) {
            let current = openSet.reduce((min, node) => {
                return fScore[startKey(node)] < fScore[startKey(min)] ? node : min;
            });
            if (current.x === end.x && current.y === end.y) {
                let path = [];
                let temp = current;
                while (temp) {
                    path.unshift(temp);
                    temp = cameFrom[startKey(temp)];
                }
                return path;
            }
            const currentIndex = openSet.indexOf(current);
            openSet.splice(currentIndex, 1);
            closedSet.push(current);
            const neighbors = [
                {x: current.x, y: current.y - 1},
                {x: current.x, y: current.y + 1},
                {x: current.x - 1, y: current.y},
                {x: current.x + 1, y: current.y}
            ];
            for (let neighbor of neighbors) {
                if (!canMoveTo(neighbor.x, neighbor.y, snakeIndex)) continue;
                if (closedSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) continue;
                const tentativeGScore = gScore[startKey(current)] + 1;
                const neighborKey = startKey(neighbor);
                const neighborInOpen = openSet.find(node => node.x === neighbor.x && node.y === neighbor.y);
                if (!neighborInOpen) {
                    openSet.push(neighbor);
                    gScore[neighborKey] = tentativeGScore;
                    fScore[neighborKey] = tentativeGScore + heuristic(neighbor, end);
                    cameFrom[neighborKey] = current;
                } else if (tentativeGScore < gScore[neighborKey]) {
                    gScore[neighborKey] = tentativeGScore;
                    fScore[neighborKey] = tentativeGScore + heuristic(neighbor, end);
                    cameFrom[neighborKey] = current;
                }
            }
        }
        return [];
    }
    function startKey(point) {
        return point.x + ',' + point.y;
    }
    function buildRoute(startX, startY, endX, endY, snakeIndex) {
        const path = aStar(startX, startY, endX, endY, snakeIndex);
        // <<< –ù–û–í–´–ô –ë–õ–û–ö: –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –ø–æ –º–∞—Ä—à—Ä—É—Ç—É >>>
        if (path.length > 1) {
            // –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è (–∏–Ω–¥–µ–∫—Å 1, —Ç–∞–∫ –∫–∞–∫ –∏–Ω–¥–µ–∫—Å 0 ‚Äî —Ç–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è)
            const firstStep = path[1];
            const dx = firstStep.x - startX;
            // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –¥–ª—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
            if (dx > 0) {
                lastHorizontalDirection[snakeIndex] = 'right';
            } else if (dx < 0) {
                lastHorizontalDirection[snakeIndex] = 'left';
            }
            // –ï—Å–ª–∏ dx === 0 (–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ), –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–µ –º–µ–Ω—è–µ–º
        }
        // <<< –ö–û–ù–ï–¶ –ù–û–í–û–ì–û –ë–õ–û–ö–ê >>>
        return path;
    }
    function initGame() {
        snakes = [];
        selectedSnakeIndex = -1;
        activeRobotIndex = -1;
        targetPoints = [];
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —Å—Ç–∞—Ä—Ç–æ–≤—ã–π –∑–∞—Ä—è–¥ –æ—Ç 25 –¥–æ 90 –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–æ–±–æ—Ç–∞
        snakeCharges = [
            Math.floor(Math.random() * (90 - 25 + 1)) + 25,
            Math.floor(Math.random() * (90 - 25 + 1)) + 25,
            Math.floor(Math.random() * (90 - 25 + 1)) + 25
        ];
        moveCounts = [0, 0, 0];
        onChargingStation = [-1, -1, -1];
        chargingTimers = [null, null, null];
        hasCargo = [false, false, false];
        cargoFood = [null, null, null];
        onParking = [-1, -1, -1];
        isBlinking = [false, false, false];
        snakeRoutes = [[], [], []];
        routeProgress = [0, 0, 0];
        reservedTargets = {};
        snakeRouteTimestamps = [0, 0, 0];
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–≥—Ä—ã
        lastHorizontalDirection = ['right', 'right', 'right'];
        let positions = [];
        for (let i = 0; i < 3; i++) {
            let validPosition = false;
            let newPosition;
            while (!validPosition) {
                newPosition = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
                validPosition = true;
                for (let pos of positions) {
                    if (pos.x === newPosition.x && pos.y === newPosition.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
            positions.push(newPosition);
            snakes.push([{x: newPosition.x, y: newPosition.y}]);
            targetPoints.push(null);
        }
        generateObstacles();
        generateChargingStations();
        generateParkingSpots();
        generateFood();
        score = 0;
        timeLeft = 180;
    }
    function generateObstacles() {
        obstacles = [];
        const obstacleCount = 5;
        for (let i = 0; i < obstacleCount; i++) {
            let newObstacle;
            let validPosition = false;
            let attempts = 0;
            while (!validPosition && attempts < 1000) {
                attempts++;
                newObstacle = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
                validPosition = true;
                for (let snake of snakes) {
                    for (let segment of snake) {
                        if (segment.x === newObstacle.x && segment.y === newObstacle.y) {
                            validPosition = false;
                            break;
                        }
                    }
                    if (!validPosition) break;
                }
                if (validPosition) {
                    for (let existingFood of food) {
                        if (existingFood.x === newObstacle.x && existingFood.y === newObstacle.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                if (validPosition) {
                    for (let existingObstacle of obstacles) {
                        const distance = Math.abs(existingObstacle.x - newObstacle.x) + Math.abs(existingObstacle.y - newObstacle.y);
                        if (distance <= 2) {
                            validPosition = false;
                            break;
                        }
                    }
                }
            }
            if (attempts >= 1000) {
                console.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ –∑–∞ 1000 –ø–æ–ø—ã—Ç–æ–∫");
                break;
            }
            obstacles.push(newObstacle);
        }
    }
    function generateChargingStations() {
        chargingStations = [];
        const stationCount = 2;
        for (let i = 0; i < stationCount; i++) {
            let validPosition = false;
            let newStation;
            let obstacleUsed = null;
            let attempts = 0;
            while (!validPosition && attempts < 1000) {
                attempts++;
                const obstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
                if (obstacleUsed && obstacleUsed.x === obstacle.x && obstacleUsed.y === obstacle.y) {
                    continue;
                }
                const directions = [
                    {x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}
                ];
                const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                newStation = {
                    x: obstacle.x + randomDirection.x,
                    y: obstacle.y + randomDirection.y
                };
                if (newStation.x >= 0 && newStation.x < gridWidth && newStation.y >= 0 && newStation.y < gridHeight) {
                    let onObstacle = obstacles.some(o => o.x === newStation.x && o.y === newStation.y);
                    let onSnake = snakes.some(s => s.some(seg => seg.x === newStation.x && seg.y === newStation.y));
                    let onFood = food.some(f => f.x === newStation.x && f.y === newStation.y);
                    let onStation = chargingStations.some(s => s.x === newStation.x && s.y === newStation.y);
                    if (!onObstacle && !onSnake && !onFood && !onStation) {
                        validPosition = true;
                        obstacleUsed = obstacle;
                    }
                }
            }
            if (attempts >= 1000) {
                console.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∑–∞—Ä—è–¥–Ω—É—é —Å—Ç–∞–Ω—Ü–∏—é –∑–∞ 1000 –ø–æ–ø—ã—Ç–æ–∫");
                break;
            }
            chargingStations.push(newStation);
        }
    }
    function generateParkingSpots() {
        parkingSpots = [];
        const parkingCount = 3;
        let attempts = 0;
        let maxAttempts = 1000;
        while (attempts < maxAttempts) {
            attempts++;
            let obstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
            const isHorizontal = Math.random() > 0.5;
            let parkingGroup = [];
            if (isHorizontal) {
                parkingGroup.push({x: obstacle.x + 1, y: obstacle.y});
                parkingGroup.push({x: obstacle.x + 2, y: obstacle.y});
                parkingGroup.push({x: obstacle.x + 3, y: obstacle.y});
            } else {
                parkingGroup.push({x: obstacle.x, y: obstacle.y + 1});
                parkingGroup.push({x: obstacle.x, y: obstacle.y + 2});
                parkingGroup.push({x: obstacle.x, y: obstacle.y + 3});
            }
            let validPosition = true;
            for (let spot of parkingGroup) {
                if (spot.x < 0 || spot.x >= gridWidth || spot.y < 0 || spot.y >= gridHeight) {
                    validPosition = false;
                    break;
                }
                if (obstacles.some(o => o.x === spot.x && o.y === spot.y)) validPosition = false;
                if (snakes.some(s => s.some(seg => seg.x === spot.x && seg.y === spot.y))) validPosition = false;
                if (food.some(f => f.x === spot.x && f.y === spot.y)) validPosition = false;
                if (chargingStations.some(s => s.x === spot.x && s.y === spot.y)) validPosition = false;
                if (obstacles.some(o => Math.abs(o.x - spot.x) + Math.abs(o.y - spot.y) <= 0)) validPosition = false;
            }
            if (validPosition) {
                parkingSpots = parkingGroup;
                return;
            }
        }
        console.error(`–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä–∫–æ–≤–æ—á–Ω—ã–µ –º–µ—Å—Ç–∞ –∑–∞ ${maxAttempts} –ø–æ–ø—ã—Ç–æ–∫`);
        parkingSpots = [];
    }
    function generateFood() {
        food = [];
        for (let i = 0; i < 3; i++) {
            let newFood;
            let validPosition = false;
            let attempts = 0;
            while (!validPosition && attempts < 1000) {
                attempts++;
                newFood = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
                validPosition = true;
                for (let snake of snakes) {
                    for (let segment of snake) {
                        if (segment.x === newFood.x && segment.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                    if (!validPosition) break;
                }
                if (validPosition) {
                    for (let obstacle of obstacles) {
                        if (obstacle.x === newFood.x && obstacle.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                if (validPosition) {
                    for (let station of chargingStations) {
                        if (station.x === newFood.x && station.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                if (validPosition) {
                    for (let parking of parkingSpots) {
                        if (parking.x === newFood.x && parking.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                if (validPosition) {
                    for (let existingFood of food) {
                        if (existingFood.x === newFood.x && existingFood.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
            }
            if (attempts >= 1000) {
                console.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –µ–¥—É –∑–∞ 1000 –ø–æ–ø—ã—Ç–æ–∫");
                break;
            }
            food.push(newFood);
        }
    }
    function update() {
        if (!gameStarted) return;
        for (let i = 0; i < snakes.length; i++) {
            const snake = snakes[i];
            const targetPoint = targetPoints[i];
            if (!targetPoint || snakeRoutes[i].length === 0) continue;
            if (snakeCharges[i] <= 0) {
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –º–∞—Ä—à—Ä—É—Ç –∏ —Ü–µ–ª–µ–≤—É—é —Ç–æ—á–∫—É, —Ç–∞–∫ –∫–∞–∫ —Ä–æ–±–æ—Ç —Ä–∞–∑—Ä—è–¥–∏–ª—Å—è
                if (targetPoints[i]) {
                    const key = `${targetPoints[i].x},${targetPoints[i].y}`;
                    if (reservedTargets[key] === i) {
                        delete reservedTargets[key];
                    }
                    targetPoints[i] = null;
                }
                snakeRoutes[i] = [];
                routeProgress[i] = 0;
                continue;
            }
            let mustStop = false;
            for (let j = 0; j < snakes.length; j++) {
                if (i === j || snakeRoutes[j].length === 0) continue;
                if (routesIntersect(i, j)) {
                    if (snakeRouteTimestamps[j] < snakeRouteTimestamps[i]) {
                        mustStop = true;
                        break;
                    }
                }
            }
            if (mustStop) continue;
            const head = snake[0];
            if (routeProgress[i] < snakeRoutes[i].length) {
                const nextPoint = snakeRoutes[i][routeProgress[i]];
                if (head.x === nextPoint.x && head.y === nextPoint.y) {
                    routeProgress[i]++;
                    if (routeProgress[i] >= snakeRoutes[i].length) {
                        if (targetPoints[i]) {
                            const key = `${targetPoints[i].x},${targetPoints[i].y}`;
                            if (reservedTargets[key] === i) {
                                delete reservedTargets[key];
                            }
                            targetPoints[i] = null;
                        }
                        snakeRoutes[i] = [];
                        routeProgress[i] = 0;
                        if (i === activeRobotIndex) {
                            isBlinking[i] = true;
                        }
                        continue;
                    }
                }
            }
            if (routeProgress[i] < snakeRoutes[i].length) {
                const nextPoint = snakeRoutes[i][routeProgress[i]];
                const dx = nextPoint.x - head.x;
                const dy = nextPoint.y - head.y;
                const newHead = {x: head.x, y: head.y};
                // <<< –ù–û–í–´–ô –ë–õ–û–ö: –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –ö–ê–ñ–î–û–ú —à–∞–≥–µ –¥–≤–∏–∂–µ–Ω–∏—è >>>
                if (dx > 0) {
                    newHead.x++;
                    lastHorizontalDirection[i] = 'right'; // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –≤–ø—Ä–∞–≤–æ
                }
                else if (dx < 0) {
                    newHead.x--;
                    lastHorizontalDirection[i] = 'left'; // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –≤–ª–µ–≤–æ
                }
                else if (dy > 0) {
                    newHead.y++;
                    // –ü—Ä–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–º –¥–≤–∏–∂–µ–Ω–∏–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ù–ï –º–µ–Ω—è–µ–º, –æ—Å—Ç–∞–≤–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ
                }
                else if (dy < 0) {
                    newHead.y--;
                    // –ü—Ä–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–º –¥–≤–∏–∂–µ–Ω–∏–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ù–ï –º–µ–Ω—è–µ–º, –æ—Å—Ç–∞–≤–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ
                }
                // <<< –ö–û–ù–ï–¶ –ù–û–í–û–ì–û –ë–õ–û–ö–ê >>>
                if (newHead.x < 0 || newHead.x >= gridWidth || newHead.y < 0 || newHead.y >= gridHeight) {
                    return;
                }
                for (let j = 0; j < snake.length; j++) {
                    if (snake[j].x === newHead.x && snake[j].y === newHead.y) {
                        return;
                    }
                }
                for (let obstacle of obstacles) {
                    if (obstacle.x === newHead.x && obstacle.y === newHead.y) {
                        return;
                    }
                }
                for (let j = 0; j < snakes.length; j++) {
                    if (i !== j) {
                        for (let segment of snakes[j]) {
                            if (segment.x === newHead.x && segment.y === newHead.y) {
                                return;
                            }
                        }
                    }
                }
                let stationIndex = isChargingStation(newHead.x, newHead.y);
                let parkingIndex = isParkingSpot(newHead.x, newHead.y);
                moveCounts[i]++;
                if (moveCounts[i] >= 2 && stationIndex === -1 && parkingIndex === -1) {
                    snakeCharges[i]--;
                    moveCounts[i] = 0;
                }
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ä–æ–±–æ—Ç –Ω–∞ –∑–∞—Ä—è–¥–Ω–æ–π —Å—Ç–∞–Ω—Ü–∏–∏
                if (stationIndex !== -1) {
                    // –£—Å–ª–æ–≤–∏—è –¥–ª—è –ù–ê–ß–ê–õ–ê –∏–ª–∏ –ü–†–û–î–û–õ–ñ–ï–ù–ò–Ø –∑–∞—Ä—è–¥–∫–∏:
                    // 1. –†–æ–±–æ—Ç –Ω–µ –∏–º–µ–µ—Ç –≥—Ä—É–∑–∞
                    // 2. –û–Ω –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ —Å—Ç–∞–Ω—Ü–∏–∏ (—ç—Ç–æ —É–∂–µ true, —Ç–∞–∫ –∫–∞–∫ stationIndex !== -1)
                    if (!hasCargo[i]) {
                        // –ï—Å–ª–∏ –∑–∞—Ä—è–¥–∫–∞ –µ—â–µ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞, –∑–∞–ø—É—Å–∫–∞–µ–º –µ–µ
                        if (onChargingStation[i] === -1) {
                            onChargingStation[i] = stationIndex;
                            startCharging(i);
                        }
                        // –ï—Å–ª–∏ –∑–∞—Ä—è–¥–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞, –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º (–æ–Ω–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è)
                    } else {
                        // –ï—Å–ª–∏ —Ä–æ–±–æ—Ç –∏–º–µ–µ—Ç –≥—Ä—É–∑, –Ω–æ –ø—Ä–∏ —ç—Ç–æ–º –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ —Å—Ç–∞–Ω—Ü–∏–∏ –∏ –∑–∞—Ä—è–∂–∞–µ—Ç—Å—è ‚Äî –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞—Ä—è–¥–∫—É
                        if (onChargingStation[i] !== -1) {
                            stopCharging(i);
                            onChargingStation[i] = -1;
                        }
                    }
                } else {
                    // –ï—Å–ª–∏ —Ä–æ–±–æ—Ç –ù–ï –Ω–∞ —Å—Ç–∞–Ω—Ü–∏–∏, –Ω–æ –∑–∞—Ä—è–¥–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ ‚Äî –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –µ–µ
                    if (onChargingStation[i] !== -1) {
                        stopCharging(i);
                        onChargingStation[i] = -1;
                    }
                }
                if (parkingIndex !== -1) {
                    const targetPoint = targetPoints[i];
                    if (targetPoint && newHead.x === targetPoint.x && newHead.y === targetPoint.y) {
                        if (hasCargo[i]) {
                            hasCargo[i] = false;
                            cargoFood[i] = null;
                            score += 10;
                        }
                    }
                } else {
                    if (onParking[i] !== -1) onParking[i] = -1;
                }
                snake[0] = newHead;
                let foodEaten = false;
                let foodIndex = -1;
                for (let j = 0; j < food.length; j++) {
                    if (newHead.x === food[j].x && newHead.y === food[j].y) {
                        const targetPoint = targetPoints[i];
                        if (targetPoint && newHead.x === targetPoint.x && newHead.y === targetPoint.y && !hasCargo[i]) {
                            foodEaten = true;
                            foodIndex = j;
                            break;
                        }
                    }
                }
                if (foodEaten) {
                    hasCargo[i] = true;
                    cargoFood[i] = {x: food[foodIndex].x, y: food[foodIndex].y};
                    food.splice(foodIndex, 1);
                    generateNewFood();
                }
            }
        }
    }
    function startCharging(snakeIndex) {
        if (chargingTimers[snakeIndex]) clearInterval(chargingTimers[snakeIndex]);
        chargingTimers[snakeIndex] = setInterval(() => {
            if (snakeCharges[snakeIndex] < 100) {
                snakeCharges[snakeIndex] = Math.min(100, snakeCharges[snakeIndex] + 2);
            }
        }, 1000);
    }
    function stopCharging(snakeIndex) {
        if (chargingTimers[snakeIndex]) {
            clearInterval(chargingTimers[snakeIndex]);
            chargingTimers[snakeIndex] = null;
        }
    }
    function generateNewFood() {
        let newFood;
        let validPosition = false;
        let attempts = 0;
        while (!validPosition && attempts < 1000) {
            attempts++;
            newFood = {
                x: Math.floor(Math.random() * gridWidth),
                y: Math.floor(Math.random() * gridHeight)
            };
            validPosition = true;
            for (let snake of snakes) {
                for (let segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
                if (!validPosition) break;
            }
            if (validPosition) {
                for (let obstacle of obstacles) {
                    if (obstacle.x === newFood.x && obstacle.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
            if (validPosition) {
                for (let station of chargingStations) {
                    if (station.x === newFood.x && station.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
            if (validPosition) {
                for (let parking of parkingSpots) {
                    if (parking.x === newFood.x && parking.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
            if (validPosition) {
                for (let existingFood of food) {
                    if (existingFood.x === newFood.x && existingFood.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
        }
        if (attempts < 1000) food.push(newFood);
    }
    function drawGame() {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        ctx.save();
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –æ–±–ª–∞—Å—Ç—å –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
        ctx.beginPath();
        ctx.rect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
        ctx.clip();
        // –°–¥–≤–∏–≥–∞–µ–º —Å–∏—Å—Ç–µ–º—É –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        ctx.translate(DISPLAY_X, DISPLAY_Y);
        // –û—á–∏—â–∞–µ–º —Ç–æ–ª—å–∫–æ –æ–±–ª–∞—Å—Ç—å –∏–≥—Ä—ã
        ctx.fillStyle = '#b1b1b1';
        ctx.fillRect(0, 0, DISPLAY_WIDTH, DISPLAY_HEIGHT);
        // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
        ctx.strokeStyle = '#cccccc';
        ctx.lineWidth = 1;
        for (let x = 0; x <= gridWidth; x++) {
            ctx.beginPath();
            ctx.moveTo(x * gridSize, 0);
            ctx.lineTo(x * gridSize, DISPLAY_HEIGHT);
            ctx.stroke();
        }
        for (let y = 0; y <= gridHeight; y++) {
            ctx.beginPath();
            ctx.moveTo(0, y * gridSize);
            ctx.lineTo(DISPLAY_WIDTH, y * gridSize);
            ctx.stroke();
        }
        // –†–∏—Å—É–µ–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
        obstacles.forEach(obstacle => {
            if (obstacleImage.complete) {
                ctx.drawImage(obstacleImage, obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize);
            } else {
                ctx.fillStyle = '#800080';
                ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize);
            }
        });
        // <<< –ù–ê–ß–ê–õ–û –ò–ó–ú–ï–ù–ï–ù–ò–ô: –ó–∞—Ä—è–¥–∫–∞ –∏ –ø–∞—Ä–∫–æ–≤–∫–∞ —Ä–∏—Å—É—é—Ç—Å—è –ü–ï–†–ï–î —Ä–æ–±–æ—Ç–∞–º–∏ >>>
        // –†–∏—Å—É–µ–º –∑–∞—Ä—è–¥–Ω—ã–µ —Å—Ç–∞–Ω—Ü–∏–∏
        chargingStations.forEach((station, index) => {
            // <<< –ò–ó–ú–ï–ù–ï–ù–û: –ó–∞—Ä—è–¥–Ω—ã–µ —Å—Ç–∞–Ω—Ü–∏–∏ –í–°–ï–ì–î–ê –≤–∏–¥–Ω—ã >>>
            // shouldHide –≤—Å–µ–≥–¥–∞ false, –ª–æ–≥–∏–∫–∞ —Å–∫—Ä—ã—Ç–∏—è –£–î–ê–õ–ï–ù–ê
            if (chargingImage.complete) {
                ctx.drawImage(chargingImage, station.x * gridSize, station.y * gridSize, gridSize, gridSize);
            } else {
                ctx.fillStyle = '#ff69b4';
                ctx.fillRect(station.x * gridSize, station.y * gridSize, gridSize, gridSize);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(station.x * gridSize, station.y * gridSize, gridSize, gridSize);
            }
            // <<< –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô >>>
        });
        // –†–∏—Å—É–µ–º –µ–¥—É
        food.forEach(f => {
            let shouldHide = false;
            for (let i = 0; i < snakes.length; i++) {
                const head = snakes[i][0];
                // –°–∫—Ä—ã–≤–∞–µ–º –µ–¥—É, –µ—Å–ª–∏ —Ä–æ–±–æ—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ –∫–ª–µ—Ç–∫–µ –ò –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ "EMPTY"
                if (head.x === f.x && head.y === f.y && !hasCargo[i]) {
                    shouldHide = true;
                    break;
                }
            }
            if (!shouldHide) {
                if (foodImage.complete) {
                    ctx.drawImage(foodImage, f.x * gridSize, f.y * gridSize, gridSize, gridSize);
                } else {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(f.x * gridSize, f.y * gridSize, gridSize, gridSize);
                    ctx.strokeStyle = 'darkred';
                    ctx.strokeRect(f.x * gridSize, f.y * gridSize, gridSize, gridSize);
                }
            }
        });
        // <<< –ù–ê–ß–ê–õ–û –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø: –°–Ω–∞—á–∞–ª–∞ —Ä–∏—Å—É–µ–º –ø–∞—Ä–∫–æ–≤–∫–∏, –ø–æ—Ç–æ–º —Ä–æ–±–æ—Ç–æ–≤ >>>
        // –†–∏—Å—É–µ–º –ø–∞—Ä–∫–æ–≤–æ—á–Ω—ã–µ –º–µ—Å—Ç–∞ –ü–ï–†–ï–î —Ä–æ–±–æ—Ç–∞–º–∏
        parkingSpots.forEach(parking => {
            let showParking = true;
            for (let i = 0; i < snakes.length; i++) {
                const head = snakes[i][0];
                if (head.x === parking.x && head.y === parking.y) {
                    const targetPoint = targetPoints[i];
                    if (targetPoint && targetPoint.x === parking.x && targetPoint.y === parking.y) {
                        showParking = true;
                    } else if (hasCargo[i]) {
                        showParking = false;
                    }
                    break;
                }
            }
            if (showParking) {
                if (parkingImage.complete) {
                    ctx.drawImage(parkingImage, parking.x * gridSize, parking.y * gridSize, gridSize, gridSize);
                } else {
                    ctx.fillStyle = '#0000ff';
                    ctx.fillRect(parking.x * gridSize, parking.y * gridSize, gridSize, gridSize);
                    ctx.strokeStyle = 'black';
                    ctx.strokeRect(parking.x * gridSize, parking.y * gridSize, gridSize, gridSize);
                }
            }
        });
        // –†–∏—Å—É–µ–º –∑–º–µ–µ–∫ (—Ä–æ–±–æ—Ç–æ–≤) –ü–û–°–õ–ï –ø–∞—Ä–∫–æ–≤–æ–∫
        snakes.forEach((snake, snakeIndex) => {
            snake.forEach((segment, index) => {
                if (index === 0) {
                    let headImageToUse = snakeHeadImage; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é - –¥–≤–∏–∂–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ
                    // <<< –ò–ó–ú–ï–ù–ï–ù–û: –õ–æ–≥–∏–∫–∞ –≤—ã–±–æ—Ä–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –£–ü–†–û–©–ï–ù–ê >>>
                    // –ï—Å–ª–∏ —Ä–æ–±–æ—Ç –∏–º–µ–µ—Ç –≥—Ä—É–∑, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                    if (hasCargo[snakeIndex]) {
                        // –í—ã–±–∏—Ä–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–≥–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                        if (lastHorizontalDirection[snakeIndex] === 'left') {
                            headImageToUse = snakeHeadWithShelfImage; // Robot_Shelf.png
                        } else {
                            headImageToUse = snakeHeadWithShelfRightImage; // Robot_Shelf_right.png
                        }
                    } else {
                        // –î–ª—è —Ä–æ–±–æ—Ç–∞ –±–µ–∑ –≥—Ä—É–∑–∞, –≤—ã–±–∏—Ä–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é
                        if (lastHorizontalDirection[snakeIndex] === 'left') {
                            headImageToUse = snakeHeadLeftImage;
                        } else {
                            headImageToUse = snakeHeadImage;
                        }
                    }
                    // <<< –ò–ó–ú–ï–ù–ï–ù–û: –ú–∏–≥–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∞ –Ω–µ —Ñ–æ–Ω >>>
                    if (!isBlinking[snakeIndex] || (isBlinking[snakeIndex] && Math.floor(Date.now() / 250) % 2 === 0)) {
                        if (headImageToUse.complete) {
                            ctx.drawImage(headImageToUse, segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                        } else {
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                        }
                    }
                    // <<< –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô >>>
                } else {
                    ctx.fillStyle = '#00cc00';
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                }
                ctx.strokeStyle = 'rgba(0, 0, 0, 0)';
                ctx.strokeRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
            });
        });
        // <<< –ö–û–ù–ï–¶ –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø >>>
        // –†–∏—Å—É–µ–º –º–∞—Ä—à—Ä—É—Ç—ã
        snakeRoutes.forEach((route, snakeIndex) => {
            if (route.length > 0 && routeProgress[snakeIndex] < route.length) {
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 4;
                ctx.beginPath();
                const head = snakes[snakeIndex][0];
                ctx.moveTo(head.x * gridSize + gridSize/2, head.y * gridSize + gridSize/2);
                for (let i = routeProgress[snakeIndex]; i < route.length; i++) {
                    const point = route[i];
                    ctx.lineTo(point.x * gridSize + gridSize/2, point.y * gridSize + gridSize/2);
                }
                ctx.stroke();
            }
        });
        // –†–∏—Å—É–µ–º —Ü–µ–ª–µ–≤—ã–µ —Ç–æ—á–∫–∏
        targetPoints.forEach((point, index) => {
            if (point) {
                ctx.strokeStyle = 'yellow';
                ctx.strokeRect(point.x * gridSize, point.y * gridSize, gridSize, gridSize);
            }
        });
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        ctx.restore();
        // –†–∏—Å—É–µ–º —á–µ—Ä–Ω—ã–π –∫–æ–Ω—Ç—É—Ä –≤–æ–∫—Ä—É–≥ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.strokeRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
    }
    function gameStep() {
        update();
        drawGame();
    }
    function startGame() {
        if (gameRunning) {
            clearInterval(gameInterval);
            clearInterval(gameTimer);
            chargingTimers.forEach(t => t && clearInterval(t));
        }
        initGame();
        gameRunning = true;
        gameStarted = false;
        // –ò–≥—Ä–æ–≤—ã–µ —Ü–∏–∫–ª—ã –ù–ï –∑–∞–ø—É—Å–∫–∞–µ–º –∑–¥–µ—Å—å. –û–Ω–∏ –∑–∞–ø—É—Å—Ç—è—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏.
    }
    canvas.addEventListener('click', handleButtonClick);
    canvas.addEventListener('touchend', function(e) {
      e.preventDefault();
      handleButtonClick(e);
    });
    function handleButtonClick(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      let x, y;
      if (e.type === 'touchend') {
        x = (e.changedTouches[0].clientX - rect.left) * scaleX;
        y = (e.changedTouches[0].clientY - rect.top) * scaleY;
      } else {
        x = (e.clientX - rect.left) * scaleX;
        y = (e.clientY - rect.top) * scaleY;
      }
      const dxPOWER = x - POWER_CENTER_X;
      const dyPOWER = y - POWER_CENTER_Y;
      const distPOWER = Math.sqrt(dxPOWER * dxPOWER + dyPOWER * dyPOWER);
      const dxRST = x - RST_CENTER_X;
      const dyRST = y - RST_CENTER_Y;
      const distRST = Math.sqrt(dxRST * dxRST + dyRST * dyRST);
      const dxPRG = x - PRG_CENTER_X;
      const dyPRG = y - PRG_CENTER_Y;
      const distPRG = Math.sqrt(dxPRG * dxPRG + dyPRG * dyPRG);
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û POWER, –µ—Å–ª–∏ GODMODE —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω, –Ω–æ —ç–∫—Ä–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –µ—â–µ –ù–ï –∞–∫—Ç–∏–≤–µ–Ω.
      if (isGodmodeFinalized && !isGameOverScreenActive) {
        if (x >= POWER_X && x <= POWER_X + POWER_WIDTH && y >= POWER_Y && y <= POWER_Y + POWER_BUTTON_HEIGHT) {
          isPowerOn = !isPowerOn;
          if (!isPowerOn) {
            resetAll();
          } else {
            // lastTickTime = performance.now(); ‚Üê –£–î–ê–õ–ï–ù–û
            lastCounterTick = performance.now();
            lastChargeTick = performance.now();
            bootActive = true;
            bootCompleted = false;
            bootLineIndex = 0;
            bootCharIndex = 0;
            lastBootTick = performance.now();
            systemsActive = false;
            robotCharge = 100;
            prgPressCount = 0;
            godmodeActive = false;
            passwordMode = false;
            inputCode = [];
            errorMode = false;
            errorCompleted = false;
            godmodeSuccess = false;
            godmodeDisplayCompleted = false;
            isGodmodeFinalized = false;
          }
        }
        return;
      }
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û POWER, –µ—Å–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞.
      if (errorCompleted) {
        if (x >= POWER_X && x <= POWER_X + POWER_WIDTH && y >= POWER_Y && y <= POWER_Y + POWER_BUTTON_HEIGHT) {
          isPowerOn = !isPowerOn;
          if (!isPowerOn) {
            resetAll();
          } else {
            // lastTickTime = performance.now(); ‚Üê –£–î–ê–õ–ï–ù–û
            lastCounterTick = performance.now();
            lastChargeTick = performance.now();
            bootActive = true;
            bootCompleted = false;
            bootLineIndex = 0;
            bootCharIndex = 0;
            lastBootTick = performance.now();
            systemsActive = false;
            robotCharge = 100;
            prgPressCount = 0;
            godmodeActive = false;
            passwordMode = false;
            inputCode = [];
            errorMode = false;
            errorCompleted = false;
            godmodeSuccess = false;
            godmodeDisplayCompleted = false;
            isGodmodeFinalized = false;
          }
        }
        return;
      }
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –∫–æ–¥–∞
      if (godmodeActive && !passwordMode && !errorMode && !godmodeSuccess) {
        handleKeypadClick(x, y);
        return;
      }
      // –û–±—ã—á–Ω–∞—è –ª–æ–≥–∏–∫–∞ –∫–Ω–æ–ø–æ–∫
      if (x >= POWER_X && x <= POWER_X + POWER_WIDTH && y >= POWER_Y && y <= POWER_Y + POWER_BUTTON_HEIGHT) {
        isPowerOn = !isPowerOn;
        if (!isPowerOn) {
          resetAll();
          // –û–ë–ù–£–õ–Ø–ï–ú localStorage –ü–†–ò –í–´–ö–õ–Æ–ß–ï–ù–ò–ò
          localStorage.removeItem('robotGameHighScores');
        } else {
          // lastTickTime = performance.now(); ‚Üê –£–î–ê–õ–ï–ù–û
          lastCounterTick = performance.now();
          lastChargeTick = performance.now();
          bootActive = true;
          bootCompleted = false;
          bootLineIndex = 0;
          bootCharIndex = 0;
          lastBootTick = performance.now();
          systemsActive = false;
          robotCharge = 100;
          prgPressCount = 0;
          godmodeActive = false;
          passwordMode = false;
          inputCode = [];
          errorMode = false;
          errorCompleted = false;
          godmodeSuccess = false;
          godmodeDisplayCompleted = false;
          isGodmodeFinalized = false;
          isGameOverScreenActive = false;
          startGame(); // ‚Üê –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä—É –ø—Ä–∏ –≤–∫–ª—é—á–µ–Ω–∏–∏ –ø–∏—Ç–∞–Ω–∏—è
        }
      } else if (distRST <= SMALL_BUTTON_SIZE / 2 && isPowerOn && !godmodeActive && !isGodmodeFinalized && !errorCompleted) {
        // <<< –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ê –ê–ù–ò–ú–ê–¶–ò–Ø –ù–ê–ñ–ê–¢–ò–Ø >>>
        isRSTPressed = true;
        setTimeout(function() { isRSTPressed = false; }, 200);
        if (isGameOverScreenActive) {
            // –ï—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω —ç–∫—Ä–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä—É
            isGameOverScreenActive = false;
            resetAll();
            startGame();
        } else {
            // –û–±—ã—á–Ω—ã–π —Å–±—Ä–æ—Å
            initGame();
            gameStarted = false;
            // –°–ë–†–ê–°–´–í–ê–ï–ú –¢–ê–ô–ú–ï–† –°–¢–†–û–ì–û –ù–ê 3:00
            // timerSeconds = 180; ‚Üê –£–î–ê–õ–ï–ù–û
            timeLeft = 180;
            // –û–ë–ù–£–õ–Ø–ï–ú localStorage –ü–†–ò –°–ë–†–û–°–ï
            localStorage.removeItem('robotGameHighScores');
        }
      } else if (distPRG <= SMALL_BUTTON_SIZE / 2 && isPowerOn && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
        // <<< –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ê –ê–ù–ò–ú–ê–¶–ò–Ø –ù–ê–ñ–ê–¢–ò–Ø >>>
        isPRGPressed = true;
        setTimeout(function() { isPRGPressed = false; }, 200);
        prgPressCount++;
        if (prgPressCount >= 10) {
          activateGodmode();
        }
      } else {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤ –ø–æ –∏–≥—Ä–æ–≤–æ–º—É –ø–æ–ª—é
        if (isPowerOn && systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
          const clickX = Math.floor((x - DISPLAY_X) / gridSize);
          const clickY = Math.floor((y - DISPLAY_Y) / gridSize);
          if (clickX >= 0 && clickX < gridWidth && clickY >= 0 && clickY < gridHeight) {
            if (!gameStarted) {
              for (let i = 0; i < snakes.length; i++) {
                const head = snakes[i][0];
                if (head.x === clickX && head.y === clickY) {
                  selectedSnakeIndex = i;
                  activeRobotIndex = i;
                  const head = snakes[i][0];
                  const targetKey = `${clickX},${clickY}`;
                  if (reservedTargets[targetKey] !== undefined && reservedTargets[targetKey] !== i) {
                    return;
                  }
                  if (targetPoints[i]) {
                    const oldKey = `${targetPoints[i].x},${targetPoints[i].y}`;
                    if (reservedTargets[oldKey] === i) delete reservedTargets[oldKey];
                  }
                  snakeRoutes[i] = buildRoute(head.x, head.y, clickX, clickY, i);
                  routeProgress[i] = 0;
                  targetPoints[i] = {x: clickX, y: clickY};
                  reservedTargets[targetKey] = i;
                  snakeRouteTimestamps[i] = Date.now();
                  isBlinking[i] = false;
                  gameStarted = true;
                  return;
                }
              }
              return;
            }
            for (let i = 0; i < snakes.length; i++) {
              const head = snakes[i][0];
              if (head.x === clickX && head.y === clickY) {
                selectedSnakeIndex = i;
                activeRobotIndex = i;
                isBlinking = [false, false, false];
                isBlinking[i] = true;
                return;
              }
            }
            if (selectedSnakeIndex !== -1) {
              if (isObstacle(clickX, clickY)) return;
              const stationIndex = isChargingStation(clickX, clickY);
              if (stationIndex !== -1) {
                if (hasCargo[selectedSnakeIndex]) return;
                const head = snakes[selectedSnakeIndex][0];
                const targetKey = `${clickX},${clickY}`;
                if (reservedTargets[targetKey] !== undefined && reservedTargets[targetKey] !== selectedSnakeIndex) {
                  return;
                }
                if (targetPoints[selectedSnakeIndex]) {
                  const oldKey = `${targetPoints[selectedSnakeIndex].x},${targetPoints[selectedSnakeIndex].y}`;
                  if (reservedTargets[oldKey] === selectedSnakeIndex) delete reservedTargets[oldKey];
                }
                snakeRoutes[selectedSnakeIndex] = buildRoute(head.x, head.y, clickX, clickY, selectedSnakeIndex);
                routeProgress[selectedSnakeIndex] = 0;
                targetPoints[selectedSnakeIndex] = {x: clickX, y: clickY};
                reservedTargets[targetKey] = selectedSnakeIndex;
                snakeRouteTimestamps[selectedSnakeIndex] = Date.now();
                isBlinking[selectedSnakeIndex] = false;
              } else {
                let isFood = food.some(f => f.x === clickX && f.y === clickY);
                if (isFood && hasCargo[selectedSnakeIndex]) return;
                const head = snakes[selectedSnakeIndex][0];
                const targetKey = `${clickX},${clickY}`;
                if (reservedTargets[targetKey] !== undefined && reservedTargets[targetKey] !== selectedSnakeIndex) {
                  return;
                }
                if (targetPoints[selectedSnakeIndex]) {
                  const oldKey = `${targetPoints[selectedSnakeIndex].x},${targetPoints[selectedSnakeIndex].y}`;
                  if (reservedTargets[oldKey] === selectedSnakeIndex) delete reservedTargets[oldKey];
                }
                snakeRoutes[selectedSnakeIndex] = buildRoute(head.x, head.y, clickX, clickY, selectedSnakeIndex);
                routeProgress[selectedSnakeIndex] = 0;
                targetPoints[selectedSnakeIndex] = {x: clickX, y: clickY};
                reservedTargets[targetKey] = selectedSnakeIndex;
                snakeRouteTimestamps[selectedSnakeIndex] = Date.now();
                isBlinking[selectedSnakeIndex] = false;
              }
            }
          }
        } else if (isGameOverScreenActive) {
          // –û–ë–†–ê–ë–û–¢–ö–ê –ù–ê–ñ–ê–¢–ò–Ø –ù–ê –ö–ù–û–ü–ö–£ SAVE
          const saveButtonX = DISPLAY_X + 100;
          const saveButtonY = DISPLAY_Y + 300;
          const saveButtonWidth = 200;
          const saveButtonHeight = 60;
          if (x >= saveButtonX && x <= saveButtonX + saveButtonWidth &&
              y >= saveButtonY && y <= saveButtonY + saveButtonHeight) {
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—á–∫–∏ –≤ localStorage
            let highScores = JSON.parse(localStorage.getItem('robotGameHighScores') || '[]');
            highScores.push({
                score: counterValue,
                timestamp: new Date().toISOString()
            });
            localStorage.setItem('robotGameHighScores', JSON.stringify(highScores));
            alert('–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω!');
            // === –û–¢–ü–†–ê–í–ö–ê –û–ß–ö–û–í –í TELEGRAM –ë–û–¢ ===
            if (window.Telegram && window.Telegram.WebApp) {
              const resultData = {
                action: "save_score",
                score: counterValue,
                timestamp: new Date().toISOString()
              };
              window.Telegram.WebApp.sendData(JSON.stringify(resultData));
              alert('‚úÖ –í–∞—à–∏ –æ—á–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!');
            } else {
              alert('‚ö†Ô∏è –ò–≥—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞ –Ω–µ –≤ Telegram. –û—á–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –ª–æ–∫–∞–ª—å–Ω–æ.');
            }
            // –ü–ï–†–ï–ó–ê–ü–£–°–ö–ê–ï–ú –ò–ì–†–£ –ü–û–°–õ–ï –°–û–•–†–ê–ù–ï–ù–ò–Ø
            isGameOverScreenActive = false;
            resetAll();
            isPowerOn = true;
            // lastTickTime = performance.now(); ‚Üê –£–î–ê–õ–ï–ù–û
            lastCounterTick = performance.now();
            lastChargeTick = performance.now();
            bootActive = true;
            bootCompleted = false;
            bootLineIndex = 0;
            bootCharIndex = 0;
            lastBootTick = performance.now();
            systemsActive = false;
            robotCharge = 100;
            prgPressCount = 0;
            godmodeActive = false;
            passwordMode = false;
            inputCode = [];
            errorMode = false;
            errorCompleted = false;
            godmodeSuccess = false;
            godmodeDisplayCompleted = false;
            isGodmodeFinalized = false;
            startGame();
          }
        }
      }
    }
    function handleKeypadClick(x, y) {
      if (passwordMode || errorMode || godmodeSuccess) return;
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
          const digit = row * 3 + col + 1;
          const keyX = KEYPAD_START_X + col * (KEYPAD_SIZE + KEYPAD_GAP);
          const keyY = KEYPAD_START_Y + row * (KEYPAD_SIZE + KEYPAD_GAP);
          if (x >= keyX && x <= keyX + KEYPAD_SIZE &&
              y >= keyY && y <= keyY + KEYPAD_SIZE) {
            if (inputCode.length < 3) {
              inputCode.push(digit);
            }
            pressedKey = digit;
            setTimeout(() => pressedKey = null, 100);
            return;
          }
        }
      }
      const zeroX = KEYPAD_START_X + 1 * (KEYPAD_SIZE + KEYPAD_GAP);
      const zeroY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      if (x >= zeroX && x <= zeroX + KEYPAD_SIZE &&
          y >= zeroY && y <= zeroY + KEYPAD_SIZE) {
        if (inputCode.length < 3) {
          inputCode.push(0);
        }
        pressedKey = 0;
        setTimeout(() => pressedKey = null, 100);
        return;
      }
      const delX = KEYPAD_START_X + 0 * (KEYPAD_SIZE + KEYPAD_GAP);
      const delY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      if (x >= delX && x <= delX + KEYPAD_SIZE &&
          y >= delY && y <= delY + KEYPAD_SIZE) {
        if (inputCode.length > 0) {
          inputCode.pop();
        }
        pressedKey = 'DEL';
        setTimeout(() => pressedKey = null, 100);
        return;
      }
      const starX = KEYPAD_START_X + 2 * (KEYPAD_SIZE + KEYPAD_GAP);
      const starY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      if (x >= starX && x <= starX + KEYPAD_SIZE &&
          y >= starY && y <= starY + KEYPAD_SIZE) {
        checkPassword();
        pressedKey = '*';
        setTimeout(() => pressedKey = null, 100);
        return;
      }
    }
    function activateGodmode() {
      godmodeActive = true;
      passwordMode = true;
      inputCode = [];
      passwordLineIndex = 0;
      passwordCharIndex = 0;
      lastPasswordTick = performance.now();
      systemsActive = false;
      errorMode = false;
      errorCompleted = false;
      godmodeSuccess = false;
      godmodeDisplayCompleted = false;
      isGodmodeFinalized = false;
    }
    function checkPassword() {
      passwordMode = false;
      if (inputCode[0] === 6 && inputCode[1] === 6 && inputCode[2] === 6) {
        counterValue = 999;
        godmodeSuccess = true;
        godmodeDisplayLineIndex = 0;
        godmodeDisplayCharIndex = 0;
        lastGodmodeDisplayTick = performance.now();
        godmodeDisplayCompleted = false;
        // –ü–û–ö–ê–ó–´–í–ê–ï–ú –≠–ö–†–ê–ù –ó–ê–í–ï–†–®–ï–ù–ò–Ø –°–†–ê–ó–£
        isGameOverScreenActive = true;
        systemsActive = false;
      } else {
        // <<< –ò–ó–ú–ï–ù–ï–ù–û: –¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º —Ä–µ–∂–∏–º –æ—à–∏–±–∫–∏, –ù–ï –≤—ã–∫–ª—é—á–∞–µ–º –ø–∏—Ç–∞–Ω–∏–µ >>>
        errorMode = true;
        errorLineIndex = 0;
        errorCharIndex = 0;
        lastErrorTick = performance.now();
        errorCompleted = false;
        // <<< –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô >>>
      }
      inputCode = [];
    }
    function resetAll() {
      // timerSeconds = 180; ‚Üê –£–î–ê–õ–ï–ù–û
      counterValue = 0;
      animatingDigit = null;
      isRSTPressed = false;
      isPRGPressed = false;
      robotCharge = 100;
      bootActive = false;
      bootCompleted = false;
      bootLineIndex = 0;
      bootCharIndex = 0;
      systemsActive = false;
      prgPressCount = 0;
      godmodeActive = false;
      passwordMode = false;
      inputCode = [];
      errorMode = false;
      errorCompleted = false;
      godmodeSuccess = false;
      godmodeDisplayCompleted = false;
      isGodmodeFinalized = false;
      isGameOverScreenActive = false;
      // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∏–≥—Ä—É
      if (gameRunning) {
        if (gameInterval) clearInterval(gameInterval);
        if (gameTimer) clearInterval(gameTimer);
        chargingTimers.forEach(t => t && clearInterval(t));
        gameRunning = false;
        gameStarted = false;
      }
    }
    // <<< –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –û–¢–†–ò–°–û–í–ö–ò –ö–ù–û–ü–û–ö –° –ö–†–£–¢–´–ú 3D –ò –¢–ï–ù–Ø–ú–ò >>>
    function drawModernButton3D(x, y, width, height, isPressed, baseColor, pressedColor, text, isActive) {
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–≤–µ—Ç –∫–Ω–æ–ø–∫–∏
        let buttonColor = isPressed && isActive ? pressedColor : baseColor;
        let textColor = '#000'; // –ß–µ—Ä–Ω—ã–π —Ç–µ–∫—Å—Ç
        // –û—á–∏—â–∞–µ–º —Ç–µ–Ω–∏
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        // –†–∏—Å—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –∫–Ω–æ–ø–∫–∏
        ctx.beginPath();
        roundRect(ctx, x, y, width, height, 8); // –°–∫—Ä—É–≥–ª–µ–Ω–∏–µ 8px
        ctx.fillStyle = buttonColor;
        ctx.fill();
        // –†–∏—Å—É–µ–º –≤–µ—Ä—Ö–Ω—é—é —Ç–µ–Ω—å (—Å–≤–µ—Ç–ª—ã–π –±–ª–∏–∫) –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—ã—Å—Ç—É–ø–∞
        if (!isPressed) {
            ctx.beginPath();
            ctx.moveTo(x + 2, y + 2);
            ctx.lineTo(x + width - 2, y + 2);
            ctx.quadraticCurveTo(x + width, y, x + width - 2, y + 2);
            ctx.lineTo(x + 2, y + 2);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fill();
        }
        // –†–∏—Å—É–µ–º –Ω–∏–∂–Ω—é—é —Ç–µ–Ω—å (—Ç–µ–º–Ω–∞—è –ø–æ–ª–æ—Å–∞) –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—ã—Å—Ç—É–ø–∞
        if (!isPressed) {
            ctx.beginPath();
            ctx.moveTo(x + 2, y + height - 2);
            ctx.lineTo(x + width - 2, y + height - 2);
            ctx.quadraticCurveTo(x + width, y + height, x + width - 2, y + height - 2);
            ctx.lineTo(x + 2, y + height - 2);
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fill();
        }
        // –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();
        // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
        ctx.fillStyle = textColor;
        if (width === POWER_WIDTH) {
            // –î–ª—è POWER —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —à—Ä–∏—Ñ—Ç
            ctx.font = 'bold 18px "Courier New", monospace';
        } else {
            ctx.font = 'bold 14px "Courier New", monospace';
        }
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, x + width / 2, y + height / 2);
    }
    // <<< –ü–û–õ–ù–û–°–¢–¨–Æ –ü–ï–†–ï–î–ï–õ–ê–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –î–õ–Ø POWER BUTTON >>>
    function drawPowerButton() {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—Ç–∏–ª—è
        const originalFillStyle = ctx.fillStyle;
        const originalStrokeStyle = ctx.strokeStyle;
        const originalLineWidth = ctx.lineWidth;
        const originalShadowColor = ctx.shadowColor;
        const originalShadowBlur = ctx.shadowBlur;
        const originalShadowOffsetX = ctx.shadowOffsetX;
        const originalShadowOffsetY = ctx.shadowOffsetY;
        const originalLineCap = ctx.lineCap;
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –≤ –∫–∞–∫–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∫–Ω–æ–ø–∫–∞
        const isPressedState = isPowerOn; // –ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞, —Ç–æ –≤–¥–∞–≤–ª–µ–Ω–∞
        // –†–∏—Å—É–µ–º –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –∫–Ω–æ–ø–∫–∏
        ctx.beginPath();
        roundRect(ctx, POWER_X, POWER_Y, POWER_WIDTH, POWER_BUTTON_HEIGHT, 8);
        ctx.closePath();
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç
        const gradient = ctx.createLinearGradient(POWER_X, POWER_Y, POWER_X + POWER_WIDTH, POWER_Y + POWER_BUTTON_HEIGHT);
        gradient.addColorStop(0, isPressedState ? '#dd0000' : '#ff3030');
        gradient.addColorStop(0.5, isPressedState ? '#cc0000' : '#ff0000');
        gradient.addColorStop(1, isPressedState ? '#bb0000' : '#cc0000');
        ctx.fillStyle = gradient;
        ctx.fill();
        // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–Ω–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è
        if (!isPressedState) {
            // –°–æ—Å—Ç–æ—è–Ω–∏–µ "–Ω–µ –Ω–∞–∂–∞—Ç–∞" - —Å–∏–ª—å–Ω–∞—è —Ç–µ–Ω—å —Å–Ω–∏–∑—É
            ctx.shadowColor = 'rgba(153, 0, 0, 0.8)'; // –¢–µ–º–Ω–æ-–∫—Ä–∞—Å–Ω–∞—è —Ç–µ–Ω—å
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 8;
            ctx.stroke(); // –†–∏—Å—É–µ–º —Ç–µ–Ω—å
            // –í–µ—Ä—Ö–Ω–∏–π —Å–≤–µ—Ç–ª—ã–π –±–ª–∏–∫
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(POWER_X + 2, POWER_Y + 2, POWER_WIDTH - 4, 4);
            // –ù–∏–∂–Ω—è—è —Ç–µ–º–Ω–∞—è –ø–æ–ª—É—Ç–µ–Ω—å
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(POWER_X + 2, POWER_Y + POWER_BUTTON_HEIGHT - 6, POWER_WIDTH - 4, 4);
        } else {
            // –°–æ—Å—Ç–æ—è–Ω–∏–µ "–Ω–∞–∂–∞—Ç–∞" - —Å–ª–∞–±–∞—è —Ç–µ–Ω—å —Å–Ω–∏–∑—É
            ctx.shadowColor = 'rgba(153, 0, 0, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.stroke(); // –†–∏—Å—É–µ–º —Ç–µ–Ω—å
        }
        // –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä –∫–Ω–æ–ø–∫–∏
        ctx.strokeStyle = '#990000';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.stroke();
        // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 18px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('POWER', POWER_X + POWER_WIDTH / 2, POWER_Y + POWER_BUTTON_HEIGHT / 2);
        // –ê–Ω–∏–º–∞—Ü–∏—è –ø—É–ª—å—Å–∞—Ü–∏–∏ –¥–ª—è –≤—ã–∫–ª—é—á–µ–Ω–Ω–æ–π –∫–Ω–æ–ø–∫–∏
        if (!isPowerOn) {
            const brightness = 0.8 + Math.sin(powerOffBlink * 1.5) * 0.2;
            const r = Math.floor(150 + brightness * 50);
            const g = Math.floor(30 + brightness * 20);
            const b = Math.floor(30 + brightness * 20);
            // –ú–æ–∂–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å —ç—Ç–æ—Ç —Ü–≤–µ—Ç –∫ –≥—Ä–∞–¥–∏–µ–Ω—Ç—É, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ, –Ω–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –æ—Å—Ç–∞–≤–∏–º –∫–∞–∫ –µ—Å—Ç—å.
        }
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ —Å—Ç–∏–ª–∏
        ctx.fillStyle = originalFillStyle;
        ctx.strokeStyle = originalStrokeStyle;
        ctx.lineWidth = originalLineWidth;
        ctx.shadowColor = originalShadowColor;
        ctx.shadowBlur = originalShadowBlur;
        ctx.shadowOffsetX = originalShadowOffsetX;
        ctx.shadowOffsetY = originalShadowOffsetY;
        ctx.lineCap = originalLineCap;
    }
    // <<< –ü–û–õ–ù–û–°–¢–¨–Æ –ü–ï–†–ï–î–ï–õ–ê–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –î–õ–Ø RESET BUTTON (–∫–æ–ø–∏—è POWER) >>>
    function drawRSTButton() {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—Ç–∏–ª—è
        const originalFillStyle = ctx.fillStyle;
        const originalStrokeStyle = ctx.strokeStyle;
        const originalLineWidth = ctx.lineWidth;
        const originalShadowColor = ctx.shadowColor;
        const originalShadowBlur = ctx.shadowBlur;
        const originalShadowOffsetX = ctx.shadowOffsetX;
        const originalShadowOffsetY = ctx.shadowOffsetY;
        const originalLineCap = ctx.lineCap;
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –≤ –∫–∞–∫–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∫–Ω–æ–ø–∫–∞
        const isPressedState = isRSTPressed; // –ï—Å–ª–∏ –Ω–∞–∂–∞—Ç–∞, —Ç–æ –≤–¥–∞–≤–ª–µ–Ω–∞
        // <<< –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ systemsActive –∏ !isGameOverScreenActive >>>
        const isActive = isPowerOn && systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive;
        // –†–∏—Å—É–µ–º –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –∫–Ω–æ–ø–∫–∏
        ctx.beginPath();
        roundRect(ctx, RST_X, RST_Y, SMALL_BUTTON_SIZE, SMALL_BUTTON_SIZE, 8);
        ctx.closePath();
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç
        const gradient = ctx.createLinearGradient(RST_X, RST_Y, RST_X + SMALL_BUTTON_SIZE, RST_Y + SMALL_BUTTON_SIZE);
        if (isActive) {
            gradient.addColorStop(0, isPressedState ? '#dd0000' : '#ff3030');
            gradient.addColorStop(0.5, isPressedState ? '#cc0000' : '#ff0000');
            gradient.addColorStop(1, isPressedState ? '#bb0000' : '#cc0000');
        } else {
            gradient.addColorStop(0, '#600000');
            gradient.addColorStop(0.5, '#500000');
            gradient.addColorStop(1, '#400000');
        }
        ctx.fillStyle = gradient;
        ctx.fill();
        // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–Ω–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è
        if (!isPressedState && isActive) {
            // –°–æ—Å—Ç–æ—è–Ω–∏–µ "–Ω–µ –Ω–∞–∂–∞—Ç–∞" - —Å–∏–ª—å–Ω–∞—è —Ç–µ–Ω—å —Å–Ω–∏–∑—É
            ctx.shadowColor = 'rgba(153, 0, 0, 0.8)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 8;
            ctx.stroke(); // –†–∏—Å—É–µ–º —Ç–µ–Ω—å
            // –í–µ—Ä—Ö–Ω–∏–π —Å–≤–µ—Ç–ª—ã–π –±–ª–∏–∫
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(RST_X + 2, RST_Y + 2, SMALL_BUTTON_SIZE - 4, 4);
            // –ù–∏–∂–Ω—è—è —Ç–µ–º–Ω–∞—è –ø–æ–ª—É—Ç–µ–Ω—å
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(RST_X + 2, RST_Y + SMALL_BUTTON_SIZE - 6, SMALL_BUTTON_SIZE - 4, 4);
        } else if (isActive) {
            // –°–æ—Å—Ç–æ—è–Ω–∏–µ "–Ω–∞–∂–∞—Ç–∞" - —Å–ª–∞–±–∞—è —Ç–µ–Ω—å —Å–Ω–∏–∑—É
            ctx.shadowColor = 'rgba(153, 0, 0, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.stroke(); // –†–∏—Å—É–µ–º —Ç–µ–Ω—å
        }
        // –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä –∫–Ω–æ–ø–∫–∏
        ctx.strokeStyle = '#990000';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.stroke();
        // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('RESET', RST_X + SMALL_BUTTON_SIZE / 2, RST_Y + SMALL_BUTTON_SIZE / 2);
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ —Å—Ç–∏–ª–∏
        ctx.fillStyle = originalFillStyle;
        ctx.strokeStyle = originalStrokeStyle;
        ctx.lineWidth = originalLineWidth;
        ctx.shadowColor = originalShadowColor;
        ctx.shadowBlur = originalShadowBlur;
        ctx.shadowOffsetX = originalShadowOffsetX;
        ctx.shadowOffsetY = originalShadowOffsetY;
        ctx.lineCap = originalLineCap;
    }
    // <<< –ü–û–õ–ù–û–°–¢–¨–Æ –ü–ï–†–ï–î–ï–õ–ê–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –î–õ–Ø PROG BUTTON (–∫–æ–ø–∏—è POWER, –æ—Ä–∞–Ω–∂–µ–≤–∞—è) >>>
    function drawPRGButton() {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—Ç–∏–ª—è
        const originalFillStyle = ctx.fillStyle;
        const originalStrokeStyle = ctx.strokeStyle;
        const originalLineWidth = ctx.lineWidth;
        const originalShadowColor = ctx.shadowColor;
        const originalShadowBlur = ctx.shadowBlur;
        const originalShadowOffsetX = ctx.shadowOffsetX;
        const originalShadowOffsetY = ctx.shadowOffsetY;
        const originalLineCap = ctx.lineCap;
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –≤ –∫–∞–∫–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∫–Ω–æ–ø–∫–∞
        const isPressedState = isPRGPressed; // –ï—Å–ª–∏ –Ω–∞–∂–∞—Ç–∞, —Ç–æ –≤–¥–∞–≤–ª–µ–Ω–∞
        // <<< –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ !isGameOverScreenActive >>>
        const isActive = isPowerOn && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive;
        // –†–∏—Å—É–µ–º –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –∫–Ω–æ–ø–∫–∏
        ctx.beginPath();
        roundRect(ctx, PRG_X, PRG_Y, SMALL_BUTTON_SIZE, SMALL_BUTTON_SIZE, 8);
        ctx.closePath();
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç
        const gradient = ctx.createLinearGradient(PRG_X, PRG_Y, PRG_X + SMALL_BUTTON_SIZE, PRG_Y + SMALL_BUTTON_SIZE);
        if (isActive) {
            gradient.addColorStop(0, isPressedState ? '#e65c00' : '#ff7c00'); // –¢–µ–º–Ω–æ-–æ—Ä–∞–Ω–∂–µ–≤—ã–π / –Ø—Ä–∫–æ-–æ—Ä–∞–Ω–∂–µ–≤—ã–π
            gradient.addColorStop(0.5, isPressedState ? '#cc5500' : '#ff6600');
            gradient.addColorStop(1, isPressedState ? '#b34d00' : '#ff5500');
        } else {
            gradient.addColorStop(0, '#600000');
            gradient.addColorStop(0.5, '#500000');
            gradient.addColorStop(1, '#400000');
        }
        ctx.fillStyle = gradient;
        ctx.fill();
        // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–Ω–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è
        if (!isPressedState && isActive) {
            // –°–æ—Å—Ç–æ—è–Ω–∏–µ "–Ω–µ –Ω–∞–∂–∞—Ç–∞" - —Å–∏–ª—å–Ω–∞—è —Ç–µ–Ω—å —Å–Ω–∏–∑—É
            ctx.shadowColor = 'rgba(153, 51, 0, 0.8)'; // –¢–µ–º–Ω–æ-–æ—Ä–∞–Ω–∂–µ–≤–∞—è —Ç–µ–Ω—å
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 8;
            ctx.stroke(); // –†–∏—Å—É–µ–º —Ç–µ–Ω—å
            // –í–µ—Ä—Ö–Ω–∏–π —Å–≤–µ—Ç–ª—ã–π –±–ª–∏–∫
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(PRG_X + 2, PRG_Y + 2, SMALL_BUTTON_SIZE - 4, 4);
            // –ù–∏–∂–Ω—è—è —Ç–µ–º–Ω–∞—è –ø–æ–ª—É—Ç–µ–Ω—å
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(PRG_X + 2, PRG_Y + SMALL_BUTTON_SIZE - 6, SMALL_BUTTON_SIZE - 4, 4);
        } else if (isActive) {
            // –°–æ—Å—Ç–æ—è–Ω–∏–µ "–Ω–∞–∂–∞—Ç–∞" - —Å–ª–∞–±–∞—è —Ç–µ–Ω—å —Å–Ω–∏–∑—É
            ctx.shadowColor = 'rgba(153, 51, 0, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.stroke(); // –†–∏—Å—É–µ–º —Ç–µ–Ω—å
        }
        // –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä –∫–Ω–æ–ø–∫–∏
        ctx.strokeStyle = '#993300'; // –¢–µ–º–Ω–æ-–æ—Ä–∞–Ω–∂–µ–≤—ã–π –∫–æ–Ω—Ç—É—Ä
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.stroke();
        // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('PROG', PRG_X + SMALL_BUTTON_SIZE / 2, PRG_Y + SMALL_BUTTON_SIZE / 2);
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ —Å—Ç–∏–ª–∏
        ctx.fillStyle = originalFillStyle;
        ctx.strokeStyle = originalStrokeStyle;
        ctx.lineWidth = originalLineWidth;
        ctx.shadowColor = originalShadowColor;
        ctx.shadowBlur = originalShadowBlur;
        ctx.shadowOffsetX = originalShadowOffsetX;
        ctx.shadowOffsetY = originalShadowOffsetY;
        ctx.lineCap = originalLineCap;
    }
    // <<< –£–î–ê–õ–ï–ù–´ –§–£–ù–ö–¶–ò–ò –õ–ê–ú–ü–û–ß–ï–ö >>>
    // –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å lampPhases, lampSpeeds, drawLamps, drawLamp ‚Äî –£–î–ê–õ–ï–ï–ù–´.
    // <<< –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø drawVoltmeter >>>
    function drawVoltmeter() {
        ctx.fillStyle = '#0a0a0a';
        roundRect(ctx, VOLTMETER_X, VOLTMETER_Y, VOLTMETER_WIDTH, VOLTMETER_HEIGHT, 6);
        ctx.fill();
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        ctx.stroke();
        // –í–°–ï –¢–ï–ö–°–¢–´ –ò–ó–ù–ê–ß–ê–õ–¨–ù–û –°–ï–†–´–ï, –ë–ï–õ–´–ï –¢–û–õ–¨–ö–û –ü–†–ò –í–´–ë–û–†–ï –†–û–ë–û–¢–ê
        let textColor = (systemsActive && activeRobotIndex !== -1) ? '#ffffff' : '#666';
        ctx.fillStyle = textColor;
        ctx.font = '12px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('0', VOLTMETER_X + 15, VOLTMETER_Y + VOLTMETER_HEIGHT - 8);
        ctx.fillText('100', VOLTMETER_X + VOLTMETER_WIDTH - 20, VOLTMETER_Y + VOLTMETER_HEIGHT - 8);
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—É—â–∏–π –∑–∞—Ä—è–¥
        let currentCharge = systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted ? (activeRobotIndex !== -1 ? snakeCharges[activeRobotIndex] : robotCharge) : robotCharge;
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–≤–µ—Ç –¥–ª—è 'ENERGY'
        let energyColor = textColor; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∏–≥–∞–Ω–∏–µ –¢–û–õ–¨–ö–û –ø—Ä–∏ —É—Å–ª–æ–≤–∏–∏ –Ω–∏–∑–∫–æ–≥–æ –∑–∞—Ä—è–¥–∞
        if (currentCharge < 50 && isPowerOn && systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && activeRobotIndex !== -1) {
            const blinkEnergy = Math.floor(performance.now() / 1000) % 2; // –ß–∞—Å—Ç–æ—Ç–∞: 1 —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
            if (blinkEnergy === 0) {
                energyColor = '#666'; // –°–∫—Ä—ã—Ç—ã–π
            } else {
                energyColor = '#ffffff'; // –ë–µ–ª—ã–π
            }
        }
        ctx.fillStyle = energyColor;
        ctx.font = 'bold 16px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ENERGY', VOLTMETER_X + VOLTMETER_WIDTH / 2, VOLTMETER_Y + VOLTMETER_HEIGHT / 2 - 18);
        // –†–∏—Å—É–µ–º —Å—Ç—Ä–µ–ª–∫—É
        const pivotX = VOLTMETER_X + VOLTMETER_WIDTH / 2;
        const pivotY = VOLTMETER_Y + VOLTMETER_HEIGHT - 5;
        const angle = -Math.PI * (1 - (currentCharge / 100));
        const needleLength = 30;
        const tipX = pivotX + Math.cos(angle) * needleLength;
        const tipY = pivotY + Math.sin(angle) * needleLength;
        ctx.beginPath();
        ctx.moveTo(pivotX, pivotY);
        ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = '#ff3030';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(pivotX, pivotY, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#ff3030';
        ctx.fill();
    }
    // <<< –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø drawLCDDisplay >>>
    function drawLCDDisplay() {
        ctx.fillStyle = '#0a0a0a';
        roundRect(ctx, LCD_X, LCD_Y, LCD_WIDTH, LCD_HEIGHT, 6);
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();
        let topText = "-----";
        let bottomText = "-----";
        if (systemsActive && isPowerOn && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
            if (activeRobotIndex !== -1) {
                topText = `UNIT${activeRobotIndex + 1}`;
                bottomText = hasCargo[activeRobotIndex] ? "LOAD" : "EMPTY";
            }
        }
        const charWidth = LCD_WIDTH / 5;
        const topY = LCD_Y + 22;
        const bottomY = LCD_Y + 45;
        ctx.fillStyle = '#666';
        ctx.font = 'bold 14px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // –ù–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –º–∏–≥–∞–Ω–∏—è –¥–ª—è LCD
        const shouldBlinkLCD = (systemsActive && activeRobotIndex !== -1);
        const blinkLCD = shouldBlinkLCD ? (Math.floor(performance.now() / 1000) % 2) : 0; // –ß–∞—Å—Ç–æ—Ç–∞: 1 —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
        // –†–∏—Å—É–µ–º –≤–µ—Ä—Ö–Ω—é—é —Å—Ç—Ä–æ–∫—É (UNITX)
        for (let i = 0; i < 5; i++) {
            if (i < topText.length && topText !== "-----") {
                if (i < 4) { // –°–∏–º–≤–æ–ª—ã 'U', 'N', 'I', 'T'
                    // –í—Å–µ–≥–¥–∞ –±–µ–ª—ã–µ, –Ω–µ –º–∏–≥–∞—é—Ç
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(topText[i], LCD_X + charWidth * (i + 0.5), topY);
                } else { // –¶–∏—Ñ—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, '1', '2', '3')
                    // –ú–∏–≥–∞–µ—Ç —Å —á–∞—Å—Ç–æ—Ç–æ–π 1 –ì—Ü
                    if (blinkLCD === 0) {
                        ctx.fillStyle = '#ffffff'; // –ë–µ–ª—ã–π
                    } else {
                        ctx.fillStyle = '#666'; // –°–∫—Ä—ã—Ç—ã–π
                    }
                    ctx.fillText(topText[i], LCD_X + charWidth * (i + 0.5), topY);
                }
                ctx.fillStyle = '#666';
            } else {
                ctx.fillText('-', LCD_X + charWidth * (i + 0.5), topY);
            }
        }
        // –†–∏—Å—É–µ–º –Ω–∏–∂–Ω—é—é —Å—Ç—Ä–æ–∫—É (LOAD/EMPTY)
        for (let i = 0; i < 5; i++) {
            if (i < bottomText.length && bottomText !== "-----") {
                if (bottomText === "LOAD" && i === 4) {
                    // –î–ª—è "LOAD" –ø—è—Ç–∞—è –ø–æ–∑–∏—Ü–∏—è –≤—Å–µ–≥–¥–∞ —Å–µ—Ä–∞—è –∏ –Ω–µ –º–∏–≥–∞–µ—Ç
                    ctx.fillStyle = '#666';
                    ctx.fillText('-', LCD_X + charWidth * (i + 0.5), bottomY);
                } else {
                    // –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –º–∏–≥–∞—é—Ç —Å —á–∞—Å—Ç–æ—Ç–æ–π 1 –ì—Ü
                    if (blinkLCD === 0) {
                        ctx.fillStyle = '#ffffff'; // –ë–µ–ª—ã–π
                    } else {
                        ctx.fillStyle = '#666'; // –°–∫—Ä—ã—Ç—ã–π
                    }
                    ctx.fillText(bottomText[i], LCD_X + charWidth * (i + 0.5), bottomY);
                }
                ctx.fillStyle = '#666';
            } else {
                ctx.fillText('-', LCD_X + charWidth * (i + 0.5), bottomY);
            }
        }
    }
    function draw3DCounter() {
      const now = performance.now();
      if (isPowerOn && systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive && now - lastCounterTick >= 1000) {
        lastCounterTick = now;
        const oldValue = counterValue;
        counterValue = score; // ‚Üê –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å–æ —Å—á–µ—Ç–æ–º –∏–≥—Ä—ã
        const oldHundreds = Math.floor(oldValue / 100) % 10;
        const oldTens = Math.floor(oldValue / 10) % 10;
        const oldUnits = oldValue % 10;
        const newHundreds = Math.floor(counterValue / 100) % 10;
        const newTens = Math.floor(counterValue / 10) % 10;
        const newUnits = counterValue % 10;
        if (newUnits !== oldUnits) {
          animatingDigit = { wheel: 2, from: oldUnits, to: newUnits, progress: 0 };
        }
        if (newTens !== oldTens) {
          animatingDigit = { wheel: 1, from: oldTens, to: newTens, progress: 0 };
        }
        if (newHundreds !== oldHundreds) {
          animatingDigit = { wheel: 0, from: oldHundreds, to: newHundreds, progress: 0 };
        }
      }
      if (animatingDigit && isPowerOn) {
        animatingDigit.progress += 0.04;
        if (animatingDigit.progress >= 1) {
          animatingDigit = null;
        }
      }
      ctx.fillStyle = '#0a0a0a';
      roundRect(ctx, COUNTER_X, COUNTER_Y, COUNTER_WIDTH, COUNTER_HEIGHT, 6);
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.save();
      roundRect(ctx, COUNTER_X, COUNTER_Y, COUNTER_WIDTH, COUNTER_HEIGHT, 6);
      ctx.clip();
      const wheelWidth = COUNTER_WIDTH / 3;
      const digits = [
        Math.floor(counterValue / 100) % 10,
        Math.floor(counterValue / 10) % 10,
        counterValue % 10
      ].map(function(d) {
        return isNaN(d) ? 0 : d;
      });
      for (let i = 0; i < 3; i++) {
        const x = COUNTER_X + i * wheelWidth;
        const y = COUNTER_Y;
        const centerX = x + wheelWidth / 2;
        const centerY = y + COUNTER_HEIGHT / 2;
        if (animatingDigit && animatingDigit.wheel === i) {
          const fromDigit = animatingDigit.from;
          const toDigit = animatingDigit.to;
          const p = animatingDigit.progress;
          draw3DRectAndDigit(fromDigit, centerX, centerY, wheelWidth, COUNTER_HEIGHT, p * Math.PI, true);
          draw3DRectAndDigit(toDigit, centerX, centerY, wheelWidth, COUNTER_HEIGHT, -Math.PI + p * Math.PI, false);
        } else {
          drawStaticRectAndDigit(digits[i], centerX, centerY, wheelWidth, COUNTER_HEIGHT);
        }
      }
      ctx.restore();
    }
    function drawStaticRectAndDigit(digit, centerX, centerY, width, height) {
      const halfHeight = height / 2;
      const rectWidth = width * 0.95;
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(centerX - rectWidth/2, centerY - halfHeight, rectWidth, halfHeight);
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.fillStyle = isPowerOn ? '#ffffff' : '#666'; // ‚Üê –ó–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ –±–µ–ª—ã–π
      ctx.font = 'bold 24px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(digit), 0, 0);
      ctx.restore();
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(centerX - rectWidth/2, centerY, rectWidth, halfHeight);
    }
    function draw3DRectAndDigit(digit, centerX, centerY, width, height, rotationAngle, isUpper) {
      const cosA = Math.cos(rotationAngle);
      const sinA = Math.sin(rotationAngle);
      const scale = 0.8 + 0.2 * Math.abs(cosA);
      const yOffset = sinA * height * 0.25;
      ctx.save();
      ctx.translate(centerX, centerY + yOffset);
      ctx.scale(scale, scale);
      const halfHeight = height / 2;
      const rectWidth = width * 0.95;
      if (isUpper) {
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(-rectWidth/2, -halfHeight, rectWidth, halfHeight);
      } else {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(-rectWidth/2, 0, rectWidth, halfHeight);
      }
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.font = 'bold 24px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(digit), 1, 1);
      ctx.fillStyle = isPowerOn ? '#ffffff' : '#666'; // ‚Üê –ó–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ –±–µ–ª—ã–π
      ctx.fillText(String(digit), 0, 0);
      if (cosA > 0) {
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(-rectWidth/2, -halfHeight/2, rectWidth, halfHeight/4);
      }
      ctx.restore();
    }
    // <<< –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø drawTimer >>>
    function drawTimer() {
      ctx.fillStyle = '#0a0a0a';
      roundRect(ctx, TIMER_X, TIMER_Y, TIMER_WIDTH, TIMER_HEIGHT, 4);
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.stroke();
      if (isPowerOn) {
        // <<< –ò–ó–ú–ï–ù–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º timeLeft –Ω–∞–ø—Ä—è–º—É—é, —É–±—Ä–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è timerSeconds >>>
        const mins = Math.floor(timeLeft / 60);
        const secs = timeLeft % 60;
        const timeText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        let textColor = '#ffffff';
        // –ú–∏–≥–∞–Ω–∏–µ –ø—Ä–∏ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è 30 —Å–µ–∫—É–Ω–¥–∞—Ö
        if (timeLeft <= 30 && systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
          const blink = Math.floor(performance.now() / 500) % 2;
          textColor = blink === 0 ? '#0a0a0a' : '#ffffff';
        }
        ctx.fillStyle = textColor;
        ctx.font = 'bold 36px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(timeText, TIMER_X + TIMER_WIDTH / 2, TIMER_Y + TIMER_HEIGHT / 2);
        // <<< –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô >>>
      } else {
        ctx.fillStyle = '#555';
        ctx.font = 'bold 36px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('--:--', TIMER_X + TIMER_WIDTH / 2, TIMER_Y + TIMER_HEIGHT / 2);
      }
    }
    function drawBootText() {
      if (!bootActive || !isPowerOn || godmodeActive || isGodmodeFinalized || errorCompleted) return;
      if (bootCompleted) return;
      const now = performance.now();
      if (now - lastBootTick >= 80) {
        lastBootTick = now;
        if (bootCharIndex >= bootText[bootLineIndex].length) {
          bootCharIndex = 0;
          bootLineIndex++;
          if (bootLineIndex >= bootText.length) {
            bootCompleted = true;
            systemsActive = true;
            // –ó–ê–ü–£–°–ö–ê–ï–ú –ò–ì–†–û–í–´–ï –¶–ò–ö–õ–´ –ü–û–°–õ–ï –ó–ê–ì–†–£–ó–ö–ò
            gameInterval = setInterval(gameStep, 250);
            gameTimer = setInterval(() => {
                timeLeft--;
                // <<< –ò–ó–ú–ï–ù–ï–ù–û: –≠–∫—Ä–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—è–≤–ª—è–µ—Ç—Å—è –¢–û–õ–¨–ö–û –ø—Ä–∏ 00:00 >>>
                if (timeLeft <= 0) {
                    clearInterval(gameTimer);
                    if (timeLeft === 0) {
                        isGameOverScreenActive = true;
                        systemsActive = false;
                    }
                }
                // <<< –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô >>>
            }, 1000);
            // –ö–û–ù–ï–¶ –ó–ê–ü–£–°–ö–ê
            return;
          }
        } else {
          bootCharIndex++;
        }
      }
      ctx.fillStyle = '#ffffff'; // ‚Üê –ó–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ –±–µ–ª—ã–π
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      for (let i = 0; i < bootLineIndex; i++) {
        ctx.fillText(bootText[i], DISPLAY_X + 10, DISPLAY_Y + 20 + i * 20);
      }
      if (bootLineIndex < bootText.length) {
        const currentLine = bootText[bootLineIndex].substring(0, bootCharIndex);
        ctx.fillText(currentLine, DISPLAY_X + 10, DISPLAY_Y + 20 + bootLineIndex * 20);
      }
    }
    function drawPasswordText() {
      if (!godmodeActive || !passwordMode || !isPowerOn || isGodmodeFinalized || errorCompleted) return;
      const now = performance.now();
      if (now - lastPasswordTick >= 80) {
        lastPasswordTick = now;
        if (passwordCharIndex >= passwordText[passwordLineIndex].length) {
          passwordCharIndex = 0;
          passwordLineIndex++;
          if (passwordLineIndex >= passwordText.length) {
            passwordMode = false;
            return;
          }
        } else {
          passwordCharIndex++;
        }
      }
      ctx.fillStyle = '#ffffff'; // ‚Üê –ó–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ –±–µ–ª—ã–π
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      for (let i = 0; i < passwordLineIndex; i++) {
        ctx.fillText(passwordText[i], DISPLAY_X + 10, DISPLAY_Y + 20 + i * 20);
      }
      if (passwordLineIndex < passwordText.length) {
        const currentLine = passwordText[passwordLineIndex].substring(0, passwordCharIndex);
        ctx.fillText(currentLine, DISPLAY_X + 10, DISPLAY_Y + 20 + passwordLineIndex * 20);
      }
    }
    function drawInputField() {
      if (!godmodeActive || passwordMode || !isPowerOn || errorMode || godmodeSuccess || isGodmodeFinalized || errorCompleted) return;
      ctx.font = 'bold 48px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const centerX = DISPLAY_X + 200;
      const centerY = DISPLAY_Y + 75;
      for (let i = 0; i < 3; i++) {
        const xPos = centerX - 60 + i * 60;
        if (i < inputCode.length) {
          ctx.fillStyle = '#ffffff'; // ‚Üê –ó–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ –±–µ–ª—ã–π
          ctx.fillText(inputCode[i].toString(), xPos, centerY);
        } else {
          ctx.fillStyle = '#666';
          ctx.fillText("-", xPos, centerY);
        }
      }
    }
    function drawKeypad() {
      if (!godmodeActive || passwordMode || !isPowerOn || errorMode || godmodeSuccess || isGodmodeFinalized || errorCompleted) return;
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
          const digit = row * 3 + col + 1;
          const keyX = KEYPAD_START_X + col * (KEYPAD_SIZE + KEYPAD_GAP);
          const keyY = KEYPAD_START_Y + row * (KEYPAD_SIZE + KEYPAD_GAP);
          drawKey(keyX, keyY, String(digit), pressedKey === digit);
        }
      }
      const zeroX = KEYPAD_START_X + 1 * (KEYPAD_SIZE + KEYPAD_GAP);
      const zeroY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      drawKey(zeroX, zeroY, "0", pressedKey === 0);
      const delX = KEYPAD_START_X + 0 * (KEYPAD_SIZE + KEYPAD_GAP);
      const delY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      drawKey(delX, delY, "DEL", pressedKey === 'DEL');
      const starX = KEYPAD_START_X + 2 * (KEYPAD_SIZE + KEYPAD_GAP);
      const starY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      drawKey(starX, starY, "*", pressedKey === '*');
    }
    function drawKey(x, y, label, isPressed) {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ—Ä—ã–π —Ü–≤–µ—Ç –≤–º–µ—Å—Ç–æ –∑–µ–ª–µ–Ω–æ–≥–æ
        ctx.fillStyle = isPressed ? '#aaaaaa' : '#333333';
        roundRect(ctx, x, y, KEYPAD_SIZE, KEYPAD_SIZE, 8);
        ctx.fill();
        ctx.strokeStyle = '#666666'; // –°–µ—Ä—ã–π –∫–æ–Ω—Ç—É—Ä
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#ffffff'; // –ë–µ–ª—ã–π —Ç–µ–∫—Å—Ç
        ctx.font = 'bold 24px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x + KEYPAD_SIZE/2, y + KEYPAD_SIZE/2);
    }
    function drawGodmodeDisplay() {
      if (!godmodeSuccess || !isPowerOn || isGodmodeFinalized || errorCompleted) return;
      const now = performance.now();
      if (now - lastGodmodeDisplayTick >= 80) {
        lastGodmodeDisplayTick = now;
        if (godmodeDisplayCharIndex >= godmodeDisplayText[godmodeDisplayLineIndex].length) {
          godmodeDisplayCompleted = true;
          // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—é GODMODE
          isGodmodeFinalized = true;
          // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º —ç–∫—Ä–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä—ã –¢–û–õ–¨–ö–û –ü–û–°–õ–ï –ó–ê–í–ï–†–®–ï–ù–ò–Ø –ê–ù–ò–ú–ê–¶–ò–ò –¢–ï–ö–°–¢–ê
          isGameOverScreenActive = true;
          return;
        } else {
          godmodeDisplayCharIndex++;
        }
      }
      // –†–∏—Å—É–µ–º —á–µ—Ä–Ω—ã–π —Ñ–æ–Ω –¥–ª—è GODMODE
      ctx.fillStyle = 'black';
      ctx.fillRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
      // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
      ctx.fillStyle = '#ffffff'; // ‚Üê –ó–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ –±–µ–ª—ã–π
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      const currentLine = godmodeDisplayText[godmodeDisplayLineIndex].substring(0, godmodeDisplayCharIndex);
      ctx.fillText(currentLine, DISPLAY_X + 10, DISPLAY_Y + 20);
    }
    function drawErrorText() {
      if (!errorMode || !isPowerOn || errorCompleted || isGodmodeFinalized) return;
      const now = performance.now();
      if (now - lastErrorTick >= 80) {
        lastErrorTick = now;
        if (errorCharIndex >= errorText[errorLineIndex].length) {
          errorCharIndex = 0;
          errorLineIndex++;
          if (errorLineIndex >= errorText.length) {
            errorCompleted = true;
            // <<< –ò–ó–ú–ï–ù–ï–ù–û: –í—ã–∫–ª—é—á–∞–µ–º –ø–∏—Ç–∞–Ω–∏–µ –∏ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å—ë –¢–û–õ–¨–ö–û –ü–û–°–õ–ï –ó–ê–í–ï–†–®–ï–ù–ò–Ø –ê–ù–ò–ú–ê–¶–ò–ò >>>
            isPowerOn = false;
            resetAll();
            // <<< –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô >>>
            return;
          }
        } else {
          errorCharIndex++;
        }
      }
      ctx.fillStyle = '#ffffff'; // ‚Üê –ó–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ –±–µ–ª—ã–π
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      for (let i = 0; i < errorLineIndex; i++) {
        ctx.fillText(errorText[i], DISPLAY_X + 10, DISPLAY_Y + 20 + i * 20);
      }
      if (errorLineIndex < errorText.length) {
        const currentLine = errorText[errorLineIndex].substring(0, errorCharIndex);
        ctx.fillText(currentLine, DISPLAY_X + 10, DISPLAY_Y + 20 + errorLineIndex * 20);
      }
    }
    // <<< –ò–ó–ú–ï–ù–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø drawGlowBorder: –°–≤–µ—á–µ–Ω–∏–µ –¢–û–õ–¨–ö–û –ù–ê–†–£–ñ–£, –ù–ê–ß–ò–ù–ê–ï–¢–°–Ø –ó–ê –ß–ï–†–ù–û–ô –†–ê–ú–ö–û–ô >>>
    function drawGlowBorder() {
        // –†–∏—Å—É–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–∞–Ω–µ–ª—å –≤–∫–ª—é—á–µ–Ω–∞
        if (!isPowerOn || errorCompleted) return;
        // –°–æ–∑–¥–∞–µ–º –ø—É–ª—å—Å–∏—Ä—É—é—â–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –¥–ª—è —Å–≤–µ—á–µ–Ω–∏—è
        const pulse = 0.7 + 0.3 * Math.sin(performance.now() / 800);
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        ctx.save();
        // === –≠–§–§–ï–ö–¢ –ù–ê–†–£–ñ–ù–û–ì–û –°–í–ï–ß–ï–ù–ò–Ø ===
        ctx.shadowColor = `rgba(255, 255, 255, ${0.4 * pulse})`;
        ctx.shadowBlur = 30;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        // –†–∏—Å—É–µ–º –Ω–µ–≤–∏–¥–∏–º—ã–µ –∫–æ–Ω—Ç—É—Ä—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≤–Ω–µ—à–Ω–µ–≥–æ —Å–≤–µ—á–µ–Ω–∏—è
        ctx.strokeStyle = 'transparent';
        ctx.lineWidth = 2;
        // <<< –ò–ó–ú–ï–ù–ï–ù–û: –°–≤–µ—á–µ–Ω–∏–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –ó–ê —á–µ—Ä–Ω–æ–π —Ä–∞–º–∫–æ–π >>>
        ctx.strokeRect(
            DISPLAY_X - 1,
            DISPLAY_Y - 1,
            DISPLAY_WIDTH + 2,
            DISPLAY_HEIGHT + 2
        );
        // <<< –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô >>>
        roundRect(ctx, VOLTMETER_X, VOLTMETER_Y, VOLTMETER_WIDTH, VOLTMETER_HEIGHT, 6);
        ctx.stroke();
        roundRect(ctx, LCD_X, LCD_Y, LCD_WIDTH, LCD_HEIGHT, 6);
        ctx.stroke();
        roundRect(ctx, TIMER_X, TIMER_Y, TIMER_WIDTH, TIMER_HEIGHT, 4);
        ctx.stroke();
        // === –≠–§–§–ï–ö–¢ –í–ù–£–¢–†–ï–ù–ù–ï–ô –¢–ï–ù–ò (–°–í–ï–ß–ï–ù–ò–ï –í–ù–£–¢–†–¨) ===
        // <<< –£–î–ê–õ–ï–ù–û: –í–µ—Å—å –±–ª–æ–∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —Å–≤–µ—á–µ–Ω–∏—è >>>
        // if (systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
        //     ctx.shadowColor = `rgba(255, 255, 255, ${0.3 * pulse})`;
        //     ctx.shadowBlur = 20;
        //     ctx.shadowOffsetX = 0;
        //     ctx.shadowOffsetY = 0;
        //     ctx.fillRect(DISPLAY_X + 2, DISPLAY_Y + 2, DISPLAY_WIDTH - 4, DISPLAY_HEIGHT - 4);
        // }
        // <<< –ö–û–ù–ï–¶ –£–î–ê–õ–ï–ù–ò–Ø >>>
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (–æ—Ç–∫–ª—é—á–∞–µ–º —Ç–µ–Ω—å)
        ctx.restore();
        // === –ß–ï–¢–ö–ò–ô –ö–û–ù–¢–£–† ===
        ctx.lineWidth = 2;
        // –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
        if (systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.strokeRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
        } else {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.strokeRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
        }
        // –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä—ã –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –ø–∞–Ω–µ–ª–µ–π
        roundRect(ctx, VOLTMETER_X, VOLTMETER_Y, VOLTMETER_WIDTH, VOLTMETER_HEIGHT, 6);
        ctx.stroke();
        roundRect(ctx, LCD_X, LCD_Y, LCD_WIDTH, LCD_HEIGHT, 6);
        ctx.stroke();
        roundRect(ctx, TIMER_X, TIMER_Y, TIMER_WIDTH, TIMER_HEIGHT, 4);
        ctx.stroke();
    }
    // <<< –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô >>>
    function drawGameOverScreen() {
        // –†–∏—Å—É–µ–º —á–µ—Ä–Ω—ã–π —Ñ–æ–Ω —ç–∫—Ä–∞–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        ctx.fillStyle = 'black';
        ctx.fillRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
        // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        ctx.fillStyle = '#ffffff'; // ‚Üê –ó–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ –±–µ–ª—ã–π
        ctx.font = 'bold 36px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`–°–ß–ï–¢: ${counterValue}`, DISPLAY_X + 200, DISPLAY_Y + 150);
        // –†–∏—Å—É–µ–º –∫–Ω–æ–ø–∫—É SAVE
        const saveButtonX = DISPLAY_X + 100;
        const saveButtonY = DISPLAY_Y + 300;
        const saveButtonWidth = 200;
        const saveButtonHeight = 60;
        ctx.fillStyle = '#ffffff'; // ‚Üê –ó–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ –±–µ–ª—ã–π
        roundRect(ctx, saveButtonX, saveButtonY, saveButtonWidth, saveButtonHeight, 8);
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'black';
        ctx.font = 'bold 24px "Courier New", monospace';
        ctx.fillText('SAVE', saveButtonX + saveButtonWidth / 2, saveButtonY + saveButtonHeight / 2);
    }
    function drawRonaviText() {
      ctx.fillStyle = '#000'; // –ß–µ—Ä–Ω—ã–π —Ü–≤–µ—Ç
      ctx.font = 'bold 30px "NexaBold", Arial, sans-serif';
      ctx.textAlign = 'center'; // –í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –ø–æ —Ü–µ–Ω—Ç—Ä—É
      ctx.textBaseline = 'bottom'; // –ë–∞–∑–æ–≤–∞—è –ª–∏–Ω–∏—è ‚Äî –Ω–∏–∑ —Ç–µ–∫—Å—Ç–∞
      ctx.fillText('RONAVI', GAME_WIDTH / 2, GAME_HEIGHT - 20); // –ü–æ —Ü–µ–Ω—Ç—Ä—É –ø–æ X, 20px –æ—Ç –Ω–∏–∑–∞ –ø–æ Y
    }
    function gameLoop() {
      ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      if (!isPowerOn) {
        powerOffBlink += 0.05;
      }
      // –û—á–∏—â–∞–µ–º —Ñ–æ–Ω –¥–∏—Å–ø–ª–µ—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–≥—Ä–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞
      if (!systemsActive || errorCompleted || isGodmodeFinalized) {
          ctx.fillStyle = '#000';
          ctx.fillRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
      }
      // –†–∏—Å—É–µ–º –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ
      if (systemsActive && !errorCompleted && !isGodmodeFinalized && !isGameOverScreenActive) {
        drawGame();
      }
      // –†–ò–°–£–ï–ú –≠–ö–†–ê–ù –ó–ê–í–ï–†–®–ï–ù–ò–Ø –ò–ì–†–´
      if (isGameOverScreenActive) {
        drawGameOverScreen();
      }
      // –†–∏—Å—É–µ–º UI-—ç–ª–µ–º–µ–Ω—Ç—ã –ø–∞–Ω–µ–ª–∏
      drawLCDDisplay();
      drawVoltmeter();
      draw3DCounter();
      drawTimer();
      drawPowerButton();
      // <<< –£–î–ê–õ–ï–ù–û: drawLamps() >>>
      drawRSTButton();
      drawPRGButton();
      drawGlowBorder();
      drawBootText();
      if (godmodeActive) {
        drawPasswordText();
        drawInputField();
        drawKeypad();
        drawErrorText();
        drawGodmodeDisplay();
      }
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.strokeRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
      drawRonaviText();
      requestAnimationFrame(gameLoop);
    }
    function roundRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–≥—Ä—ã –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ Telegram
    function initializeGame() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç—É–ø–µ–Ω –ª–∏ Telegram WebApp
        if (window.Telegram && window.Telegram.WebApp) {
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º WebApp
            window.Telegram.WebApp.ready();
            console.log("‚úÖ Telegram WebApp —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω");

            // –°–∫—Ä—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –æ—à–∏–±–∫–∏, –µ—Å–ª–∏ –æ–Ω –±—ã–ª –ø–æ–∫–∞–∑–∞–Ω
            document.getElementById('error-screen').style.display = 'none';

            // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
            gameLoop();
        } else {
            // –ï—Å–ª–∏ WebApp –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –æ—à–∏–±–∫–∏
            console.error("‚ùå –ò–≥—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞ –≤–Ω–µ Telegram WebApp");
            document.getElementById('error-screen').style.display = 'flex';
            // –ë–ª–æ–∫–∏—Ä—É–µ–º canvas, —á—Ç–æ–±—ã –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å –ª—é–±–æ–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ
            canvas.style.pointerEvents = 'none';
        }
    }

    // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –∏–≥—Ä—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    window.addEventListener('load', function() {
        initializeGame();
    });

  </script>
</body>
</html>
