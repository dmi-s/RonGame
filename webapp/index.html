<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Панель Управления Роботом</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
      @font-face {
        font-family: 'NexaBold';
        src: url('Nexa-Bold.ttf') format('truetype');
        font-weight: bold;
        font-style: normal;
        font-display: swap;
    }
    body {
      overflow: hidden;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    #game-container {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      background: linear-gradient(135deg, #ccaa00, #ffdd00, #ffff00, #ffdd00, #ccaa00);
      border: 2px solid #222;
      box-shadow:
        0 0 20px #111,
        inset 0 0 20px rgba(255,255,255,0.05),
        inset 0 0 50px rgba(0,0,0,0.3);
      border-radius: 6px;
      image-rendering: pixelated;
      width: auto;
      height: auto;
      max-width: 100vw;
      max-height: 100vh;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>
  </div>
  <script>
    if (window.Telegram && window.Telegram.WebApp) {
        window.Telegram.WebApp.ready();
        console.log("✅ Telegram WebApp успешно инициализирован");
    } else {
        console.warn("⚠️ Запущено не в Telegram. WebApp API недоступно.");
    }
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    // === РАЗМЕРЫ ПАНЕЛИ ===
    const GAME_WIDTH = 420;  // Общий размер canvas
    const GAME_HEIGHT = 650;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;


    const TOP_MARGIN = 20;
    const PANEL_HEIGHT = 65;
    const GAP_TIMER_COUNTER = 10;
    const GAP_COUNTER_DISPLAY = 20;
    const DISPLAY_HEIGHT = 400; // Размер игрового поля
    const BOTTOM_MARGIN = 20;
    const TIMER_Y = TOP_MARGIN;
    const COUNTER_Y = TIMER_Y + PANEL_HEIGHT + GAP_TIMER_COUNTER;
    const DISPLAY_Y = COUNTER_Y + PANEL_HEIGHT + GAP_COUNTER_DISPLAY;
    const PANEL_WIDTH = 126;
    const LEFT_MARGIN = 10;
    const GAP_VOLT_TIMER = 10;
    const VOLTMETER_X = LEFT_MARGIN;
    const VOLTMETER_Y = TIMER_Y;
    const VOLTMETER_WIDTH = PANEL_WIDTH;
    const VOLTMETER_HEIGHT = PANEL_HEIGHT;
    const TIMER_X = VOLTMETER_X + VOLTMETER_WIDTH + GAP_VOLT_TIMER;
    const TIMER_WIDTH = PANEL_WIDTH;
    const TIMER_HEIGHT = PANEL_HEIGHT;
    const COUNTER_X = TIMER_X;
    const COUNTER_WIDTH = PANEL_WIDTH;
    const COUNTER_HEIGHT = PANEL_HEIGHT;
    const LCD_X = VOLTMETER_X;
    const LCD_Y = COUNTER_Y;
    const LCD_WIDTH = PANEL_WIDTH;
    const LCD_HEIGHT = PANEL_HEIGHT;
    const DISPLAY_WIDTH = 400; // Размер игрового поля
    const DISPLAY_X = 10;
    // === КНОПКА POWER ===
    // Расчет новой позиции и размера кнопки POWER
    const POWER_BUTTON_HEIGHT = PANEL_HEIGHT; // Высота как у таймера
    const POWER_RIGHT_MARGIN = 10; // Отступ от правого края canvas
    const POWER_LEFT_MARGIN_FROM_TIMER = 10; // Отступ от правой стороны таймера
    const POWER_X = TIMER_X + TIMER_WIDTH + POWER_LEFT_MARGIN_FROM_TIMER; // Левая сторона кнопки
    const POWER_WIDTH = GAME_WIDTH - POWER_X - POWER_RIGHT_MARGIN; // Автоматический расчет ширины
    const POWER_Y = TIMER_Y;
    const POWER_CENTER_X = POWER_X + POWER_WIDTH / 2;
    const POWER_CENTER_Y = POWER_Y + POWER_BUTTON_HEIGHT / 2;
    // === КНОПКИ RESET и PROG ===
    const FIELD_LEFT = COUNTER_X + COUNTER_WIDTH + 10;
    const FIELD_RIGHT = GAME_WIDTH - 10;
    const FIELD_TOP = COUNTER_Y;
    const FIELD_BOTTOM = COUNTER_Y + COUNTER_HEIGHT;
    const FIELD_WIDTH = FIELD_RIGHT - FIELD_LEFT;
    const FIELD_HEIGHT = FIELD_BOTTOM - FIELD_TOP;
    const SMALL_BUTTON_SIZE = 50;
    const GAP_BETWEEN_BUTTONS = 10;
    const FIELD_CENTER_X = (FIELD_LEFT + FIELD_RIGHT) / 2;
    const FIELD_CENTER_Y = (FIELD_TOP + FIELD_BOTTOM) / 2;
    const RST_X = FIELD_CENTER_X - SMALL_BUTTON_SIZE - GAP_BETWEEN_BUTTONS / 2;
    const RST_Y = FIELD_CENTER_Y - SMALL_BUTTON_SIZE / 2;
    const RST_CENTER_X = RST_X + SMALL_BUTTON_SIZE / 2;
    const RST_CENTER_Y = RST_Y + SMALL_BUTTON_SIZE / 2;
    const PRG_X = FIELD_CENTER_X + GAP_BETWEEN_BUTTONS / 2;
    const PRG_Y = FIELD_CENTER_Y - SMALL_BUTTON_SIZE / 2;
    const PRG_CENTER_X = PRG_X + SMALL_BUTTON_SIZE / 2;
    const PRG_CENTER_Y = PRG_Y + SMALL_BUTTON_SIZE / 2;
    // === ЗАРЯД РОБОТА ===
    let robotCharge = 100;
    let lastChargeTick = 0;
    let isPowerOn = false;
    let isRSTPressed = false;
    let isPRGPressed = false;
    let powerOffBlink = 0;
    // let timerSeconds = 180; ← УДАЛЕНО
    // let lastTickTime = 0; ← УДАЛЕНО
    let counterValue = 0;
    let lastCounterTick = 0;
    let animatingDigit = null;
    let systemsActive = false;
    // === ТЕКСТ ЗАГРУЗКИ ===
    const bootText = [
      ">>> INIT",
      ">>> CONNECT TO RONAVI_MCNS",
      ">>> LOW SIGNAL",
      ">>> SUDO START_GAME",
      ">>> GAME START IN",
      ">>> 3",
      ">>> 2",
      ">>> 1"
    ];
    let bootLineIndex = 0;
    let bootCharIndex = 0;
    let lastBootTick = 0;
    let bootActive = false;
    let bootCompleted = false;
    // ← GODMODE
    let prgPressCount = 0;
    let godmodeActive = false;
    let passwordMode = false;
    let inputCode = [];
    let lastPasswordTick = 0;
    let passwordLineIndex = 0;
    let passwordCharIndex = 0;
    const passwordText = [
      ">>>GODMODE_OFF",
      ">>>ENTER PASSWORD"
    ];
    // ← GODMODE: клавиатура
    const KEYPAD_SIZE = 50;
    const KEYPAD_GAP = 10;
    const KEYPAD_ROWS = 4;
    const KEYPAD_COLS = 3;
    const KEYPAD_TOTAL_WIDTH = KEYPAD_COLS * KEYPAD_SIZE + (KEYPAD_COLS - 1) * KEYPAD_GAP;
    const KEYPAD_TOTAL_HEIGHT = KEYPAD_ROWS * KEYPAD_SIZE + (KEYPAD_ROWS - 1) * KEYPAD_GAP;
    const KEYPAD_START_X = DISPLAY_X + (DISPLAY_WIDTH - KEYPAD_TOTAL_WIDTH) / 2;
    const KEYPAD_START_Y = DISPLAY_Y + 120;
    let pressedKey = null;
    // ← GODMODE: ошибка
    let errorMode = false;
    let errorText = [
      ">>>GODMODE_OFF",
      ">>>ERROR",
      ">>>POWER_OFF"
    ];
    let errorLineIndex = 0;
    let errorCharIndex = 0;
    let lastErrorTick = 0;
    let errorCompleted = false;
    // ← GODMODE: успешная активация
    let godmodeSuccess = false;
    let godmodeDisplayText = [">>>GODMODE_ON"];
    let godmodeDisplayLineIndex = 0;
    let godmodeDisplayCharIndex = 0;
    let lastGodmodeDisplayTick = 0;
    let godmodeDisplayCompleted = false;
    // ← Флаг: GODMODE активирован и финализирован (текст исчез, всё заморожено)
    let isGodmodeFinalized = false;
    // ← Флаг: Экран завершения игры активен (истекло время или активирован GODMODE)
    let isGameOverScreenActive = false;
    // === ИГРА "РОБОТЫ" ===
    const gridSize = 40;
    const gridWidth = 10; // 400 / 40
    const gridHeight = 10; // 400 / 40
    let snakes = [];
    let food = [];
    let obstacles = [];
    let chargingStations = [];
    let parkingSpots = [];
    let score = 0;
    let gameRunning = false;
    let gameStarted = false;
    let targetPoints = [];
    let selectedSnakeIndex = -1;
    let activeRobotIndex = -1;
    let gameInterval;
    let gameTimer;
    let timeLeft = 180;
    // Генерируем случайный стартовый заряд от 25 до 90 для каждого робота
    let snakeCharges = [
        Math.floor(Math.random() * (90 - 25 + 1)) + 25,
        Math.floor(Math.random() * (90 - 25 + 1)) + 25,
        Math.floor(Math.random() * (90 - 25 + 1)) + 25
    ];
    let moveCounts = [0, 0, 0];
    let onChargingStation = [-1, -1, -1];
    let chargingTimers = [null, null, null];
    let hasCargo = [false, false, false];
    let cargoFood = [null, null, null];
    let onParking = [-1, -1, -1];
    let isBlinking = [false, false, false];
    let snakeRoutes = [[], [], []];
    let routeProgress = [0, 0, 0];
    let reservedTargets = {};
    let snakeRouteTimestamps = [0, 0, 0];
    // Переменная для хранения последнего горизонтального направления каждого робота
    let lastHorizontalDirection = ['right', 'right', 'right']; // Инициализируем 'right' для всех
    let snakeHeadImage = new Image();
    let snakeHeadLeftImage = new Image(); // Новое изображение для движения влево
    let snakeHeadWithShelfImage = new Image();
    let snakeHeadWithShelfRightImage = new Image(); // Новое изображение для движения вправо с грузом
    let snakeHeadChargingImage = new Image();
    let snakeHeadChargingRightImage = new Image(); // Новое изображение для движения вправо на зарядке
    let foodImage = new Image();
    let chargingImage = new Image();
    let parkingImage = new Image();
    let obstacleImage = new Image();
    // Загрузка изображений
    snakeHeadImage.src = 'Robot.png';
    snakeHeadLeftImage.src = 'robot_left.png'; // Загружаем новое изображение
    snakeHeadWithShelfImage.src = 'Robot_Shelf.png';
    snakeHeadWithShelfRightImage.src = 'Robot_Shelf_right.png'; // Загружаем новое изображение
    snakeHeadChargingImage.src = 'Robot_Charg.png';
    snakeHeadChargingRightImage.src = 'Robot_Charg_right.png'; // Загружаем новое изображение
    foodImage.src = 'Shelf.png';
    chargingImage.src = 'Charging.png';
    parkingImage.src = 'Parking.png';
    obstacleImage.src = 'Column.png';
    function isObstacle(x, y) {
        for (let obstacle of obstacles) {
            if (obstacle.x === x && obstacle.y === y) {
                return true;
            }
        }
        return false;
    }
    function isChargingStation(x, y) {
        for (let i = 0; i < chargingStations.length; i++) {
            if (chargingStations[i].x === x && chargingStations[i].y === y) {
                return i;
            }
        }
        return -1;
    }
    function isParkingSpot(x, y) {
        for (let i = 0; i < parkingSpots.length; i++) {
            if (parkingSpots[i].x === x && parkingSpots[i].y === y) {
                return i;
            }
        }
        return -1;
    }
    function isOtherSnake(x, y, snakeIndex) {
        for (let i = 0; i < snakes.length; i++) {
            if (i !== snakeIndex) {
                for (let segment of snakes[i]) {
                    if (segment.x === x && segment.y === y) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    function isFood(x, y) {
        for (let f of food) {
            if (f.x === x && f.y === y) {
                return true;
            }
        }
        return false;
    }
    function routesIntersect(snakeIndex1, snakeIndex2) {
        if (snakeRoutes[snakeIndex1].length === 0 || snakeRoutes[snakeIndex2].length === 0) {
            return false;
        }
        for (let i = routeProgress[snakeIndex1]; i < snakeRoutes[snakeIndex1].length; i++) {
            const point1 = snakeRoutes[snakeIndex1][i];
            for (let j = routeProgress[snakeIndex2]; j < snakeRoutes[snakeIndex2].length; j++) {
                const point2 = snakeRoutes[snakeIndex2][j];
                if (point1.x === point2.x && point1.y === point2.y) {
                    return true;
                }
            }
        }
        return false;
    }
    function aStar(startX, startY, endX, endY, snakeIndex) {
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }
        function canMoveTo(x, y, snakeIndex) {
            if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return false;
            if (isObstacle(x, y)) return false;
            if (isOtherSnake(x, y, snakeIndex)) return false;
            if (hasCargo[snakeIndex] && isChargingStation(x, y) !== -1) return false;
            if (hasCargo[snakeIndex] && isFood(x, y)) return false;
            const targetKey = `${x},${y}`;
            if (reservedTargets[targetKey] !== undefined && reservedTargets[targetKey] !== snakeIndex) {
                return false;
            }
            return true;
        }
        const start = {x: startX, y: startY};
        const end = {x: endX, y: endY};
        let openSet = [start];
        let closedSet = [];
        let cameFrom = {};
        let gScore = {};
        let fScore = {};
        gScore[startKey(start)] = 0;
        fScore[startKey(start)] = heuristic(start, end);
        while (openSet.length > 0) {
            let current = openSet.reduce((min, node) => {
                return fScore[startKey(node)] < fScore[startKey(min)] ? node : min;
            });
            if (current.x === end.x && current.y === end.y) {
                let path = [];
                let temp = current;
                while (temp) {
                    path.unshift(temp);
                    temp = cameFrom[startKey(temp)];
                }
                return path;
            }
            const currentIndex = openSet.indexOf(current);
            openSet.splice(currentIndex, 1);
            closedSet.push(current);
            const neighbors = [
                {x: current.x, y: current.y - 1},
                {x: current.x, y: current.y + 1},
                {x: current.x - 1, y: current.y},
                {x: current.x + 1, y: current.y}
            ];
            for (let neighbor of neighbors) {
                if (!canMoveTo(neighbor.x, neighbor.y, snakeIndex)) continue;
                if (closedSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) continue;
                const tentativeGScore = gScore[startKey(current)] + 1;
                const neighborKey = startKey(neighbor);
                const neighborInOpen = openSet.find(node => node.x === neighbor.x && node.y === neighbor.y);
                if (!neighborInOpen) {
                    openSet.push(neighbor);
                    gScore[neighborKey] = tentativeGScore;
                    fScore[neighborKey] = tentativeGScore + heuristic(neighbor, end);
                    cameFrom[neighborKey] = current;
                } else if (tentativeGScore < gScore[neighborKey]) {
                    gScore[neighborKey] = tentativeGScore;
                    fScore[neighborKey] = tentativeGScore + heuristic(neighbor, end);
                    cameFrom[neighborKey] = current;
                }
            }
        }
        return [];
    }
    function startKey(point) {
        return point.x + ',' + point.y;
    }
    function buildRoute(startX, startY, endX, endY, snakeIndex) {
        const path = aStar(startX, startY, endX, endY, snakeIndex);
        // <<< НОВЫЙ БЛОК: Определяем начальное направление движения по маршруту >>>
        if (path.length > 1) {
            // Берем первую точку назначения (индекс 1, так как индекс 0 — текущая позиция)
            const firstStep = path[1];
            const dx = firstStep.x - startX;
            // Обновляем направление только для горизонтального движения
            if (dx > 0) {
                lastHorizontalDirection[snakeIndex] = 'right';
            } else if (dx < 0) {
                lastHorizontalDirection[snakeIndex] = 'left';
            }
            // Если dx === 0 (вертикальное движение), направление не меняем
        }
        // <<< КОНЕЦ НОВОГО БЛОКА >>>
        return path;
    }
    function initGame() {
        snakes = [];
        selectedSnakeIndex = -1;
        activeRobotIndex = -1;
        targetPoints = [];
        // Генерируем случайный стартовый заряд от 25 до 90 для каждого робота
        snakeCharges = [
            Math.floor(Math.random() * (90 - 25 + 1)) + 25,
            Math.floor(Math.random() * (90 - 25 + 1)) + 25,
            Math.floor(Math.random() * (90 - 25 + 1)) + 25
        ];
        moveCounts = [0, 0, 0];
        onChargingStation = [-1, -1, -1];
        chargingTimers = [null, null, null];
        hasCargo = [false, false, false];
        cargoFood = [null, null, null];
        onParking = [-1, -1, -1];
        isBlinking = [false, false, false];
        snakeRoutes = [[], [], []];
        routeProgress = [0, 0, 0];
        reservedTargets = {};
        snakeRouteTimestamps = [0, 0, 0];
        // Сбрасываем направление при инициализации игры
        lastHorizontalDirection = ['right', 'right', 'right'];
        let positions = [];
        for (let i = 0; i < 3; i++) {
            let validPosition = false;
            let newPosition;
            while (!validPosition) {
                newPosition = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
                validPosition = true;
                for (let pos of positions) {
                    if (pos.x === newPosition.x && pos.y === newPosition.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
            positions.push(newPosition);
            snakes.push([{x: newPosition.x, y: newPosition.y}]);
            targetPoints.push(null);
        }
        generateObstacles();
        generateChargingStations();
        generateParkingSpots();
        generateFood();
        score = 0;
        timeLeft = 180;
    }
    function generateObstacles() {
        obstacles = [];
        const obstacleCount = 5;
        for (let i = 0; i < obstacleCount; i++) {
            let newObstacle;
            let validPosition = false;
            let attempts = 0;
            while (!validPosition && attempts < 1000) {
                attempts++;
                newObstacle = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
                validPosition = true;
                for (let snake of snakes) {
                    for (let segment of snake) {
                        if (segment.x === newObstacle.x && segment.y === newObstacle.y) {
                            validPosition = false;
                            break;
                        }
                    }
                    if (!validPosition) break;
                }
                if (validPosition) {
                    for (let existingFood of food) {
                        if (existingFood.x === newObstacle.x && existingFood.y === newObstacle.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                if (validPosition) {
                    for (let existingObstacle of obstacles) {
                        const distance = Math.abs(existingObstacle.x - newObstacle.x) + Math.abs(existingObstacle.y - newObstacle.y);
                        if (distance <= 2) {
                            validPosition = false;
                            break;
                        }
                    }
                }
            }
            if (attempts >= 1000) {
                console.error("Не удалось сгенерировать препятствие за 1000 попыток");
                break;
            }
            obstacles.push(newObstacle);
        }
    }
    function generateChargingStations() {
        chargingStations = [];
        const stationCount = 2;
        for (let i = 0; i < stationCount; i++) {
            let validPosition = false;
            let newStation;
            let obstacleUsed = null;
            let attempts = 0;
            while (!validPosition && attempts < 1000) {
                attempts++;
                const obstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
                if (obstacleUsed && obstacleUsed.x === obstacle.x && obstacleUsed.y === obstacle.y) {
                    continue;
                }
                const directions = [
                    {x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}
                ];
                const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                newStation = {
                    x: obstacle.x + randomDirection.x,
                    y: obstacle.y + randomDirection.y
                };
                if (newStation.x >= 0 && newStation.x < gridWidth && newStation.y >= 0 && newStation.y < gridHeight) {
                    let onObstacle = obstacles.some(o => o.x === newStation.x && o.y === newStation.y);
                    let onSnake = snakes.some(s => s.some(seg => seg.x === newStation.x && seg.y === newStation.y));
                    let onFood = food.some(f => f.x === newStation.x && f.y === newStation.y);
                    let onStation = chargingStations.some(s => s.x === newStation.x && s.y === newStation.y);
                    if (!onObstacle && !onSnake && !onFood && !onStation) {
                        validPosition = true;
                        obstacleUsed = obstacle;
                    }
                }
            }
            if (attempts >= 1000) {
                console.error("Не удалось сгенерировать зарядную станцию за 1000 попыток");
                break;
            }
            chargingStations.push(newStation);
        }
    }
    function generateParkingSpots() {
        parkingSpots = [];
        const parkingCount = 3;
        let attempts = 0;
        let maxAttempts = 1000;
        while (attempts < maxAttempts) {
            attempts++;
            let obstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
            const isHorizontal = Math.random() > 0.5;
            let parkingGroup = [];
            if (isHorizontal) {
                parkingGroup.push({x: obstacle.x + 1, y: obstacle.y});
                parkingGroup.push({x: obstacle.x + 2, y: obstacle.y});
                parkingGroup.push({x: obstacle.x + 3, y: obstacle.y});
            } else {
                parkingGroup.push({x: obstacle.x, y: obstacle.y + 1});
                parkingGroup.push({x: obstacle.x, y: obstacle.y + 2});
                parkingGroup.push({x: obstacle.x, y: obstacle.y + 3});
            }
            let validPosition = true;
            for (let spot of parkingGroup) {
                if (spot.x < 0 || spot.x >= gridWidth || spot.y < 0 || spot.y >= gridHeight) {
                    validPosition = false;
                    break;
                }
                if (obstacles.some(o => o.x === spot.x && o.y === spot.y)) validPosition = false;
                if (snakes.some(s => s.some(seg => seg.x === spot.x && seg.y === spot.y))) validPosition = false;
                if (food.some(f => f.x === spot.x && f.y === spot.y)) validPosition = false;
                if (chargingStations.some(s => s.x === spot.x && s.y === spot.y)) validPosition = false;
                if (obstacles.some(o => Math.abs(o.x - spot.x) + Math.abs(o.y - spot.y) <= 0)) validPosition = false;
            }
            if (validPosition) {
                parkingSpots = parkingGroup;
                return;
            }
        }
        console.error(`Не удалось сгенерировать парковочные места за ${maxAttempts} попыток`);
        parkingSpots = [];
    }
    function generateFood() {
        food = [];
        for (let i = 0; i < 3; i++) {
            let newFood;
            let validPosition = false;
            let attempts = 0;
            while (!validPosition && attempts < 1000) {
                attempts++;
                newFood = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
                validPosition = true;
                for (let snake of snakes) {
                    for (let segment of snake) {
                        if (segment.x === newFood.x && segment.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                    if (!validPosition) break;
                }
                if (validPosition) {
                    for (let obstacle of obstacles) {
                        if (obstacle.x === newFood.x && obstacle.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                if (validPosition) {
                    for (let station of chargingStations) {
                        if (station.x === newFood.x && station.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                if (validPosition) {
                    for (let parking of parkingSpots) {
                        if (parking.x === newFood.x && parking.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                if (validPosition) {
                    for (let existingFood of food) {
                        if (existingFood.x === newFood.x && existingFood.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                }
            }
            if (attempts >= 1000) {
                console.error("Не удалось сгенерировать еду за 1000 попыток");
                break;
            }
            food.push(newFood);
        }
    }
    function update() {
        if (!gameStarted) return;
        for (let i = 0; i < snakes.length; i++) {
            const snake = snakes[i];
            const targetPoint = targetPoints[i];
            if (!targetPoint || snakeRoutes[i].length === 0) continue;
            if (snakeCharges[i] <= 0) {
                // Сбрасываем маршрут и целевую точку, так как робот разрядился
                if (targetPoints[i]) {
                    const key = `${targetPoints[i].x},${targetPoints[i].y}`;
                    if (reservedTargets[key] === i) {
                        delete reservedTargets[key];
                    }
                    targetPoints[i] = null;
                }
                snakeRoutes[i] = [];
                routeProgress[i] = 0;
                continue;
            }
            let mustStop = false;
            for (let j = 0; j < snakes.length; j++) {
                if (i === j || snakeRoutes[j].length === 0) continue;
                if (routesIntersect(i, j)) {
                    if (snakeRouteTimestamps[j] < snakeRouteTimestamps[i]) {
                        mustStop = true;
                        break;
                    }
                }
            }
            if (mustStop) continue;
            const head = snake[0];
            if (routeProgress[i] < snakeRoutes[i].length) {
                const nextPoint = snakeRoutes[i][routeProgress[i]];
                if (head.x === nextPoint.x && head.y === nextPoint.y) {
                    routeProgress[i]++;
                    if (routeProgress[i] >= snakeRoutes[i].length) {
                        if (targetPoints[i]) {
                            const key = `${targetPoints[i].x},${targetPoints[i].y}`;
                            if (reservedTargets[key] === i) {
                                delete reservedTargets[key];
                            }
                            targetPoints[i] = null;
                        }
                        snakeRoutes[i] = [];
                        routeProgress[i] = 0;
                        if (i === activeRobotIndex) {
                            isBlinking[i] = true;
                        }
                        continue;
                    }
                }
            }
            if (routeProgress[i] < snakeRoutes[i].length) {
                const nextPoint = snakeRoutes[i][routeProgress[i]];
                const dx = nextPoint.x - head.x;
                const dy = nextPoint.y - head.y;
                const newHead = {x: head.x, y: head.y};

                // <<< НОВЫЙ БЛОК: Обновляем направление на КАЖДОМ шаге движения >>>
                if (dx > 0) {
                    newHead.x++;
                    lastHorizontalDirection[i] = 'right'; // Обновляем направление при движении вправо
                }
                else if (dx < 0) {
                    newHead.x--;
                    lastHorizontalDirection[i] = 'left'; // Обновляем направление при движении влево
                }
                else if (dy > 0) {
                    newHead.y++;
                    // При вертикальном движении направление НЕ меняем, оставляем предыдущее
                }
                else if (dy < 0) {
                    newHead.y--;
                    // При вертикальном движении направление НЕ меняем, оставляем предыдущее
                }
                // <<< КОНЕЦ НОВОГО БЛОКА >>>

                if (newHead.x < 0 || newHead.x >= gridWidth || newHead.y < 0 || newHead.y >= gridHeight) {
                    return;
                }
                for (let j = 0; j < snake.length; j++) {
                    if (snake[j].x === newHead.x && snake[j].y === newHead.y) {
                        return;
                    }
                }
                for (let obstacle of obstacles) {
                    if (obstacle.x === newHead.x && obstacle.y === newHead.y) {
                        return;
                    }
                }
                for (let j = 0; j < snakes.length; j++) {
                    if (i !== j) {
                        for (let segment of snakes[j]) {
                            if (segment.x === newHead.x && segment.y === newHead.y) {
                                return;
                            }
                        }
                    }
                }
                let stationIndex = isChargingStation(newHead.x, newHead.y);
                let parkingIndex = isParkingSpot(newHead.x, newHead.y);
                moveCounts[i]++;
                if (moveCounts[i] >= 2 && stationIndex === -1 && parkingIndex === -1) {
                    snakeCharges[i]--;
                    moveCounts[i] = 0;
                }
                // Проверяем, находится ли робот на зарядной станции
                if (stationIndex !== -1) {
                    // Условия для НАЧАЛА или ПРОДОЛЖЕНИЯ зарядки:
                    // 1. Робот не имеет груза
                    // 2. Он находится на станции (это уже true, так как stationIndex !== -1)
                    if (!hasCargo[i]) {
                        // Если зарядка еще не активна, запускаем ее
                        if (onChargingStation[i] === -1) {
                            onChargingStation[i] = stationIndex;
                            startCharging(i);
                        }
                        // Если зарядка активна, ничего не делаем (она продолжается)
                    } else {
                        // Если робот имеет груз, но при этом находится на станции и заряжается — останавливаем зарядку
                        if (onChargingStation[i] !== -1) {
                            stopCharging(i);
                            onChargingStation[i] = -1;
                        }
                    }
                } else {
                    // Если робот НЕ на станции, но зарядка активна — останавливаем ее
                    if (onChargingStation[i] !== -1) {
                        stopCharging(i);
                        onChargingStation[i] = -1;
                    }
                }
                if (parkingIndex !== -1) {
                    const targetPoint = targetPoints[i];
                    if (targetPoint && newHead.x === targetPoint.x && newHead.y === targetPoint.y) {
                        if (hasCargo[i]) {
                            hasCargo[i] = false;
                            cargoFood[i] = null;
                            score += 10;
                        }
                    }
                } else {
                    if (onParking[i] !== -1) onParking[i] = -1;
                }
                snake[0] = newHead;
                let foodEaten = false;
                let foodIndex = -1;
                for (let j = 0; j < food.length; j++) {
                    if (newHead.x === food[j].x && newHead.y === food[j].y) {
                        const targetPoint = targetPoints[i];
                        if (targetPoint && newHead.x === targetPoint.x && newHead.y === targetPoint.y && !hasCargo[i]) {
                            foodEaten = true;
                            foodIndex = j;
                            break;
                        }
                    }
                }
                if (foodEaten) {
                    hasCargo[i] = true;
                    cargoFood[i] = {x: food[foodIndex].x, y: food[foodIndex].y};
                    food.splice(foodIndex, 1);
                    generateNewFood();
                }
            }
        }
    }
    function startCharging(snakeIndex) {
        if (chargingTimers[snakeIndex]) clearInterval(chargingTimers[snakeIndex]);
        chargingTimers[snakeIndex] = setInterval(() => {
            if (snakeCharges[snakeIndex] < 100) {
                snakeCharges[snakeIndex] = Math.min(100, snakeCharges[snakeIndex] + 2);
            }
        }, 1000);
    }
    function stopCharging(snakeIndex) {
        if (chargingTimers[snakeIndex]) {
            clearInterval(chargingTimers[snakeIndex]);
            chargingTimers[snakeIndex] = null;
        }
    }
    function generateNewFood() {
        let newFood;
        let validPosition = false;
        let attempts = 0;
        while (!validPosition && attempts < 1000) {
            attempts++;
            newFood = {
                x: Math.floor(Math.random() * gridWidth),
                y: Math.floor(Math.random() * gridHeight)
            };
            validPosition = true;
            for (let snake of snakes) {
                for (let segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
                if (!validPosition) break;
            }
            if (validPosition) {
                for (let obstacle of obstacles) {
                    if (obstacle.x === newFood.x && obstacle.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
            if (validPosition) {
                for (let station of chargingStations) {
                    if (station.x === newFood.x && station.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
            if (validPosition) {
                for (let parking of parkingSpots) {
                    if (parking.x === newFood.x && parking.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
            if (validPosition) {
                for (let existingFood of food) {
                    if (existingFood.x === newFood.x && existingFood.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
        }
        if (attempts < 1000) food.push(newFood);
    }
    function drawGame() {
        // Сохраняем состояние контекста
        ctx.save();
        // Ограничиваем область отрисовки
        ctx.beginPath();
        ctx.rect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
        ctx.clip();
        // Сдвигаем систему координат
        ctx.translate(DISPLAY_X, DISPLAY_Y);
        // Очищаем только область игры
        ctx.fillStyle = '#b1b1b1';
        ctx.fillRect(0, 0, DISPLAY_WIDTH, DISPLAY_HEIGHT);
        // Рисуем сетку
        ctx.strokeStyle = '#cccccc';
        ctx.lineWidth = 1;
        for (let x = 0; x <= gridWidth; x++) {
            ctx.beginPath();
            ctx.moveTo(x * gridSize, 0);
            ctx.lineTo(x * gridSize, DISPLAY_HEIGHT);
            ctx.stroke();
        }
        for (let y = 0; y <= gridHeight; y++) {
            ctx.beginPath();
            ctx.moveTo(0, y * gridSize);
            ctx.lineTo(DISPLAY_WIDTH, y * gridSize);
            ctx.stroke();
        }
        // Рисуем препятствия
        obstacles.forEach(obstacle => {
            if (obstacleImage.complete) {
                ctx.drawImage(obstacleImage, obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize);
            } else {
                ctx.fillStyle = '#800080';
                ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize);
            }
        });
        // <<< НАЧАЛО ИЗМЕНЕНИЙ: Зарядка и парковка рисуются ПЕРЕД роботами >>>
        // Рисуем зарядные станции
        chargingStations.forEach((station, index) => {
            // <<< ИЗМЕНЕНО: Зарядные станции ВСЕГДА видны >>>
            // shouldHide всегда false, логика скрытия УДАЛЕНА
            if (chargingImage.complete) {
                ctx.drawImage(chargingImage, station.x * gridSize, station.y * gridSize, gridSize, gridSize);
            } else {
                ctx.fillStyle = '#ff69b4';
                ctx.fillRect(station.x * gridSize, station.y * gridSize, gridSize, gridSize);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(station.x * gridSize, station.y * gridSize, gridSize, gridSize);
            }
            // <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
        });
        // Рисуем еду
        food.forEach(f => {
            let shouldHide = false;
            for (let i = 0; i < snakes.length; i++) {
                const head = snakes[i][0];
                // Скрываем еду, если робот находится на клетке И находится в состоянии "EMPTY"
                if (head.x === f.x && head.y === f.y && !hasCargo[i]) {
                    shouldHide = true;
                    break;
                }
            }
            if (!shouldHide) {
                if (foodImage.complete) {
                    ctx.drawImage(foodImage, f.x * gridSize, f.y * gridSize, gridSize, gridSize);
                } else {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(f.x * gridSize, f.y * gridSize, gridSize, gridSize);
                    ctx.strokeStyle = 'darkred';
                    ctx.strokeRect(f.x * gridSize, f.y * gridSize, gridSize, gridSize);
                }
            }
        });
        // <<< НАЧАЛО ИСПРАВЛЕНИЯ: Сначала рисуем парковки, потом роботов >>>
        // Рисуем парковочные места ПЕРЕД роботами
        parkingSpots.forEach(parking => {
            let showParking = true;
            for (let i = 0; i < snakes.length; i++) {
                const head = snakes[i][0];
                if (head.x === parking.x && head.y === parking.y) {
                    const targetPoint = targetPoints[i];
                    if (targetPoint && targetPoint.x === parking.x && targetPoint.y === parking.y) {
                        showParking = true;
                    } else if (hasCargo[i]) {
                        showParking = false;
                    }
                    break;
                }
            }
            if (showParking) {
                if (parkingImage.complete) {
                    ctx.drawImage(parkingImage, parking.x * gridSize, parking.y * gridSize, gridSize, gridSize);
                } else {
                    ctx.fillStyle = '#0000ff';
                    ctx.fillRect(parking.x * gridSize, parking.y * gridSize, gridSize, gridSize);
                    ctx.strokeStyle = 'black';
                    ctx.strokeRect(parking.x * gridSize, parking.y * gridSize, gridSize, gridSize);
                }
            }
        });
        // Рисуем змеек (роботов) ПОСЛЕ парковок
        snakes.forEach((snake, snakeIndex) => {
            snake.forEach((segment, index) => {
                if (index === 0) {
                    let headImageToUse = snakeHeadImage; // По умолчанию - движение вправо
                    // <<< ИЗМЕНЕНО: Логика выбора изображения УПРОЩЕНА >>>
                    // Если робот имеет груз, используем соответствующее изображение
                    if (hasCargo[snakeIndex]) {
                        // Выбираем изображение в зависимости от последнего горизонтального направления
                        if (lastHorizontalDirection[snakeIndex] === 'left') {
                            headImageToUse = snakeHeadWithShelfImage; // Robot_Shelf.png
                        } else {
                            headImageToUse = snakeHeadWithShelfRightImage; // Robot_Shelf_right.png
                        }
                    } else {
                        // Для робота без груза, выбираем изображение по направлению
                        if (lastHorizontalDirection[snakeIndex] === 'left') {
                            headImageToUse = snakeHeadLeftImage;
                        } else {
                            headImageToUse = snakeHeadImage;
                        }
                    }
                    // <<< ИЗМЕНЕНО: Мигает изображение, а не фон >>>
                    if (!isBlinking[snakeIndex] || (isBlinking[snakeIndex] && Math.floor(Date.now() / 250) % 2 === 0)) {
                        if (headImageToUse.complete) {
                            ctx.drawImage(headImageToUse, segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                        } else {
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                        }
                    }
                    // <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
                } else {
                    ctx.fillStyle = '#00cc00';
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                }
                ctx.strokeStyle = 'rgba(0, 0, 0, 0)';
                ctx.strokeRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
            });
        });
        // <<< КОНЕЦ ИСПРАВЛЕНИЯ >>>
        // Рисуем маршруты
        snakeRoutes.forEach((route, snakeIndex) => {
            if (route.length > 0 && routeProgress[snakeIndex] < route.length) {
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 4;
                ctx.beginPath();
                const head = snakes[snakeIndex][0];
                ctx.moveTo(head.x * gridSize + gridSize/2, head.y * gridSize + gridSize/2);
                for (let i = routeProgress[snakeIndex]; i < route.length; i++) {
                    const point = route[i];
                    ctx.lineTo(point.x * gridSize + gridSize/2, point.y * gridSize + gridSize/2);
                }
                ctx.stroke();
            }
        });
        // Рисуем целевые точки
        targetPoints.forEach((point, index) => {
            if (point) {
                ctx.strokeStyle = 'yellow';
                ctx.strokeRect(point.x * gridSize, point.y * gridSize, gridSize, gridSize);
            }
        });
        // Восстанавливаем состояние контекста
        ctx.restore();
        // Рисуем черный контур вокруг игрового поля
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.strokeRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
    }
    function gameStep() {
        update();
        drawGame();
    }
    function startGame() {
        if (gameRunning) {
            clearInterval(gameInterval);
            clearInterval(gameTimer);
            chargingTimers.forEach(t => t && clearInterval(t));
        }
        initGame();
        gameRunning = true;
        gameStarted = false;
        // Игровые циклы НЕ запускаем здесь. Они запустятся после загрузки.
    }
    canvas.addEventListener('click', handleButtonClick);
    canvas.addEventListener('touchend', function(e) {
      e.preventDefault();
      handleButtonClick(e);
    });
    function handleButtonClick(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      let x, y;
      if (e.type === 'touchend') {
        x = (e.changedTouches[0].clientX - rect.left) * scaleX;
        y = (e.changedTouches[0].clientY - rect.top) * scaleY;
      } else {
        x = (e.clientX - rect.left) * scaleX;
        y = (e.clientY - rect.top) * scaleY;
      }
      const dxPOWER = x - POWER_CENTER_X;
      const dyPOWER = y - POWER_CENTER_Y;
      const distPOWER = Math.sqrt(dxPOWER * dxPOWER + dyPOWER * dyPOWER);
      const dxRST = x - RST_CENTER_X;
      const dyRST = y - RST_CENTER_Y;
      const distRST = Math.sqrt(dxRST * dxRST + dyRST * dyRST);
      const dxPRG = x - PRG_CENTER_X;
      const dyPRG = y - PRG_CENTER_Y;
      const distPRG = Math.sqrt(dxPRG * dxPRG + dyPRG * dyPRG);
      // Обрабатываем ТОЛЬКО POWER, если GODMODE финализирован, но экран завершения еще НЕ активен.
      if (isGodmodeFinalized && !isGameOverScreenActive) {
        if (x >= POWER_X && x <= POWER_X + POWER_WIDTH && y >= POWER_Y && y <= POWER_Y + POWER_BUTTON_HEIGHT) {
          isPowerOn = !isPowerOn;
          if (!isPowerOn) {
            resetAll();
          } else {
            // lastTickTime = performance.now(); ← УДАЛЕНО
            lastCounterTick = performance.now();
            lastChargeTick = performance.now();
            bootActive = true;
            bootCompleted = false;
            bootLineIndex = 0;
            bootCharIndex = 0;
            lastBootTick = performance.now();
            systemsActive = false;
            robotCharge = 100;
            prgPressCount = 0;
            godmodeActive = false;
            passwordMode = false;
            inputCode = [];
            errorMode = false;
            errorCompleted = false;
            godmodeSuccess = false;
            godmodeDisplayCompleted = false;
            isGodmodeFinalized = false;
          }
        }
        return;
      }
      // Обрабатываем ТОЛЬКО POWER, если произошла ошибка.
      if (errorCompleted) {
        if (x >= POWER_X && x <= POWER_X + POWER_WIDTH && y >= POWER_Y && y <= POWER_Y + POWER_BUTTON_HEIGHT) {
          isPowerOn = !isPowerOn;
          if (!isPowerOn) {
            resetAll();
          } else {
            // lastTickTime = performance.now(); ← УДАЛЕНО
            lastCounterTick = performance.now();
            lastChargeTick = performance.now();
            bootActive = true;
            bootCompleted = false;
            bootLineIndex = 0;
            bootCharIndex = 0;
            lastBootTick = performance.now();
            systemsActive = false;
            robotCharge = 100;
            prgPressCount = 0;
            godmodeActive = false;
            passwordMode = false;
            inputCode = [];
            errorMode = false;
            errorCompleted = false;
            godmodeSuccess = false;
            godmodeDisplayCompleted = false;
            isGodmodeFinalized = false;
          }
        }
        return;
      }
      // Обработка ввода кода
      if (godmodeActive && !passwordMode && !errorMode && !godmodeSuccess) {
        handleKeypadClick(x, y);
        return;
      }
      // Обычная логика кнопок
      if (x >= POWER_X && x <= POWER_X + POWER_WIDTH && y >= POWER_Y && y <= POWER_Y + POWER_BUTTON_HEIGHT) {
        isPowerOn = !isPowerOn;
        if (!isPowerOn) {
          resetAll();
          // ОБНУЛЯЕМ localStorage ПРИ ВЫКЛЮЧЕНИИ
          localStorage.removeItem('robotGameHighScores');
        } else {
          // lastTickTime = performance.now(); ← УДАЛЕНО
          lastCounterTick = performance.now();
          lastChargeTick = performance.now();
          bootActive = true;
          bootCompleted = false;
          bootLineIndex = 0;
          bootCharIndex = 0;
          lastBootTick = performance.now();
          systemsActive = false;
          robotCharge = 100;
          prgPressCount = 0;
          godmodeActive = false;
          passwordMode = false;
          inputCode = [];
          errorMode = false;
          errorCompleted = false;
          godmodeSuccess = false;
          godmodeDisplayCompleted = false;
          isGodmodeFinalized = false;
          isGameOverScreenActive = false;
          startGame(); // ← Запускаем игру при включении питания
        }
      } else if (distRST <= SMALL_BUTTON_SIZE / 2 && isPowerOn && !godmodeActive && !isGodmodeFinalized && !errorCompleted) {
        // <<< ВОССТАНОВЛЕНА АНИМАЦИЯ НАЖАТИЯ >>>
        isRSTPressed = true;
        setTimeout(function() { isRSTPressed = false; }, 200);
        if (isGameOverScreenActive) {
            // Если активен экран завершения, полностью перезапускаем игру
            isGameOverScreenActive = false;
            resetAll();
            startGame();
        } else {
            // Обычный сброс
            initGame();
            gameStarted = false;
            // СБРАСЫВАЕМ ТАЙМЕР СТРОГО НА 3:00
            // timerSeconds = 180; ← УДАЛЕНО
            timeLeft = 180;
            // ОБНУЛЯЕМ localStorage ПРИ СБРОСЕ
            localStorage.removeItem('robotGameHighScores');
        }
      } else if (distPRG <= SMALL_BUTTON_SIZE / 2 && isPowerOn && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
        // <<< ВОССТАНОВЛЕНА АНИМАЦИЯ НАЖАТИЯ >>>
        isPRGPressed = true;
        setTimeout(function() { isPRGPressed = false; }, 200);
        prgPressCount++;
        if (prgPressCount >= 10) {
          activateGodmode();
        }
      } else {
        // Обработка кликов по игровому полю
        if (isPowerOn && systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
          const clickX = Math.floor((x - DISPLAY_X) / gridSize);
          const clickY = Math.floor((y - DISPLAY_Y) / gridSize);
          if (clickX >= 0 && clickX < gridWidth && clickY >= 0 && clickY < gridHeight) {
            if (!gameStarted) {
              for (let i = 0; i < snakes.length; i++) {
                const head = snakes[i][0];
                if (head.x === clickX && head.y === clickY) {
                  selectedSnakeIndex = i;
                  activeRobotIndex = i;
                  const head = snakes[i][0];
                  const targetKey = `${clickX},${clickY}`;
                  if (reservedTargets[targetKey] !== undefined && reservedTargets[targetKey] !== i) {
                    return;
                  }
                  if (targetPoints[i]) {
                    const oldKey = `${targetPoints[i].x},${targetPoints[i].y}`;
                    if (reservedTargets[oldKey] === i) delete reservedTargets[oldKey];
                  }
                  snakeRoutes[i] = buildRoute(head.x, head.y, clickX, clickY, i);
                  routeProgress[i] = 0;
                  targetPoints[i] = {x: clickX, y: clickY};
                  reservedTargets[targetKey] = i;
                  snakeRouteTimestamps[i] = Date.now();
                  isBlinking[i] = false;
                  gameStarted = true;
                  return;
                }
              }
              return;
            }
            for (let i = 0; i < snakes.length; i++) {
              const head = snakes[i][0];
              if (head.x === clickX && head.y === clickY) {
                selectedSnakeIndex = i;
                activeRobotIndex = i;
                isBlinking = [false, false, false];
                isBlinking[i] = true;
                return;
              }
            }
            if (selectedSnakeIndex !== -1) {
              if (isObstacle(clickX, clickY)) return;
              const stationIndex = isChargingStation(clickX, clickY);
              if (stationIndex !== -1) {
                if (hasCargo[selectedSnakeIndex]) return;
                const head = snakes[selectedSnakeIndex][0];
                const targetKey = `${clickX},${clickY}`;
                if (reservedTargets[targetKey] !== undefined && reservedTargets[targetKey] !== selectedSnakeIndex) {
                  return;
                }
                if (targetPoints[selectedSnakeIndex]) {
                  const oldKey = `${targetPoints[selectedSnakeIndex].x},${targetPoints[selectedSnakeIndex].y}`;
                  if (reservedTargets[oldKey] === selectedSnakeIndex) delete reservedTargets[oldKey];
                }
                snakeRoutes[selectedSnakeIndex] = buildRoute(head.x, head.y, clickX, clickY, selectedSnakeIndex);
                routeProgress[selectedSnakeIndex] = 0;
                targetPoints[selectedSnakeIndex] = {x: clickX, y: clickY};
                reservedTargets[targetKey] = selectedSnakeIndex;
                snakeRouteTimestamps[selectedSnakeIndex] = Date.now();
                isBlinking[selectedSnakeIndex] = false;
              } else {
                let isFood = food.some(f => f.x === clickX && f.y === clickY);
                if (isFood && hasCargo[selectedSnakeIndex]) return;
                const head = snakes[selectedSnakeIndex][0];
                const targetKey = `${clickX},${clickY}`;
                if (reservedTargets[targetKey] !== undefined && reservedTargets[targetKey] !== selectedSnakeIndex) {
                  return;
                }
                if (targetPoints[selectedSnakeIndex]) {
                  const oldKey = `${targetPoints[selectedSnakeIndex].x},${targetPoints[selectedSnakeIndex].y}`;
                  if (reservedTargets[oldKey] === selectedSnakeIndex) delete reservedTargets[oldKey];
                }
                snakeRoutes[selectedSnakeIndex] = buildRoute(head.x, head.y, clickX, clickY, selectedSnakeIndex);
                routeProgress[selectedSnakeIndex] = 0;
                targetPoints[selectedSnakeIndex] = {x: clickX, y: clickY};
                reservedTargets[targetKey] = selectedSnakeIndex;
                snakeRouteTimestamps[selectedSnakeIndex] = Date.now();
                isBlinking[selectedSnakeIndex] = false;
              }
            }
          }
        } else if (isGameOverScreenActive) {
          // ОБРАБОТКА НАЖАТИЯ НА КНОПКУ SAVE
          const saveButtonX = DISPLAY_X + 100;
          const saveButtonY = DISPLAY_Y + 300;
          const saveButtonWidth = 200;
          const saveButtonHeight = 60;
          if (x >= saveButtonX && x <= saveButtonX + saveButtonWidth &&
              y >= saveButtonY && y <= saveButtonY + saveButtonHeight) {
            // Сохраняем очки в localStorage
            let highScores = JSON.parse(localStorage.getItem('robotGameHighScores') || '[]');
            highScores.push({
                score: counterValue,
                timestamp: new Date().toISOString()
            });
            localStorage.setItem('robotGameHighScores', JSON.stringify(highScores));
            alert('Ваш результат сохранен!');
            // === ОТПРАВКА ОЧКОВ В TELEGRAM БОТ ===
            if (window.Telegram && window.Telegram.WebApp) {
              const resultData = {
                action: "save_score",
                score: counterValue,
                timestamp: new Date().toISOString()
              };
              window.Telegram.WebApp.sendData(JSON.stringify(resultData));
              alert('✅ Ваши очки сохранены!');
            } else {
              alert('⚠️ Игра запущена не в Telegram. Очки сохранены локально.');
            }

            // ПЕРЕЗАПУСКАЕМ ИГРУ ПОСЛЕ СОХРАНЕНИЯ
            isGameOverScreenActive = false;
            resetAll();
            isPowerOn = true;
            // lastTickTime = performance.now(); ← УДАЛЕНО
            lastCounterTick = performance.now();
            lastChargeTick = performance.now();
            bootActive = true;
            bootCompleted = false;
            bootLineIndex = 0;
            bootCharIndex = 0;
            lastBootTick = performance.now();
            systemsActive = false;
            robotCharge = 100;
            prgPressCount = 0;
            godmodeActive = false;
            passwordMode = false;
            inputCode = [];
            errorMode = false;
            errorCompleted = false;
            godmodeSuccess = false;
            godmodeDisplayCompleted = false;
            isGodmodeFinalized = false;
            startGame();
          }
        }
      }
    }
    function handleKeypadClick(x, y) {
      if (passwordMode || errorMode || godmodeSuccess) return;
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
          const digit = row * 3 + col + 1;
          const keyX = KEYPAD_START_X + col * (KEYPAD_SIZE + KEYPAD_GAP);
          const keyY = KEYPAD_START_Y + row * (KEYPAD_SIZE + KEYPAD_GAP);
          if (x >= keyX && x <= keyX + KEYPAD_SIZE &&
              y >= keyY && y <= keyY + KEYPAD_SIZE) {
            if (inputCode.length < 3) {
              inputCode.push(digit);
            }
            pressedKey = digit;
            setTimeout(() => pressedKey = null, 100);
            return;
          }
        }
      }
      const zeroX = KEYPAD_START_X + 1 * (KEYPAD_SIZE + KEYPAD_GAP);
      const zeroY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      if (x >= zeroX && x <= zeroX + KEYPAD_SIZE &&
          y >= zeroY && y <= zeroY + KEYPAD_SIZE) {
        if (inputCode.length < 3) {
          inputCode.push(0);
        }
        pressedKey = 0;
        setTimeout(() => pressedKey = null, 100);
        return;
      }
      const delX = KEYPAD_START_X + 0 * (KEYPAD_SIZE + KEYPAD_GAP);
      const delY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      if (x >= delX && x <= delX + KEYPAD_SIZE &&
          y >= delY && y <= delY + KEYPAD_SIZE) {
        if (inputCode.length > 0) {
          inputCode.pop();
        }
        pressedKey = 'DEL';
        setTimeout(() => pressedKey = null, 100);
        return;
      }
      const starX = KEYPAD_START_X + 2 * (KEYPAD_SIZE + KEYPAD_GAP);
      const starY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      if (x >= starX && x <= starX + KEYPAD_SIZE &&
          y >= starY && y <= starY + KEYPAD_SIZE) {
        checkPassword();
        pressedKey = '*';
        setTimeout(() => pressedKey = null, 100);
        return;
      }
    }
    function activateGodmode() {
      godmodeActive = true;
      passwordMode = true;
      inputCode = [];
      passwordLineIndex = 0;
      passwordCharIndex = 0;
      lastPasswordTick = performance.now();
      systemsActive = false;
      errorMode = false;
      errorCompleted = false;
      godmodeSuccess = false;
      godmodeDisplayCompleted = false;
      isGodmodeFinalized = false;
    }
    function checkPassword() {
      passwordMode = false;
      if (inputCode[0] === 6 && inputCode[1] === 6 && inputCode[2] === 6) {
        counterValue = 999;
        godmodeSuccess = true;
        godmodeDisplayLineIndex = 0;
        godmodeDisplayCharIndex = 0;
        lastGodmodeDisplayTick = performance.now();
        godmodeDisplayCompleted = false;
        // ПОКАЗЫВАЕМ ЭКРАН ЗАВЕРШЕНИЯ СРАЗУ
        isGameOverScreenActive = true;
        systemsActive = false;
      } else {
        // <<< ИЗМЕНЕНО: Только активируем режим ошибки, НЕ выключаем питание >>>
        errorMode = true;
        errorLineIndex = 0;
        errorCharIndex = 0;
        lastErrorTick = performance.now();
        errorCompleted = false;
        // <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
      }
      inputCode = [];
    }
    function resetAll() {
      // timerSeconds = 180; ← УДАЛЕНО
      counterValue = 0;
      animatingDigit = null;
      isRSTPressed = false;
      isPRGPressed = false;
      robotCharge = 100;
      bootActive = false;
      bootCompleted = false;
      bootLineIndex = 0;
      bootCharIndex = 0;
      systemsActive = false;
      prgPressCount = 0;
      godmodeActive = false;
      passwordMode = false;
      inputCode = [];
      errorMode = false;
      errorCompleted = false;
      godmodeSuccess = false;
      godmodeDisplayCompleted = false;
      isGodmodeFinalized = false;
      isGameOverScreenActive = false;
      // Сбрасываем игру
      if (gameRunning) {
        if (gameInterval) clearInterval(gameInterval);
        if (gameTimer) clearInterval(gameTimer);
        chargingTimers.forEach(t => t && clearInterval(t));
        gameRunning = false;
        gameStarted = false;
      }
    }
    // <<< НОВАЯ ФУНКЦИЯ ДЛЯ ОТРИСОВКИ КНОПОК С КРУТЫМ 3D И ТЕНЯМИ >>>
    function drawModernButton3D(x, y, width, height, isPressed, baseColor, pressedColor, text, isActive) {
        // Определяем цвет кнопки
        let buttonColor = isPressed && isActive ? pressedColor : baseColor;
        let textColor = '#000'; // Черный текст
        // Очищаем тени
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        // Рисуем основной прямоугольник кнопки
        ctx.beginPath();
        roundRect(ctx, x, y, width, height, 8); // Скругление 8px
        ctx.fillStyle = buttonColor;
        ctx.fill();
        // Рисуем верхнюю тень (светлый блик) для эффекта выступа
        if (!isPressed) {
            ctx.beginPath();
            ctx.moveTo(x + 2, y + 2);
            ctx.lineTo(x + width - 2, y + 2);
            ctx.quadraticCurveTo(x + width, y, x + width - 2, y + 2);
            ctx.lineTo(x + 2, y + 2);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fill();
        }
        // Рисуем нижнюю тень (темная полоса) для эффекта выступа
        if (!isPressed) {
            ctx.beginPath();
            ctx.moveTo(x + 2, y + height - 2);
            ctx.lineTo(x + width - 2, y + height - 2);
            ctx.quadraticCurveTo(x + width, y + height, x + width - 2, y + height - 2);
            ctx.lineTo(x + 2, y + height - 2);
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fill();
        }
        // Рисуем контур
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Рисуем текст
        ctx.fillStyle = textColor;
        if (width === POWER_WIDTH) {
            // Для POWER увеличиваем шрифт
            ctx.font = 'bold 18px "Courier New", monospace';
        } else {
            ctx.font = 'bold 14px "Courier New", monospace';
        }
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, x + width / 2, y + height / 2);
    }
    // <<< ПОЛНОСТЬЮ ПЕРЕДЕЛАННАЯ ФУНКЦИЯ ДЛЯ POWER BUTTON >>>
    function drawPowerButton() {
        // Сохраняем текущее состояние стиля
        const originalFillStyle = ctx.fillStyle;
        const originalStrokeStyle = ctx.strokeStyle;
        const originalLineWidth = ctx.lineWidth;
        const originalShadowColor = ctx.shadowColor;
        const originalShadowBlur = ctx.shadowBlur;
        const originalShadowOffsetX = ctx.shadowOffsetX;
        const originalShadowOffsetY = ctx.shadowOffsetY;
        const originalLineCap = ctx.lineCap;
        // Определяем, в каком состоянии находится кнопка
        const isPressedState = isPowerOn; // Если включена, то вдавлена
        // Рисуем прямоугольник кнопки
        ctx.beginPath();
        roundRect(ctx, POWER_X, POWER_Y, POWER_WIDTH, POWER_BUTTON_HEIGHT, 8);
        ctx.closePath();
        // Применяем градиент
        const gradient = ctx.createLinearGradient(POWER_X, POWER_Y, POWER_X + POWER_WIDTH, POWER_Y + POWER_BUTTON_HEIGHT);
        gradient.addColorStop(0, isPressedState ? '#dd0000' : '#ff3030');
        gradient.addColorStop(0.5, isPressedState ? '#cc0000' : '#ff0000');
        gradient.addColorStop(1, isPressedState ? '#bb0000' : '#cc0000');
        ctx.fillStyle = gradient;
        ctx.fill();
        // Применяем тени в зависимости от состояния
        if (!isPressedState) {
            // Состояние "не нажата" - сильная тень снизу
            ctx.shadowColor = 'rgba(153, 0, 0, 0.8)'; // Темно-красная тень
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 8;
            ctx.stroke(); // Рисуем тень
            // Верхний светлый блик
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(POWER_X + 2, POWER_Y + 2, POWER_WIDTH - 4, 4);
            // Нижняя темная полутень
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(POWER_X + 2, POWER_Y + POWER_BUTTON_HEIGHT - 6, POWER_WIDTH - 4, 4);
        } else {
            // Состояние "нажата" - слабая тень снизу
            ctx.shadowColor = 'rgba(153, 0, 0, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.stroke(); // Рисуем тень
        }
        // Рисуем контур кнопки
        ctx.strokeStyle = '#990000';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.stroke();
        // Рисуем текст
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 18px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('POWER', POWER_X + POWER_WIDTH / 2, POWER_Y + POWER_BUTTON_HEIGHT / 2);
        // Анимация пульсации для выключенной кнопки
        if (!isPowerOn) {
            const brightness = 0.8 + Math.sin(powerOffBlink * 1.5) * 0.2;
            const r = Math.floor(150 + brightness * 50);
            const g = Math.floor(30 + brightness * 20);
            const b = Math.floor(30 + brightness * 20);
            // Можно применить этот цвет к градиенту, если нужно, но для простоты оставим как есть.
        }
        // Восстанавливаем исходные стили
        ctx.fillStyle = originalFillStyle;
        ctx.strokeStyle = originalStrokeStyle;
        ctx.lineWidth = originalLineWidth;
        ctx.shadowColor = originalShadowColor;
        ctx.shadowBlur = originalShadowBlur;
        ctx.shadowOffsetX = originalShadowOffsetX;
        ctx.shadowOffsetY = originalShadowOffsetY;
        ctx.lineCap = originalLineCap;
    }
    // <<< ПОЛНОСТЬЮ ПЕРЕДЕЛАННАЯ ФУНКЦИЯ ДЛЯ RESET BUTTON (копия POWER) >>>
    function drawRSTButton() {
        // Сохраняем текущее состояние стиля
        const originalFillStyle = ctx.fillStyle;
        const originalStrokeStyle = ctx.strokeStyle;
        const originalLineWidth = ctx.lineWidth;
        const originalShadowColor = ctx.shadowColor;
        const originalShadowBlur = ctx.shadowBlur;
        const originalShadowOffsetX = ctx.shadowOffsetX;
        const originalShadowOffsetY = ctx.shadowOffsetY;
        const originalLineCap = ctx.lineCap;
        // Определяем, в каком состоянии находится кнопка
        const isPressedState = isRSTPressed; // Если нажата, то вдавлена
        // <<< ИЗМЕНЕНО: Добавлена проверка systemsActive и !isGameOverScreenActive >>>
        const isActive = isPowerOn && systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive;
        // Рисуем прямоугольник кнопки
        ctx.beginPath();
        roundRect(ctx, RST_X, RST_Y, SMALL_BUTTON_SIZE, SMALL_BUTTON_SIZE, 8);
        ctx.closePath();
        // Применяем градиент
        const gradient = ctx.createLinearGradient(RST_X, RST_Y, RST_X + SMALL_BUTTON_SIZE, RST_Y + SMALL_BUTTON_SIZE);
        if (isActive) {
            gradient.addColorStop(0, isPressedState ? '#dd0000' : '#ff3030');
            gradient.addColorStop(0.5, isPressedState ? '#cc0000' : '#ff0000');
            gradient.addColorStop(1, isPressedState ? '#bb0000' : '#cc0000');
        } else {
            gradient.addColorStop(0, '#600000');
            gradient.addColorStop(0.5, '#500000');
            gradient.addColorStop(1, '#400000');
        }
        ctx.fillStyle = gradient;
        ctx.fill();
        // Применяем тени в зависимости от состояния
        if (!isPressedState && isActive) {
            // Состояние "не нажата" - сильная тень снизу
            ctx.shadowColor = 'rgba(153, 0, 0, 0.8)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 8;
            ctx.stroke(); // Рисуем тень
            // Верхний светлый блик
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(RST_X + 2, RST_Y + 2, SMALL_BUTTON_SIZE - 4, 4);
            // Нижняя темная полутень
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(RST_X + 2, RST_Y + SMALL_BUTTON_SIZE - 6, SMALL_BUTTON_SIZE - 4, 4);
        } else if (isActive) {
            // Состояние "нажата" - слабая тень снизу
            ctx.shadowColor = 'rgba(153, 0, 0, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.stroke(); // Рисуем тень
        }
        // Рисуем контур кнопки
        ctx.strokeStyle = '#990000';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.stroke();
        // Рисуем текст
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('RESET', RST_X + SMALL_BUTTON_SIZE / 2, RST_Y + SMALL_BUTTON_SIZE / 2);
        // Восстанавливаем исходные стили
        ctx.fillStyle = originalFillStyle;
        ctx.strokeStyle = originalStrokeStyle;
        ctx.lineWidth = originalLineWidth;
        ctx.shadowColor = originalShadowColor;
        ctx.shadowBlur = originalShadowBlur;
        ctx.shadowOffsetX = originalShadowOffsetX;
        ctx.shadowOffsetY = originalShadowOffsetY;
        ctx.lineCap = originalLineCap;
    }
    // <<< ПОЛНОСТЬЮ ПЕРЕДЕЛАННАЯ ФУНКЦИЯ ДЛЯ PROG BUTTON (копия POWER, оранжевая) >>>
    function drawPRGButton() {
        // Сохраняем текущее состояние стиля
        const originalFillStyle = ctx.fillStyle;
        const originalStrokeStyle = ctx.strokeStyle;
        const originalLineWidth = ctx.lineWidth;
        const originalShadowColor = ctx.shadowColor;
        const originalShadowBlur = ctx.shadowBlur;
        const originalShadowOffsetX = ctx.shadowOffsetX;
        const originalShadowOffsetY = ctx.shadowOffsetY;
        const originalLineCap = ctx.lineCap;
        // Определяем, в каком состоянии находится кнопка
        const isPressedState = isPRGPressed; // Если нажата, то вдавлена
        // <<< ИЗМЕНЕНО: Добавлена проверка !isGameOverScreenActive >>>
        const isActive = isPowerOn && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive;
        // Рисуем прямоугольник кнопки
        ctx.beginPath();
        roundRect(ctx, PRG_X, PRG_Y, SMALL_BUTTON_SIZE, SMALL_BUTTON_SIZE, 8);
        ctx.closePath();
        // Применяем градиент
        const gradient = ctx.createLinearGradient(PRG_X, PRG_Y, PRG_X + SMALL_BUTTON_SIZE, PRG_Y + SMALL_BUTTON_SIZE);
        if (isActive) {
            gradient.addColorStop(0, isPressedState ? '#e65c00' : '#ff7c00'); // Темно-оранжевый / Ярко-оранжевый
            gradient.addColorStop(0.5, isPressedState ? '#cc5500' : '#ff6600');
            gradient.addColorStop(1, isPressedState ? '#b34d00' : '#ff5500');
        } else {
            gradient.addColorStop(0, '#600000');
            gradient.addColorStop(0.5, '#500000');
            gradient.addColorStop(1, '#400000');
        }
        ctx.fillStyle = gradient;
        ctx.fill();
        // Применяем тени в зависимости от состояния
        if (!isPressedState && isActive) {
            // Состояние "не нажата" - сильная тень снизу
            ctx.shadowColor = 'rgba(153, 51, 0, 0.8)'; // Темно-оранжевая тень
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 8;
            ctx.stroke(); // Рисуем тень
            // Верхний светлый блик
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(PRG_X + 2, PRG_Y + 2, SMALL_BUTTON_SIZE - 4, 4);
            // Нижняя темная полутень
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(PRG_X + 2, PRG_Y + SMALL_BUTTON_SIZE - 6, SMALL_BUTTON_SIZE - 4, 4);
        } else if (isActive) {
            // Состояние "нажата" - слабая тень снизу
            ctx.shadowColor = 'rgba(153, 51, 0, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.stroke(); // Рисуем тень
        }
        // Рисуем контур кнопки
        ctx.strokeStyle = '#993300'; // Темно-оранжевый контур
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.stroke();
        // Рисуем текст
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('PROG', PRG_X + SMALL_BUTTON_SIZE / 2, PRG_Y + SMALL_BUTTON_SIZE / 2);
        // Восстанавливаем исходные стили
        ctx.fillStyle = originalFillStyle;
        ctx.strokeStyle = originalStrokeStyle;
        ctx.lineWidth = originalLineWidth;
        ctx.shadowColor = originalShadowColor;
        ctx.shadowBlur = originalShadowBlur;
        ctx.shadowOffsetX = originalShadowOffsetX;
        ctx.shadowOffsetY = originalShadowOffsetY;
        ctx.lineCap = originalLineCap;
    }
    // <<< УДАЛЕНЫ ФУНКЦИИ ЛАМПОЧЕК >>>
    // Все функции и переменные, связанные с lampPhases, lampSpeeds, drawLamps, drawLamp — УДАЛЕЕНЫ.
    // <<< ИСПРАВЛЕННАЯ ФУНКЦИЯ drawVoltmeter >>>
    function drawVoltmeter() {
        ctx.fillStyle = '#0a0a0a';
        roundRect(ctx, VOLTMETER_X, VOLTMETER_Y, VOLTMETER_WIDTH, VOLTMETER_HEIGHT, 6);
        ctx.fill();
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        ctx.stroke();
        // ВСЕ ТЕКСТЫ ИЗНАЧАЛЬНО СЕРЫЕ, БЕЛЫЕ ТОЛЬКО ПРИ ВЫБОРЕ РОБОТА
        let textColor = (systemsActive && activeRobotIndex !== -1) ? '#ffffff' : '#666';
        ctx.fillStyle = textColor;
        ctx.font = '12px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('0', VOLTMETER_X + 15, VOLTMETER_Y + VOLTMETER_HEIGHT - 8);
        ctx.fillText('100', VOLTMETER_X + VOLTMETER_WIDTH - 20, VOLTMETER_Y + VOLTMETER_HEIGHT - 8);
        // Определяем текущий заряд
        let currentCharge = systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted ? (activeRobotIndex !== -1 ? snakeCharges[activeRobotIndex] : robotCharge) : robotCharge;
        // Устанавливаем цвет для 'ENERGY'
        let energyColor = textColor; // По умолчанию
        // Применяем мигание ТОЛЬКО при условии низкого заряда
        if (currentCharge < 50 && isPowerOn && systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && activeRobotIndex !== -1) {
            const blinkEnergy = Math.floor(performance.now() / 1000) % 2; // Частота: 1 раз в секунду
            if (blinkEnergy === 0) {
                energyColor = '#666'; // Скрытый
            } else {
                energyColor = '#ffffff'; // Белый
            }
        }
        ctx.fillStyle = energyColor;
        ctx.font = 'bold 16px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ENERGY', VOLTMETER_X + VOLTMETER_WIDTH / 2, VOLTMETER_Y + VOLTMETER_HEIGHT / 2 - 18);
        // Рисуем стрелку
        const pivotX = VOLTMETER_X + VOLTMETER_WIDTH / 2;
        const pivotY = VOLTMETER_Y + VOLTMETER_HEIGHT - 5;
        const angle = -Math.PI * (1 - (currentCharge / 100));
        const needleLength = 30;
        const tipX = pivotX + Math.cos(angle) * needleLength;
        const tipY = pivotY + Math.sin(angle) * needleLength;
        ctx.beginPath();
        ctx.moveTo(pivotX, pivotY);
        ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = '#ff3030';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(pivotX, pivotY, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#ff3030';
        ctx.fill();
    }
    // <<< ИСПРАВЛЕННАЯ ФУНКЦИЯ drawLCDDisplay >>>
    function drawLCDDisplay() {
        ctx.fillStyle = '#0a0a0a';
        roundRect(ctx, LCD_X, LCD_Y, LCD_WIDTH, LCD_HEIGHT, 6);
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();
        let topText = "-----";
        let bottomText = "-----";
        if (systemsActive && isPowerOn && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
            if (activeRobotIndex !== -1) {
                topText = `UNIT${activeRobotIndex + 1}`;
                bottomText = hasCargo[activeRobotIndex] ? "LOAD" : "EMPTY";
            }
        }
        const charWidth = LCD_WIDTH / 5;
        const topY = LCD_Y + 22;
        const bottomY = LCD_Y + 45;
        ctx.fillStyle = '#666';
        ctx.font = 'bold 14px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Новая логика мигания для LCD
        const shouldBlinkLCD = (systemsActive && activeRobotIndex !== -1);
        const blinkLCD = shouldBlinkLCD ? (Math.floor(performance.now() / 1000) % 2) : 0; // Частота: 1 раз в секунду
        // Рисуем верхнюю строку (UNITX)
        for (let i = 0; i < 5; i++) {
            if (i < topText.length && topText !== "-----") {
                if (i < 4) { // Символы 'U', 'N', 'I', 'T'
                    // Всегда белые, не мигают
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(topText[i], LCD_X + charWidth * (i + 0.5), topY);
                } else { // Цифра (например, '1', '2', '3')
                    // Мигает с частотой 1 Гц
                    if (blinkLCD === 0) {
                        ctx.fillStyle = '#ffffff'; // Белый
                    } else {
                        ctx.fillStyle = '#666'; // Скрытый
                    }
                    ctx.fillText(topText[i], LCD_X + charWidth * (i + 0.5), topY);
                }
                ctx.fillStyle = '#666';
            } else {
                ctx.fillText('-', LCD_X + charWidth * (i + 0.5), topY);
            }
        }
        // Рисуем нижнюю строку (LOAD/EMPTY)
        for (let i = 0; i < 5; i++) {
            if (i < bottomText.length && bottomText !== "-----") {
                if (bottomText === "LOAD" && i === 4) {
                    // Для "LOAD" пятая позиция всегда серая и не мигает
                    ctx.fillStyle = '#666';
                    ctx.fillText('-', LCD_X + charWidth * (i + 0.5), bottomY);
                } else {
                    // Остальные символы мигают с частотой 1 Гц
                    if (blinkLCD === 0) {
                        ctx.fillStyle = '#ffffff'; // Белый
                    } else {
                        ctx.fillStyle = '#666'; // Скрытый
                    }
                    ctx.fillText(bottomText[i], LCD_X + charWidth * (i + 0.5), bottomY);
                }
                ctx.fillStyle = '#666';
            } else {
                ctx.fillText('-', LCD_X + charWidth * (i + 0.5), bottomY);
            }
        }
    }
    function draw3DCounter() {
      const now = performance.now();
      if (isPowerOn && systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive && now - lastCounterTick >= 1000) {
        lastCounterTick = now;
        const oldValue = counterValue;
        counterValue = score; // ← Синхронизируем со счетом игры
        const oldHundreds = Math.floor(oldValue / 100) % 10;
        const oldTens = Math.floor(oldValue / 10) % 10;
        const oldUnits = oldValue % 10;
        const newHundreds = Math.floor(counterValue / 100) % 10;
        const newTens = Math.floor(counterValue / 10) % 10;
        const newUnits = counterValue % 10;
        if (newUnits !== oldUnits) {
          animatingDigit = { wheel: 2, from: oldUnits, to: newUnits, progress: 0 };
        }
        if (newTens !== oldTens) {
          animatingDigit = { wheel: 1, from: oldTens, to: newTens, progress: 0 };
        }
        if (newHundreds !== oldHundreds) {
          animatingDigit = { wheel: 0, from: oldHundreds, to: newHundreds, progress: 0 };
        }
      }
      if (animatingDigit && isPowerOn) {
        animatingDigit.progress += 0.04;
        if (animatingDigit.progress >= 1) {
          animatingDigit = null;
        }
      }
      ctx.fillStyle = '#0a0a0a';
      roundRect(ctx, COUNTER_X, COUNTER_Y, COUNTER_WIDTH, COUNTER_HEIGHT, 6);
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.save();
      roundRect(ctx, COUNTER_X, COUNTER_Y, COUNTER_WIDTH, COUNTER_HEIGHT, 6);
      ctx.clip();
      const wheelWidth = COUNTER_WIDTH / 3;
      const digits = [
        Math.floor(counterValue / 100) % 10,
        Math.floor(counterValue / 10) % 10,
        counterValue % 10
      ].map(function(d) {
        return isNaN(d) ? 0 : d;
      });
      for (let i = 0; i < 3; i++) {
        const x = COUNTER_X + i * wheelWidth;
        const y = COUNTER_Y;
        const centerX = x + wheelWidth / 2;
        const centerY = y + COUNTER_HEIGHT / 2;
        if (animatingDigit && animatingDigit.wheel === i) {
          const fromDigit = animatingDigit.from;
          const toDigit = animatingDigit.to;
          const p = animatingDigit.progress;
          draw3DRectAndDigit(fromDigit, centerX, centerY, wheelWidth, COUNTER_HEIGHT, p * Math.PI, true);
          draw3DRectAndDigit(toDigit, centerX, centerY, wheelWidth, COUNTER_HEIGHT, -Math.PI + p * Math.PI, false);
        } else {
          drawStaticRectAndDigit(digits[i], centerX, centerY, wheelWidth, COUNTER_HEIGHT);
        }
      }
      ctx.restore();
    }
    function drawStaticRectAndDigit(digit, centerX, centerY, width, height) {
      const halfHeight = height / 2;
      const rectWidth = width * 0.95;
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(centerX - rectWidth/2, centerY - halfHeight, rectWidth, halfHeight);
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.fillStyle = isPowerOn ? '#ffffff' : '#666'; // ← Заменено на белый
      ctx.font = 'bold 24px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(digit), 0, 0);
      ctx.restore();
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(centerX - rectWidth/2, centerY, rectWidth, halfHeight);
    }
    function draw3DRectAndDigit(digit, centerX, centerY, width, height, rotationAngle, isUpper) {
      const cosA = Math.cos(rotationAngle);
      const sinA = Math.sin(rotationAngle);
      const scale = 0.8 + 0.2 * Math.abs(cosA);
      const yOffset = sinA * height * 0.25;
      ctx.save();
      ctx.translate(centerX, centerY + yOffset);
      ctx.scale(scale, scale);
      const halfHeight = height / 2;
      const rectWidth = width * 0.95;
      if (isUpper) {
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(-rectWidth/2, -halfHeight, rectWidth, halfHeight);
      } else {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(-rectWidth/2, 0, rectWidth, halfHeight);
      }
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.font = 'bold 24px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(digit), 1, 1);
      ctx.fillStyle = isPowerOn ? '#ffffff' : '#666'; // ← Заменено на белый
      ctx.fillText(String(digit), 0, 0);
      if (cosA > 0) {
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(-rectWidth/2, -halfHeight/2, rectWidth, halfHeight/4);
      }
      ctx.restore();
    }
    // <<< ИСПРАВЛЕННАЯ ФУНКЦИЯ drawTimer >>>
    function drawTimer() {
      ctx.fillStyle = '#0a0a0a';
      roundRect(ctx, TIMER_X, TIMER_Y, TIMER_WIDTH, TIMER_HEIGHT, 4);
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.stroke();
      if (isPowerOn) {
        // <<< ИЗМЕНЕНО: Используем timeLeft напрямую, убрана переменная timerSeconds >>>
        const mins = Math.floor(timeLeft / 60);
        const secs = timeLeft % 60;
        const timeText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        let textColor = '#ffffff';
        // Мигание при оставшихся 30 секундах
        if (timeLeft <= 30 && systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
          const blink = Math.floor(performance.now() / 500) % 2;
          textColor = blink === 0 ? '#0a0a0a' : '#ffffff';
        }
        ctx.fillStyle = textColor;
        ctx.font = 'bold 36px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(timeText, TIMER_X + TIMER_WIDTH / 2, TIMER_Y + TIMER_HEIGHT / 2);
        // <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
      } else {
        ctx.fillStyle = '#555';
        ctx.font = 'bold 36px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('--:--', TIMER_X + TIMER_WIDTH / 2, TIMER_Y + TIMER_HEIGHT / 2);
      }
    }
    function drawBootText() {
      if (!bootActive || !isPowerOn || godmodeActive || isGodmodeFinalized || errorCompleted) return;
      if (bootCompleted) return;
      const now = performance.now();
      if (now - lastBootTick >= 80) {
        lastBootTick = now;
        if (bootCharIndex >= bootText[bootLineIndex].length) {
          bootCharIndex = 0;
          bootLineIndex++;
          if (bootLineIndex >= bootText.length) {
            bootCompleted = true;
            systemsActive = true;
            // ЗАПУСКАЕМ ИГРОВЫЕ ЦИКЛЫ ПОСЛЕ ЗАГРУЗКИ
            gameInterval = setInterval(gameStep, 250);
            gameTimer = setInterval(() => {
                timeLeft--;
                // <<< ИЗМЕНЕНО: Экран завершения появляется ТОЛЬКО при 00:00 >>>
                if (timeLeft <= 0) {
                    clearInterval(gameTimer);
                    if (timeLeft === 0) {
                        isGameOverScreenActive = true;
                        systemsActive = false;
                    }
                }
                // <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
            }, 1000);
            // КОНЕЦ ЗАПУСКА
            return;
          }
        } else {
          bootCharIndex++;
        }
      }
      ctx.fillStyle = '#ffffff'; // ← Заменено на белый
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      for (let i = 0; i < bootLineIndex; i++) {
        ctx.fillText(bootText[i], DISPLAY_X + 10, DISPLAY_Y + 20 + i * 20);
      }
      if (bootLineIndex < bootText.length) {
        const currentLine = bootText[bootLineIndex].substring(0, bootCharIndex);
        ctx.fillText(currentLine, DISPLAY_X + 10, DISPLAY_Y + 20 + bootLineIndex * 20);
      }
    }
    function drawPasswordText() {
      if (!godmodeActive || !passwordMode || !isPowerOn || isGodmodeFinalized || errorCompleted) return;
      const now = performance.now();
      if (now - lastPasswordTick >= 80) {
        lastPasswordTick = now;
        if (passwordCharIndex >= passwordText[passwordLineIndex].length) {
          passwordCharIndex = 0;
          passwordLineIndex++;
          if (passwordLineIndex >= passwordText.length) {
            passwordMode = false;
            return;
          }
        } else {
          passwordCharIndex++;
        }
      }
      ctx.fillStyle = '#ffffff'; // ← Заменено на белый
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      for (let i = 0; i < passwordLineIndex; i++) {
        ctx.fillText(passwordText[i], DISPLAY_X + 10, DISPLAY_Y + 20 + i * 20);
      }
      if (passwordLineIndex < passwordText.length) {
        const currentLine = passwordText[passwordLineIndex].substring(0, passwordCharIndex);
        ctx.fillText(currentLine, DISPLAY_X + 10, DISPLAY_Y + 20 + passwordLineIndex * 20);
      }
    }
    function drawInputField() {
      if (!godmodeActive || passwordMode || !isPowerOn || errorMode || godmodeSuccess || isGodmodeFinalized || errorCompleted) return;
      ctx.font = 'bold 48px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const centerX = DISPLAY_X + 200;
      const centerY = DISPLAY_Y + 75;
      for (let i = 0; i < 3; i++) {
        const xPos = centerX - 60 + i * 60;
        if (i < inputCode.length) {
          ctx.fillStyle = '#ffffff'; // ← Заменено на белый
          ctx.fillText(inputCode[i].toString(), xPos, centerY);
        } else {
          ctx.fillStyle = '#666';
          ctx.fillText("-", xPos, centerY);
        }
      }
    }
    function drawKeypad() {
      if (!godmodeActive || passwordMode || !isPowerOn || errorMode || godmodeSuccess || isGodmodeFinalized || errorCompleted) return;
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
          const digit = row * 3 + col + 1;
          const keyX = KEYPAD_START_X + col * (KEYPAD_SIZE + KEYPAD_GAP);
          const keyY = KEYPAD_START_Y + row * (KEYPAD_SIZE + KEYPAD_GAP);
          drawKey(keyX, keyY, String(digit), pressedKey === digit);
        }
      }
      const zeroX = KEYPAD_START_X + 1 * (KEYPAD_SIZE + KEYPAD_GAP);
      const zeroY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      drawKey(zeroX, zeroY, "0", pressedKey === 0);
      const delX = KEYPAD_START_X + 0 * (KEYPAD_SIZE + KEYPAD_GAP);
      const delY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      drawKey(delX, delY, "DEL", pressedKey === 'DEL');
      const starX = KEYPAD_START_X + 2 * (KEYPAD_SIZE + KEYPAD_GAP);
      const starY = KEYPAD_START_Y + 3 * (KEYPAD_SIZE + KEYPAD_GAP);
      drawKey(starX, starY, "*", pressedKey === '*');
    }
    function drawKey(x, y, label, isPressed) {
        // Используем серый цвет вместо зеленого
        ctx.fillStyle = isPressed ? '#aaaaaa' : '#333333';
        roundRect(ctx, x, y, KEYPAD_SIZE, KEYPAD_SIZE, 8);
        ctx.fill();
        ctx.strokeStyle = '#666666'; // Серый контур
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#ffffff'; // Белый текст
        ctx.font = 'bold 24px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x + KEYPAD_SIZE/2, y + KEYPAD_SIZE/2);
    }
    function drawGodmodeDisplay() {
      if (!godmodeSuccess || !isPowerOn || isGodmodeFinalized || errorCompleted) return;
      const now = performance.now();
      if (now - lastGodmodeDisplayTick >= 80) {
        lastGodmodeDisplayTick = now;
        if (godmodeDisplayCharIndex >= godmodeDisplayText[godmodeDisplayLineIndex].length) {
          godmodeDisplayCompleted = true;
          // Активируем финализацию GODMODE
          isGodmodeFinalized = true;
          // Активируем экран завершения игры ТОЛЬКО ПОСЛЕ ЗАВЕРШЕНИЯ АНИМАЦИИ ТЕКСТА
          isGameOverScreenActive = true;
          return;
        } else {
          godmodeDisplayCharIndex++;
        }
      }
      // Рисуем черный фон для GODMODE
      ctx.fillStyle = 'black';
      ctx.fillRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
      // Рисуем текст
      ctx.fillStyle = '#ffffff'; // ← Заменено на белый
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      const currentLine = godmodeDisplayText[godmodeDisplayLineIndex].substring(0, godmodeDisplayCharIndex);
      ctx.fillText(currentLine, DISPLAY_X + 10, DISPLAY_Y + 20);
    }
    function drawErrorText() {
      if (!errorMode || !isPowerOn || errorCompleted || isGodmodeFinalized) return;
      const now = performance.now();
      if (now - lastErrorTick >= 80) {
        lastErrorTick = now;
        if (errorCharIndex >= errorText[errorLineIndex].length) {
          errorCharIndex = 0;
          errorLineIndex++;
          if (errorLineIndex >= errorText.length) {
            errorCompleted = true;
            // <<< ИЗМЕНЕНО: Выключаем питание и сбрасываем всё ТОЛЬКО ПОСЛЕ ЗАВЕРШЕНИЯ АНИМАЦИИ >>>
            isPowerOn = false;
            resetAll();
            // <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
            return;
          }
        } else {
          errorCharIndex++;
        }
      }
      ctx.fillStyle = '#ffffff'; // ← Заменено на белый
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      for (let i = 0; i < errorLineIndex; i++) {
        ctx.fillText(errorText[i], DISPLAY_X + 10, DISPLAY_Y + 20 + i * 20);
      }
      if (errorLineIndex < errorText.length) {
        const currentLine = errorText[errorLineIndex].substring(0, errorCharIndex);
        ctx.fillText(currentLine, DISPLAY_X + 10, DISPLAY_Y + 20 + errorLineIndex * 20);
      }
    }
    // <<< ИЗМЕНЕННАЯ ФУНКЦИЯ drawGlowBorder: Свечение ТОЛЬКО НАРУЖУ, НАЧИНАЕТСЯ ЗА ЧЕРНОЙ РАМКОЙ >>>
    function drawGlowBorder() {
        // Рисуем только если панель включена
        if (!isPowerOn || errorCompleted) return;
        // Создаем пульсирующий коэффициент для свечения
        const pulse = 0.7 + 0.3 * Math.sin(performance.now() / 800);
        // Сохраняем текущее состояние контекста
        ctx.save();
        // === ЭФФЕКТ НАРУЖНОГО СВЕЧЕНИЯ ===
        ctx.shadowColor = `rgba(255, 255, 255, ${0.4 * pulse})`;
        ctx.shadowBlur = 30;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        // Рисуем невидимые контуры для создания внешнего свечения
        ctx.strokeStyle = 'transparent';
        ctx.lineWidth = 2;
        // <<< ИЗМЕНЕНО: Свечение начинается ЗА черной рамкой >>>
        ctx.strokeRect(
            DISPLAY_X - 1,
            DISPLAY_Y - 1,
            DISPLAY_WIDTH + 2,
            DISPLAY_HEIGHT + 2
        );
        // <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
        roundRect(ctx, VOLTMETER_X, VOLTMETER_Y, VOLTMETER_WIDTH, VOLTMETER_HEIGHT, 6);
        ctx.stroke();
        roundRect(ctx, LCD_X, LCD_Y, LCD_WIDTH, LCD_HEIGHT, 6);
        ctx.stroke();
        roundRect(ctx, TIMER_X, TIMER_Y, TIMER_WIDTH, TIMER_HEIGHT, 4);
        ctx.stroke();
        // === ЭФФЕКТ ВНУТРЕННЕЙ ТЕНИ (СВЕЧЕНИЕ ВНУТРЬ) ===
        // <<< УДАЛЕНО: Весь блок внутреннего свечения >>>
        // if (systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
        //     ctx.shadowColor = `rgba(255, 255, 255, ${0.3 * pulse})`;
        //     ctx.shadowBlur = 20;
        //     ctx.shadowOffsetX = 0;
        //     ctx.shadowOffsetY = 0;
        //     ctx.fillRect(DISPLAY_X + 2, DISPLAY_Y + 2, DISPLAY_WIDTH - 4, DISPLAY_HEIGHT - 4);
        // }
        // <<< КОНЕЦ УДАЛЕНИЯ >>>
        // Восстанавливаем состояние контекста (отключаем тень)
        ctx.restore();
        // === ЧЕТКИЙ КОНТУР ===
        ctx.lineWidth = 2;
        // Рисуем контур игрового поля
        if (systemsActive && !godmodeActive && !isGodmodeFinalized && !errorCompleted && !isGameOverScreenActive) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.strokeRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
        } else {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.strokeRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
        }
        // Рисуем контуры остальных панелей
        roundRect(ctx, VOLTMETER_X, VOLTMETER_Y, VOLTMETER_WIDTH, VOLTMETER_HEIGHT, 6);
        ctx.stroke();
        roundRect(ctx, LCD_X, LCD_Y, LCD_WIDTH, LCD_HEIGHT, 6);
        ctx.stroke();
        roundRect(ctx, TIMER_X, TIMER_Y, TIMER_WIDTH, TIMER_HEIGHT, 4);
        ctx.stroke();
    }
    // <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
    function drawGameOverScreen() {
        // Рисуем черный фон экрана завершения
        ctx.fillStyle = 'black';
        ctx.fillRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
        // Рисуем текст результата
        ctx.fillStyle = '#ffffff'; // ← Заменено на белый
        ctx.font = 'bold 36px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`СЧЕТ: ${counterValue}`, DISPLAY_X + 200, DISPLAY_Y + 150);
        // Рисуем кнопку SAVE
        const saveButtonX = DISPLAY_X + 100;
        const saveButtonY = DISPLAY_Y + 300;
        const saveButtonWidth = 200;
        const saveButtonHeight = 60;
        ctx.fillStyle = '#ffffff'; // ← Заменено на белый
        roundRect(ctx, saveButtonX, saveButtonY, saveButtonWidth, saveButtonHeight, 8);
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'black';
        ctx.font = 'bold 24px "Courier New", monospace';
        ctx.fillText('SAVE', saveButtonX + saveButtonWidth / 2, saveButtonY + saveButtonHeight / 2);
    }
    function drawRonaviText() {
      ctx.fillStyle = '#000'; // Черный цвет
      ctx.font = 'bold 30px "NexaBold", Arial, sans-serif';
      ctx.textAlign = 'center'; // Выравнивание по центру
      ctx.textBaseline = 'bottom'; // Базовая линия — низ текста
      ctx.fillText('RONAVI', GAME_WIDTH / 2, GAME_HEIGHT - 20); // По центру по X, 20px от низа по Y
    }
    function gameLoop() {
      ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      if (!isPowerOn) {
        powerOffBlink += 0.05;
      }
      // Очищаем фон дисплея только если игра не активна
      if (!systemsActive || errorCompleted || isGodmodeFinalized) {
          ctx.fillStyle = '#000';
          ctx.fillRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
      }
      // Рисуем игровое поле
      if (systemsActive && !errorCompleted && !isGodmodeFinalized && !isGameOverScreenActive) {
        drawGame();
      }
      // РИСУЕМ ЭКРАН ЗАВЕРШЕНИЯ ИГРЫ
      if (isGameOverScreenActive) {
        drawGameOverScreen();
      }
      // Рисуем UI-элементы панели
      drawLCDDisplay();
      drawVoltmeter();
      draw3DCounter();
      drawTimer();
      drawPowerButton();
      // <<< УДАЛЕНО: drawLamps() >>>
      drawRSTButton();
      drawPRGButton();
      drawGlowBorder();
      drawBootText();
      if (godmodeActive) {
        drawPasswordText();
        drawInputField();
        drawKeypad();
        drawErrorText();
        drawGodmodeDisplay();
      }
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.strokeRect(DISPLAY_X, DISPLAY_Y, DISPLAY_WIDTH, DISPLAY_HEIGHT);
      drawRonaviText();
      requestAnimationFrame(gameLoop);
    }
    function roundRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }
    window.addEventListener('load', function() {
      setTimeout(gameLoop, 100);
    });
  </script>
</body>
</html>
