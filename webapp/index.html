<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Логистические роботы</title>
    <style>
        /* style.css */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box; /* Учитываем padding и border в размерах */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }

        /* --- ФОН ВОКРУГ ПОЛЯ ЧЁРНЫЙ --- */
        body {
            font-family: 'Arial', sans-serif;
            /* background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%); */
            background: black; /* Изменён фон body на чёрный */
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Выравнивание сверху, а не по центру */
            overflow: hidden; /* Запрещаем прокрутку body */
            touch-action: manipulation;
        }

        .container {
            background: black; /* Изменён фон контейнера на чёрный */
            /* border-radius: 12px; */
            border-radius: 0; /* Убираем скругление углов контейнера */
            padding: 8px; /* Уменьшено padding */
            /* box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); */
            box-shadow: none; /* Убираем тень */
            text-align: center;
            width: 100vw; /* Занимает всю ширину экрана */
            max-width: 100%; /* Но не больше 100% */
            max-height: 100vh; /* Ограничиваем высоту контейнера */
            margin: 4px 0; /* Отступы сверху/снизу, 0 по бокам */
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* Скрываем переполнение внутри контейнера */
        }

        .stats-container {
            display: flex;
            justify-content: space-between;
            /* --- УВЕЛИЧЕНИЕ --- */
            margin-bottom: 10px;
            padding: 0 6px;
            gap: 8px;
            width: 100%;
            max-width: 550px; /* Увеличена максимальная ширина */
        }

        .stat-item {
            background: #ecf0f1;
            /* --- УВЕЛИЧЕНИЕ --- */
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: bold;
            /* --- УВЕЛИЧЕНИЕ --- */
            font-size: min(0.9em, 4vw);
            flex: 1;
            min-width: 0;
            white-space: nowrap; /* Предотвращает перенос текста */
            overflow: hidden;
            text-overflow: ellipsis; /* Добавляет многоточие при переполнении */
             /* Центрирование текста */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 1px; /* Минимальный padding */
            overflow: hidden; /* Важно: скрывает переполнение */
        }

        /* Ключевое изменение для размеров поля */
        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(13, 1fr);
            gap: 1px;
            /* Используем clamp для более точного контроля */
            width: min(94vw, 94vh * (10/13), 480px); /* Ширина: 94vw или пропорциональная высота, максимум 480px */
            height: min(94vh, 94vw * (13/10), 624px); /* Высота: 94vh или пропорциональная ширина, максимум 624px (13/10 * 480) */
            max-width: 100%; /* Дополнительная страховка */
            max-height: 100%; /* Дополнительная страховка */
            border: 2px solid #34495e;
            background: #bdc3c7;
            position: relative;
            overflow: hidden; /* Скрывает переполнение содержимого поля */
            aspect-ratio: 10 / 13; /* Сохраняет пропорции 10x13 */
        }


        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            /* Адаптивный размер шрифта, связанный с размером поля */
            font-size: calc(min(94vw, 94vh * (10/13), 480px) / 10 * 0.4);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease; /* Ускорена анимация */
            position: relative;
            border-radius: 1px; /* Уменьшен радиус */
            /* aspect-ratio управляется grid */
            background: #ecf0f1; /* Фон по умолчанию */
            background-size: cover; /* Растягиваем изображения до границ клеток */
            background-position: center; /* Центрируем изображения */
            background-repeat: no-repeat; /* Не повторяем изображения */
        }

        .cell:hover {
             transform: scale(0.95); /* Легкое сжатие вместо увеличения */
             opacity: 0.9; /* Немного прозрачности */
             z-index: 2;
        }

        /* Цвета клеток */
        .start { background: #ecf0f1; color: #2c3e50; }
        .finish { background: #27ae60; color: white; }
        .charging { background: #f39c12; color: white; }
        .loading { background: #9b59b6; color: white; }

        /* --- ВОЗВРАЩЕН ФОН ДЛЯ СТЕН И СТОЛБОВ --- */
        .obstacle, .wall {
            /* Создаем диагональные полосы под углом 45 градусов */
            background-image:
                repeating-linear-gradient(
                    45deg,
                    #000 0%,
                    #000 10%,
                    #ffff00 10%,
                    #ffff00 20%
                );
            color: white; /* Цвет текста, если он есть */
        }

        .robot {
            background: linear-gradient(45deg, #ffeb3b, #ffc107);
            color: #000;
            font-weight: bold;
            z-index: 3;
            transition: all 0.2s ease;
        }
        .path {
            background: #f1c40f;
            color: #2c3e50;
            font-weight: bold;
        }
        .empty { background: #ecf0f1; }

        /* Стили для изображений */
        .parking {
            background-image: url('Parking.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .column {
            background-image: url('Column.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .charging-station {
            background-image: url('Charging.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .shelf {
            background-image: url('Shelf.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .robot-cell {
            background-image: url('Robot.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
        }

        .robot-shelf {
            background-image: url('Robot_Shelf.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* Полоса заряда робота */
        .charge-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background-color: #ccc;
        }

        .charge-level {
            height: 100%;
            transition: width 0.3s ease;
        }

        /* Цвета полосы заряда */
        .charge-level.low { background-color: #e74c3c; }    /* 0-25% - красный */
        .charge-level.medium { background-color: #f39c12; } /* 25-50% - оранжевый */
        .charge-level.good { background-color: #f1c40f; }   /* 50-75% - желтый */
        .charge-level.high { background-color: #27ae60; }   /* 75-100% - зеленый */

        /* Подсветка возможных перемещений */
        .possible-move {
            position: relative;
            overflow: hidden;
        }

        .border-highlight {
            position: absolute;
            background: black;
        }

        .moving-part {
            position: absolute;
            background: yellow;
        }

        /* Траектория движения */
        .trajectory {
            position: absolute;
            background: red;
            z-index: 5;
        }

        .moving-cell {
            background: red !important;
        }

        /* Анимация мигания выбранного робота */
        @keyframes blink {
            0% { filter: brightness(1); }
            50% { filter: brightness(2) hue-rotate(180deg); }
            100% { filter: brightness(1); }
        }

        .selected-robot {
            animation: blink 1s infinite;
        }

        /* Анимация движения робота */
        .moving-robot {
            transition: transform 0.5s linear;
            z-index: 10;
        }

        /* --- КНОПКА НОВАЯ ИГРА: ФОН ЖЁЛТЫЙ, ТЕКСТ ЧЁРНЫЙ --- */
        button {
            /* background: #3498db; */
            background: yellow; /* Изменён фон кнопки на жёлтый */
            /* color: white; */
            color: black; /* Изменён цвет текста кнопки на чёрный */
            border: none;
            /* --- УВЕЛИЧЕНИЕ --- */
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            /* --- УВЕЛИЧЕНИЕ --- */
            font-size: min(1em, 4.5vw);
            font-weight: bold;
            transition: background 0.3s;
            /* --- УВЕЛИЧЕНИЕ --- */
            margin-top: 12px;
            width: 100%;
            /* --- УВЕЛИЧЕНИЕ --- */
            max-width: 550px;
        }

        /* button:hover {
            background: #2980b9;
        } */
        button:hover {
            /* background: #2980b9; */
            background: #ffeb3b; /* Изменён цвет фона при наведении */
            /* Можно добавить другие эффекты при наведении */
        }

        /* Адаптивность */
        @media (max-width: 400px) {
            .container {
                padding: 6px;
                margin: 2px 0;
            }
            .stats-container {
                margin-bottom: 8px;
                padding: 0 4px;
                gap: 6px;
            }
            .stat-item {
                padding: 6px 10px;
                font-size: min(0.85em, 3.8vw);
            }
            .cell {
                font-size: calc(min(92vw, 92vh * (10/13), 400px) / 10 * 0.38);
                border-radius: 1px;
            }
            button {
                padding: 10px 14px;
                margin-top: 10px;
                font-size: min(0.95em, 4.2vw);
            }
        }

        @media (max-height: 700px) and (orientation: landscape) {
             .container {
                 padding: 5px;
                 margin: 2px 0;
             }
             .stats-container {
                 margin-bottom: 6px;
                 padding: 0 3px;
                 gap: 5px;
             }
             .stat-item {
                 padding: 5px 8px;
                 font-size: min(0.75em, 3vw);
             }
             .game-board {
                 /* Ещё более строгие ограничения для ландшафта на маленьких экранах */
                 width: min(85vw, 85vh * (10/13), 350px);
                 height: min(85vh, 85vw * (13/10), 455px);
             }
             .cell {
                 font-size: calc(min(85vw, 85vh * (10/13), 350px) / 10 * 0.35);
             }
             button {
                 padding: 8px 12px;
                 margin-top: 8px;
                 font-size: min(0.85em, 3.5vw);
             }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="stats-container">
            <div id="moves" class="stat-item">Заряд робота: 100%</div>
            <div id="timer" class="stat-item">Время: 20:00</div>
        </div>
        <div class="game-wrapper">
            <!-- Поле игры -->
            <div class="game-board" id="game-board"></div>
        </div>
        <button id="reset-btn">Новая игра</button>
    </div>
    <script>
        class LogisticsGame {
            constructor() {
                this.board = document.getElementById('game-board');
                this.movesElement = document.getElementById('moves');
                this.timerElement = document.getElementById('timer');
                this.rows = 13;
                this.cols = 10;
                this.chargingStations = [];
                this.obstacles = [];
                this.shelves = [];
                this.robots = [];
                this.robotCharges = []; // Массив для хранения зарядов роботов
                this.chargingStationCount = 3; // Переменная для количества столбов с зарядками
                this.shelfCount = 10; // Переменная для количества столов
                this.robotCount = 3; // Переменная для количества роботов
                this.lowChargeRobotCount = 0; // Количество роботов с низким зарядом
                this.selectedRobot = null; // Выбранный робот для отсчета времени
                this.moves = 0;
                this.gameStarted = false;
                this.startTime = 0;
                this.timerInterval = null;
                this.totalTime = 20 * 60; // 20 минут в секундах
                this.remainingTime = this.totalTime;
                this.possibleMoves = []; // Массив для хранения возможных перемещений
                this.blinkInterval = null; // Интервал для мигания робота
                this.movingRobot = null; // Робот, который сейчас движется
                this.trajectoryCells = []; // Клетки траектории
                this.trajectoryElements = []; // Элементы траектории
                this.OBSTACLES_COUNT = 9;
                this.init();
            }

            init() {
                this.createBoard();
                this.setupGame();
                this.setupEventListeners();
                 // Добавим обработчик изменения размера окна для лучшей адаптации
                 window.addEventListener('resize', () => {
                     // Можно добавить дополнительную логику при необходимости
                 });
            }

            createBoard() {
                this.board.innerHTML = '';
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell empty';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        this.board.appendChild(cell);
                    }
                }
            }

            setupGame() {
                this.moves = 0;
                this.movesElement.textContent = 'Заряд робота: 100%';
                this.stopTimer();
                this.stopBlinking();
                this.stopRobotMovement();
                this.gameStarted = false;
                this.startTime = 0;
                this.selectedRobot = null;
                this.remainingTime = this.totalTime;
                this.possibleMoves = [];
                this.updateTimerDisplay();

                // Верхний ряд - парковка
                for (let col = 0; col < this.cols; col++) {
                    const cell = this.getCell(0, col);
                    cell.className = 'cell parking';
                    cell.dataset.originalClass = 'parking';
                }

                this.placeObstaclesChargingStationsShelvesAndRobots();
            }

            placeObstaclesChargingStationsShelvesAndRobots() {
                this.obstacles = [];
                this.chargingStations = [];
                this.shelves = [];
                this.robots = [];
                this.robotCharges = [];
                
                // Столбы только в рядах 3-12 (индексы 3-12)
                const obstacleRows = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
                
                // Создаем сетку для размещения столбов с минимальным расстоянием 4 клетки
                const grid = [];
                for (const row of obstacleRows) {
                    for (let col = 0; col < this.cols; col++) {
                        grid.push({ row, col });
                    }
                }

                // Перемешиваем сетку для случайного выбора
                this.shuffleArray(grid);
                
                // Размещаем столбы с минимальным расстоянием 4 клетки
                for (const pos of grid) {
                    if (this.obstacles.length >= this.OBSTACLES_COUNT) break;
                    
                    let valid = true;
                    // Проверяем минимальное расстояние до уже размещенных столбов
                    for (const existing of this.obstacles) {
                        const manhattanDistance = Math.abs(pos.row - existing.row) + Math.abs(pos.col - existing.col);
                        if (manhattanDistance < 4) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) {
                        this.obstacles.push(pos);
                    }
                }

                // Если не удалось разместить нужное количество столбов, добавляем оставшиеся
                if (this.obstacles.length < this.OBSTACLES_COUNT) {
                    const remaining = grid.filter(pos =>
                        !this.obstacles.some(o => o.row === pos.row && o.col === pos.col)
                    );
                    this.obstacles.push(...remaining.slice(0, this.OBSTACLES_COUNT - this.obstacles.length));
                }

                // Размещаем столбы на поле
                for (const obs of this.obstacles) {
                    const cell = this.getCell(obs.row, obs.col);
                    cell.className = 'cell column';
                    cell.textContent = '';
                    cell.dataset.originalClass = 'column';
                }

                // Размещаем зарядные станции рядом со случайными столбами
                const shuffledObstacles = [...this.obstacles];
                this.shuffleArray(shuffledObstacles);
                
                let placedChargingStations = 0;
                for (const obstacle of shuffledObstacles) {
                    if (placedChargingStations >= this.chargingStationCount) break;
                    
                    // Направления: 0 - сверху, 1 - справа, 2 - снизу, 3 - слева
                    const directions = [
                        { row: -1, col: 0 },  // сверху
                        { row: 0, col: 1 },   // справа
                        { row: 1, col: 0 },   // снизу
                        { row: 0, col: -1 }   // слева
                    ];
                    
                    // Перемешиваем направления
                    this.shuffleArray(directions);
                    
                    let chargingPlaced = false;
                    for (const dir of directions) {
                        const newRow = obstacle.row + dir.row;
                        const newCol = obstacle.col + dir.col;
                        
                        // Проверяем, что позиция внутри поля и не ближе 2 клеток к краям
                        if (newRow >= 2 && newRow < this.rows - 2 && newCol >= 2 && newCol < this.cols - 2) {
                            const cell = this.getCell(newRow, newCol);
                            const currentClass = cell.className;
                            
                            // Проверяем, что клетка пустая
                            if (currentClass.includes('empty')) {
                                // Проверяем минимальное расстояние 3 клетки до других зарядных станций
                                let validDistance = true;
                                for (const existingStation of this.chargingStations) {
                                    const manhattanDistance = Math.abs(newRow - existingStation.row) + Math.abs(newCol - existingStation.col);
                                    if (manhattanDistance < 3) {
                                        validDistance = false;
                                        break;
                                    }
                                }
                                
                                if (validDistance) {
                                    cell.className = 'cell charging-station';
                                    cell.dataset.originalClass = 'charging-station';
                                    this.chargingStations.push({ row: newRow, col: newCol });
                                    chargingPlaced = true;
                                    placedChargingStations++;
                                    break;
                                }
                            }
                        }
                    }
                }

                // Размещаем столы в рядах 4-12 (индексы 4-12)
                const shelfRows = [4, 5, 6, 7, 8, 9, 10, 11, 12];
                const shelfGrid = [];
                for (const row of shelfRows) {
                    for (let col = 0; col < this.cols; col++) {
                        shelfGrid.push({ row, col });
                    }
                }

                // Перемешиваем сетку для случайного выбора
                this.shuffleArray(shelfGrid);
                
                // Размещаем столы с проверкой расстояния до зарядных станций
                for (const pos of shelfGrid) {
                    if (this.shelves.length >= this.shelfCount) break;
                    
                    let valid = true;
                    // Проверяем минимальное расстояние 2 клетки до зарядных станций
                    for (const chargingStation of this.chargingStations) {
                        const manhattanDistance = Math.abs(pos.row - chargingStation.row) + Math.abs(pos.col - chargingStation.col);
                        if (manhattanDistance < 2) {
                            valid = false;
                            break;
                        }
                    }
                    
                    // Проверяем, что клетка пустая
                    if (valid) {
                        const cell = this.getCell(pos.row, pos.col);
                        if (cell.className.includes('empty')) {
                            this.shelves.push(pos);
                        } else {
                            valid = false;
                        }
                    }
                    
                    if (valid) {
                        const cell = this.getCell(pos.row, pos.col);
                        cell.className = 'cell shelf';
                        cell.dataset.originalClass = 'shelf';
                    }
                }

                // Размещаем роботов в рядах 3-12 (индексы 3-12)
                const robotRows = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
                const robotGrid = [];
                for (const row of robotRows) {
                    for (let col = 0; col < this.cols; col++) {
                        robotGrid.push({ row, col });
                    }
                }

                // Перемешиваем сетку для случайного выбора
                this.shuffleArray(robotGrid);
                
                // Размещаем роботов с минимальным расстоянием 4 клетки
                for (const pos of robotGrid) {
                    if (this.robots.length >= this.robotCount) break;
                    
                    let valid = true;
                    // Проверяем минимальное расстояние 4 клетки до других роботов
                    for (const existingRobot of this.robots) {
                        const manhattanDistance = Math.abs(pos.row - existingRobot.row) + Math.abs(pos.col - existingRobot.col);
                        if (manhattanDistance < 4) {
                            valid = false;
                            break;
                        }
                    }
                    
                    // Проверяем, что клетка пустая
                    if (valid) {
                        const cell = this.getCell(pos.row, pos.col);
                        if (cell.className.includes('empty')) {
                            this.robots.push(pos);
                        } else {
                            valid = false;
                        }
                    }
                    
                    if (valid) {
                        const cell = this.getCell(pos.row, pos.col);
                        cell.className = 'cell robot-cell';
                        cell.dataset.originalClass = 'robot-cell';
                        
                        // Добавляем полосу заряда
                        const chargeBar = document.createElement('div');
                        chargeBar.className = 'charge-bar';
                        const chargeLevel = document.createElement('div');
                        chargeLevel.className = 'charge-level high';
                        chargeLevel.style.width = '100%';
                        chargeBar.appendChild(chargeLevel);
                        cell.appendChild(chargeBar);
                    }
                }

                // Устанавливаем заряды роботов
                this.setRobotCharges();
            }

            setRobotCharges() {
                // Вычисляем количество роботов с низким зарядом (10% или минимум 1)
                this.lowChargeRobotCount = Math.max(1, Math.floor(this.robotCount * 0.1));
                
                // Создаем массив зарядов
                this.robotCharges = [];
                for (let i = 0; i < this.robotCount; i++) {
                    let charge;
                    if (i < this.lowChargeRobotCount) {
                        // Роботы с низким зарядом (24-40%)
                        charge = Math.floor(Math.random() * 17) + 24; // 24-40
                    } else {
                        // Роботы с нормальным зарядом (41-100%)
                        charge = Math.floor(Math.random() * 60) + 41; // 41-100
                    }
                    this.robotCharges.push(charge);
                }
                
                // Перемешиваем заряды для случайного распределения
                this.shuffleArray(this.robotCharges);
                
                // Обновляем визуальное отображение зарядов
                this.updateRobotChargeDisplay();
            }

            updateRobotChargeDisplay() {
                for (let i = 0; i < this.robots.length; i++) {
                    const robotPos = this.robots[i];
                    const cell = this.getCell(robotPos.row, robotPos.col);
                    const chargeLevel = cell.querySelector('.charge-level');
                    
                    if (chargeLevel) {
                        const charge = this.robotCharges[i];
                        chargeLevel.style.width = charge + '%';
                        
                        // Устанавливаем цвет в зависимости от уровня заряда
                        chargeLevel.className = 'charge-level ';
                        if (charge <= 25) {
                            chargeLevel.classList.add('low');
                        } else if (charge <= 50) {
                            chargeLevel.classList.add('medium');
                        } else if (charge <= 75) {
                            chargeLevel.classList.add('good');
                        } else {
                            chargeLevel.classList.add('high');
                        }
                    }
                }
            }

            startTimer() {
                if (!this.gameStarted && this.selectedRobot !== null) {
                    this.gameStarted = true;
                    this.startTime = Date.now();
                    this.timerInterval = setInterval(() => this.updateTimer(), 1000);
                }
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            updateTimer() {
                if (this.gameStarted) {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    this.remainingTime = this.totalTime - elapsed;
                    
                    if (this.remainingTime <= 0) {
                        this.remainingTime = 0;
                        this.stopTimer();
                    }
                    
                    this.updateTimerDisplay();
                }
            }

            updateTimerDisplay() {
                const minutes = Math.floor(this.remainingTime / 60);
                const seconds = this.remainingTime % 60;
                this.timerElement.textContent = `Время: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            getCell(row, col) {
                return this.board.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            }

            // Метод для вычисления возможных перемещений робота до препятствия
            calculatePossibleMoves(robotIndex) {
                const robot = this.robots[robotIndex];
                if (!robot) return [];
                
                const possibleMoves = [];
                const directions = [
                    { row: -1, col: 0 }, // вверх
                    { row: 0, col: 1 },  // вправо
                    { row: 1, col: 0 },  // вниз
                    { row: 0, col: -1 }  // влево
                ];
                
                for (const dir of directions) {
                    let newRow = robot.row + dir.row;
                    let newCol = robot.col + dir.col;
                    
                    // Двигаемся в направлении пока не встретим препятствие
                    while (newRow >= 0 && newRow < this.rows && newCol >= 0 && newCol < this.cols) {
                        const cell = this.getCell(newRow, newCol);
                        const cellClass = cell.className;
                        
                        // Проверяем, можно ли переместиться в эту клетку
                        // Зарядная станция теперь не прерывает маршрут
                        if (this.isMovableCell(cellClass)) {
                            // Проверяем, есть ли в этой клетке другой робот
                            const hasRobot = this.robots.some((r, index) => 
                                index !== robotIndex && r.row === newRow && r.col === newCol
                            );
                            
                            if (!hasRobot) {
                                // Можно переместиться в эту клетку
                                possibleMoves.push({ row: newRow, col: newCol });
                                newRow += dir.row;
                                newCol += dir.col;
                            } else {
                                // В клетке другой робот - останавливаемся
                                break;
                            }
                        } else {
                            // Нельзя переместиться - препятствие
                            break;
                        }
                    }
                }
                
                return possibleMoves;
            }

            // Метод для проверки, можно ли перемещаться в клетку
            isMovableCell(cellClass) {
                // Робот может перемещаться в пустые клетки, клетки со столами и зарядные станции
                return cellClass.includes('empty') || 
                       cellClass.includes('shelf') || 
                       cellClass.includes('charging-station');
            }

            // Метод для подсветки возможных перемещений
            highlightPossibleMoves() {
                // Убираем предыдущую подсветку
                this.clearHighlights();
                
                if (this.selectedRobot === null) return;
                
                // Вычисляем возможные перемещения
                this.possibleMoves = this.calculatePossibleMoves(this.selectedRobot);
                
                // Подсвечиваем возможные перемещения
                for (const move of this.possibleMoves) {
                    const cell = this.getCell(move.row, move.col);
                    cell.classList.add('possible-move');
                    
                    // Добавляем черные границы и движущиеся желтые части
                    this.addBorderHighlights(cell);
                }
            }

            // Метод для добавления черных границ и движущихся желтых частей
            addBorderHighlights(cell) {
                // Создаем черные границы
                const borders = [];
                
                // Верхняя граница
                const topBorder = document.createElement('div');
                topBorder.className = 'border-highlight';
                topBorder.style.top = '0';
                topBorder.style.left = '0';
                topBorder.style.width = '100%';
                topBorder.style.height = '2px';
                borders.push(topBorder);
                
                // Правая граница
                const rightBorder = document.createElement('div');
                rightBorder.className = 'border-highlight';
                rightBorder.style.top = '0';
                rightBorder.style.right = '0';
                rightBorder.style.width = '2px';
                rightBorder.style.height = '100%';
                borders.push(rightBorder);
                
                // Нижняя граница
                const bottomBorder = document.createElement('div');
                bottomBorder.className = 'border-highlight';
                bottomBorder.style.bottom = '0';
                bottomBorder.style.left = '0';
                bottomBorder.style.width = '100%';
                bottomBorder.style.height = '2px';
                borders.push(bottomBorder);
                
                // Левая граница
                const leftBorder = document.createElement('div');
                leftBorder.className = 'border-highlight';
                leftBorder.style.top = '0';
                leftBorder.style.left = '0';
                leftBorder.style.width = '2px';
                leftBorder.style.height = '100%';
                borders.push(leftBorder);
                
                // Добавляем черные границы
                borders.forEach(border => cell.appendChild(border));
                
                // Создаем движущиеся желтые части
                const movingParts = [];
                
                // Верхняя движущаяся часть
                const topPart = document.createElement('div');
                topPart.className = 'moving-part';
                topPart.style.top = '0';
                topPart.style.left = '0';
                topPart.style.width = '25%';
                topPart.style.height = '2px';
                movingParts.push({
                    element: topPart,
                    type: 'top',
                    position: 0
                });
                
                // Правая движущаяся часть
                const rightPart = document.createElement('div');
                rightPart.className = 'moving-part';
                rightPart.style.top = '0';
                rightPart.style.right = '0';
                rightPart.style.width = '2px';
                rightPart.style.height = '25%';
                movingParts.push({
                    element: rightPart,
                    type: 'right',
                    position: 0
                });
                
                // Нижняя движущаяся часть
                const bottomPart = document.createElement('div');
                bottomPart.className = 'moving-part';
                bottomPart.style.bottom = '0';
                bottomPart.style.right = '0';
                bottomPart.style.width = '25%';
                bottomPart.style.height = '2px';
                movingParts.push({
                    element: bottomPart,
                    type: 'bottom',
                    position: 0
                });
                
                // Левая движущаяся часть
                const leftPart = document.createElement('div');
                leftPart.className = 'moving-part';
                leftPart.style.bottom = '0';
                leftPart.style.left = '0';
                leftPart.style.width = '2px';
                leftPart.style.height = '25%';
                movingParts.push({
                    element: leftPart,
                    type: 'left',
                    position: 0
                });
                
                // Добавляем движущиеся части
                movingParts.forEach(part => cell.appendChild(part.element));
                
                // Запускаем анимацию
                this.animateMovingParts(movingParts);
            }

            // Метод для анимации движущихся частей
            animateMovingParts(movingParts) {
                let step = 0;
                const animate = () => {
                    movingParts.forEach(part => {
                        switch (part.type) {
                            case 'top':
                                // Движение слева направо
                                part.element.style.left = (step * 25) + '%';
                                break;
                            case 'right':
                                // Движение сверху вниз
                                part.element.style.top = (step * 25) + '%';
                                break;
                            case 'bottom':
                                // Движение справа налево
                                part.element.style.right = (step * 25) + '%';
                                break;
                            case 'left':
                                // Движение снизу вверх
                                part.element.style.bottom = (step * 25) + '%';
                                break;
                        }
                    });
                    
                    step = (step + 1) % 4;
                };
                
                // Запускаем анимацию с интервалом 300мс
                setInterval(animate, 300);
            }

            // Метод для очистки подсветки
            clearHighlights() {
                const highlightedCells = this.board.querySelectorAll('.possible-move');
                highlightedCells.forEach(cell => {
                    cell.classList.remove('possible-move');
                    // Удаляем все элементы подсветки
                    const highlights = cell.querySelectorAll('.border-highlight, .moving-part');
                    highlights.forEach(highlight => highlight.remove());
                });
                this.possibleMoves = [];
            }

            // Метод для начала мигания выбранного робота
            startBlinking(robotIndex) {
                this.stopBlinking();
                if (robotIndex === null) return;
                
                const robot = this.robots[robotIndex];
                if (robot) {
                    const cell = this.getCell(robot.row, robot.col);
                    cell.classList.add('selected-robot');
                }
            }

            // Метод для остановки мигания
            stopBlinking() {
                if (this.blinkInterval) {
                    clearInterval(this.blinkInterval);
                    this.blinkInterval = null;
                }
                
                const blinkingRobots = this.board.querySelectorAll('.selected-robot');
                blinkingRobots.forEach(cell => {
                    cell.classList.remove('selected-robot');
                });
            }

            // Метод для остановки движения робота
            stopRobotMovement() {
                if (this.movingRobot) {
                    // Очищаем траекторию
                    this.clearTrajectory();
                    this.movingRobot = null;
                }
            }

            // Метод для создания траектории движения
            createTrajectory(startRow, startCol, endRow, endCol) {
                const trajectory = [];
                
                // Определяем направление движения
                if (startRow === endRow) {
                    // Горизонтальное движение
                    const step = startCol < endCol ? 1 : -1;
                    for (let col = startCol + step; col !== endCol + step; col += step) {
                        trajectory.push({ row: startRow, col: col });
                    }
                } else if (startCol === endCol) {
                    // Вертикальное движение
                    const step = startRow < endRow ? 1 : -1;
                    for (let row = startRow + step; row !== endRow + step; row += step) {
                        trajectory.push({ row: row, col: startCol });
                    }
                }
                
                return trajectory;
            }

            // Метод для отображения траектории
            showTrajectory(trajectory) {
                this.trajectoryCells = [];
                this.trajectoryElements = [];
                
                trajectory.forEach((pos, index) => {
                    const cell = this.getCell(pos.row, pos.col);
                    if (cell) {
                        // Добавляем красный фон клетке
                        cell.classList.add('moving-cell');
                        this.trajectoryCells.push(cell);
                        
                        // Создаем элемент траектории
                        const trajectoryElement = document.createElement('div');
                        trajectoryElement.className = 'trajectory';
                        
                        // Определяем ориентацию линии
                        if (index < trajectory.length - 1) {
                            const nextPos = trajectory[index + 1];
                            if (pos.row === nextPos.row) {
                                // Горизонтальная линия
                                trajectoryElement.style.top = '50%';
                                trajectoryElement.style.left = '0';
                                trajectoryElement.style.width = '100%';
                                trajectoryElement.style.height = '2px';
                                trajectoryElement.style.transform = 'translateY(-50%)';
                            } else {
                                // Вертикальная линия
                                trajectoryElement.style.left = '50%';
                                trajectoryElement.style.top = '0';
                                trajectoryElement.style.width = '2px';
                                trajectoryElement.style.height = '100%';
                                trajectoryElement.style.transform = 'translateX(-50%)';
                            }
                        } else {
                            // Последняя клетка - точка
                            trajectoryElement.style.top = '50%';
                            trajectoryElement.style.left = '50%';
                            trajectoryElement.style.width = '4px';
                            trajectoryElement.style.height = '4px';
                            trajectoryElement.style.borderRadius = '50%';
                            trajectoryElement.style.transform = 'translate(-50%, -50%)';
                        }
                        
                        cell.appendChild(trajectoryElement);
                        this.trajectoryElements.push(trajectoryElement);
                    }
                });
            }

            // Метод для очистки траектории
            clearTrajectory() {
                // Убираем красный фон с клеток
                this.trajectoryCells.forEach(cell => {
                    cell.classList.remove('moving-cell');
                });
                
                // Удаляем элементы траектории
                this.trajectoryElements.forEach(element => {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                });
                
                this.trajectoryCells = [];
                this.trajectoryElements = [];
            }

            // Метод для перемещения робота
            moveRobot(robotIndex, targetRow, targetCol) {
                const robot = this.robots[robotIndex];
                if (!robot) return;
                
                // Создаем траекторию
                const trajectory = this.createTrajectory(robot.row, robot.col, targetRow, targetCol);
                if (trajectory.length === 0) return;
                
                // Отображаем траекторию
                this.showTrajectory(trajectory);
                
                // Получаем элемент робота
                const robotCell = this.getCell(robot.row, robot.col);
                const robotElement = robotCell.querySelector('img') || robotCell;
                
                // Добавляем класс для анимации
                robotElement.classList.add('moving-robot');
                
                // Сохраняем движущегося робота
                this.movingRobot = {
                    index: robotIndex,
                    element: robotElement,
                    from: { row: robot.row, col: robot.col },
                    to: { row: targetRow, col: targetCol },
                    trajectory: trajectory
                };
                
                // Начинаем анимацию движения
                this.animateRobotMovement(robotIndex, targetRow, targetCol, trajectory);
            }

            // Метод для анимации движения робота
            animateRobotMovement(robotIndex, targetRow, targetCol, trajectory) {
                const robot = this.robots[robotIndex];
                if (!robot) return;
                
                // Рассчитываем размер клетки
                const cellWidth = this.board.clientWidth / this.cols;
                const cellHeight = this.board.clientHeight / this.rows;
                
                // Рассчитываем смещение
                const deltaX = (targetCol - robot.col) * cellWidth;
                const deltaY = (targetRow - robot.row) * cellHeight;
                
                // Применяем трансформацию
                const robotCell = this.getCell(robot.row, robot.col);
                const robotElement = robotCell.querySelector('img') || robotCell;
                robotElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                
                // После завершения анимации обновляем позицию робота
                setTimeout(() => {
                    // Очищаем траекторию
                    this.clearTrajectory();
                    
                    // Убираем класс анимации
                    robotElement.classList.remove('moving-robot');
                    robotElement.style.transform = '';
                    
                    // Очищаем исходную клетку
                    const oldCell = this.getCell(robot.row, robot.col);
                    const originalClass = oldCell.dataset.originalClass || 'empty';
                    oldCell.className = 'cell ' + originalClass;
                    
                    // Обновляем позицию робота
                    robot.row = targetRow;
                    robot.col = targetCol;
                    
                    // Обновляем целевую клетку
                    const newCell = this.getCell(targetRow, targetCol);
                    newCell.className = 'cell robot-cell';
                    newCell.dataset.originalClass = 'robot-cell';
                    
                    // Добавляем полосу заряда
                    const chargeBar = document.createElement('div');
                    chargeBar.className = 'charge-bar';
                    const chargeLevel = document.createElement('div');
                    chargeLevel.className = 'charge-level high';
                    chargeLevel.style.width = '100%';
                    chargeBar.appendChild(chargeLevel);
                    newCell.appendChild(chargeBar);
                    
                    // Обновляем отображение заряда
                    this.updateRobotChargeDisplay();
                    
                    // Сбрасываем движущегося робота
                    this.movingRobot = null;
                }, 500);
            }

            setupEventListeners() {
                document.getElementById('reset-btn').addEventListener('click', () => this.resetGame());
                
                // Обработчик клика по полю
                this.board.addEventListener('click', (e) => {
                    // Если робот движется, игнорируем клики
                    if (this.movingRobot) return;
                    
                    const cell = e.target.closest('.cell');
                    if (!cell) return;
                    
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    // Проверяем, кликнули ли на робота
                    const robotIndex = this.robots.findIndex(robot => 
                        robot.row === row && robot.col === col
                    );
                    
                    if (robotIndex !== -1) {
                        // Клик на робота - показываем возможные перемещения
                        this.selectedRobot = robotIndex;
                        const charge = this.robotCharges[robotIndex];
                        this.movesElement.textContent = `Заряд робота: ${charge}%`;
                        
                        // Запускаем таймер при первом клике на робота
                        if (!this.gameStarted) {
                            this.startTimer();
                        }
                        
                        // Подсвечиваем возможные перемещения
                        this.highlightPossibleMoves();
                        
                        // Начинаем мигание выбранного робота
                        this.startBlinking(robotIndex);
                    } else if (this.selectedRobot !== null) {
                        // Клик на клетку - проверяем, является ли она возможным перемещением
                        const isPossibleMove = this.possibleMoves.some(move => 
                            move.row === row && move.col === col
                        );
                        
                        if (isPossibleMove) {
                            // Перемещаем робота
                            this.moveRobot(this.selectedRobot, row, col);
                            
                            // Убираем подсветку
                            this.clearHighlights();
                            this.stopBlinking();
                            this.selectedRobot = null;
                        } else {
                            // Клик не на возможное перемещение - убираем подсветку
                            this.clearHighlights();
                            this.stopBlinking();
                            this.selectedRobot = null;
                        }
                    }
                });
            }

            resetGame() {
                this.createBoard();
                this.setupGame();
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new LogisticsGame();
        });
    </script>
</body>
</html>
