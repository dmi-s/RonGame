<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Логистические роботы</title>
 <style>
  body {
    margin: 0;
    padding: 10px;
    font-family: Arial, sans-serif;
    background-color: black;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: white;
  }

  .game-info {
    display: flex;
    justify-content: space-around;
    width: min(95vw, 600px);
    max-width: 100%;
    margin-bottom: 10px;
    background-color: var(--info-bg, yellow);
    color: var(--info-text, black);
    padding: 10px;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1em;
  }

  .game-container {
    position: relative;
    width: min(95vw, 600px);
    max-width: 100%;
    aspect-ratio: calc(var(--cols) / var(--rows));
    margin-bottom: 20px;
  }

  .grid {
    display: grid;
    width: 100%;
    height: 100%;
    grid-template-columns: repeat(var(--cols), 1fr);
    grid-template-rows: repeat(var(--rows), 1fr);
    gap: 1px;
    background-color: gray;
    border: 2px solid gray;
  }

  .cell {
    background-color: white;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    position: relative;
    overflow: hidden;
    min-height: 30px;
    min-width: 30px;
    /* Адаптивный размер клетки: min 30px, max 60px, динамично под экран */
    width: clamp(30px, 5vw, 60px);
    height: clamp(30px, 5vw, 60px);
  }

  .cell img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .charge-bar {
    position: absolute;
    top: 2px;
    left: 2px;
    right: 2px;
    height: 6px;
    border-radius: 3px;
    background-color: #ccc;
    overflow: hidden;
  }

  .charge-level {
    height: 100%;
    width: 0%;
  }

  .overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(128, 128, 128, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2.5em;
    font-weight: bold;
    color: red;
    z-index: 10;
    display: none;
  }

  button {
    background-color: var(--btn-bg, yellow);
    color: var(--btn-text, black);
    border: none;
    padding: 12px 24px;
    font-size: 1.2em;
    font-weight: bold;
    border-radius: 8px;
    cursor: pointer;
    width: min(95vw, 600px);
    max-width: 100%;
  }

  button:hover {
    background-color: #ffcc00;
  }
</style>
</head>
<body>

  <div class="game-info">
    <div>Заряд: <span id="robot-charge">-</span></div>
    <div>Время: <span id="game-timer">-</span></div>
  </div>

  <div class="game-container">
    <div class="grid" id="grid"></div>
    <div class="overlay" id="overlay">GAME OVER</div>
  </div>

  <button id="new-game">Новая игра</button>

<script>
  // === КОНФИГУРАЦИЯ ИГРЫ ===
  const CONFIG = {
    rows: 13,
    cols: 10,
    gameMinutes: 20,
    numColumns: 8,
    numShelves: 10,
    numRobots: 3,
    numChargingStations: 3,

    shelfRows: { min: 3, max: 12 },
    shelfCols: { min: 0, max: 9 },
    robotRows: { min: 3, max: 12 },
    robotCols: { min: 0, max: 9 },
    columnRows: { min: 4, max: 11 },
    columnCols: { min: 0, max: 9 },
    chargingCenterRows: { min: 4, max: 8 },
    chargingCenterCols: { min: 3, max: 7 },

    minDistanceShelf: 2,
    minDistanceRobot: 4,
    minDistanceColumn: 4,

    chargeRobotFirstMin: 25,
    chargeRobotFirstMax: 50,
    chargeOtherRobotsMin: 50,
    chargeOtherRobotsMax: 100,

    chargeCostPerMove: 5,
    chargeGainPerTick: 2,

    maxGenerationAttempts: 10, // Макс. попыток генерации

    images: {
      parking: 'Parking.png',
      column: 'Column.png',
      robot: 'Robot.png',
      charging: 'Charging.png',
      robotCharging: 'Robot_Charg.png',
      shelf: 'Shelf.png',
      robotWithShelf: 'Robot_Shelf.png',
      parkedShelf: 'Parking_Shelf.png'
    },

    styles: {
      '--rows': 13,
      '--cols': 10,
      '--info-bg': 'yellow',
      '--info-text': 'black',
      '--btn-bg': 'yellow',
      '--btn-text': 'black'
    }
  };

  // Применяем стили
  Object.keys(CONFIG.styles).forEach(key => {
    document.documentElement.style.setProperty(key, CONFIG.styles[key]);
  });

  // DOM
  const grid = document.getElementById("grid");
  const chargeDisplay = document.getElementById("robot-charge");
  const timerDisplay = document.getElementById("game-timer");
  const overlay = document.getElementById("overlay");
  const newGameBtn = document.getElementById("new-game");

  // Состояние
  let cells = [];
  let robots = [];
  let shelves = [];
  let chargingStations = [];
  let columns = [];
  let parkingSpots = [];
  let robotCharge = [];
  let selectedRobot = null;
  let gameInterval = null;
  let timer = CONFIG.gameMinutes * 60;
  let gameStarted = false;
  let gameEnded = false;

  // === БЕЗОПАСНАЯ ГЕНЕРАЦИЯ С ЛИМИТОМ ПОПЫТОК ===
  function initGrid(attempt = 0) {
    if (attempt > CONFIG.maxGenerationAttempts) {
      alert("Не удалось сгенерировать поле после нескольких попыток. Попробуйте изменить параметры.");
      return;
    }

    grid.innerHTML = "";
    const { rows, cols } = CONFIG;
    cells = Array(rows).fill().map(() => Array(cols).fill("free"));
    robots = [];
    shelves = [];
    chargingStations = [];
    columns = [];
    parkingSpots = [];
    robotCharge = [];

    // Парковка
    for (let c = 0; c < cols; c++) {
      parkingSpots.push({ r: 0, c });
      cells[0][c] = "parking";
    }

    // Столбы
    if (!placeObjects(columns, CONFIG.numColumns, () => {
      const r = rand(CONFIG.columnRows.min, CONFIG.columnRows.max);
      const c = rand(CONFIG.columnCols.min, CONFIG.columnCols.max);
      return { r, c, valid: isFree(r, c) && isTooClose(columns, r, c, CONFIG.minDistanceColumn) === false };
    })) {
      console.log("Failed to place columns, retrying...");
      return initGrid(attempt + 1);
    }

    // Зарядки
    placeChargingStations();

    // Столы
    if (!placeObjects(shelves, CONFIG.numShelves, () => {
      const r = rand(CONFIG.shelfRows.min, CONFIG.shelfRows.max);
      const c = rand(CONFIG.shelfCols.min, CONFIG.shelfCols.max);
      return { r, c, valid: isFree(r, c) && isTooClose(shelves, r, c, CONFIG.minDistanceShelf) === false };
    })) {
      console.log("Failed to place shelves, retrying...");
      return initGrid(attempt + 1);
    }

    // Роботы
    if (!placeObjects(robots, CONFIG.numRobots, () => {
      const r = rand(CONFIG.robotRows.min, CONFIG.robotRows.max);
      const c = rand(CONFIG.robotCols.min, CONFIG.robotCols.max);
      return { r, c, valid: isFree(r, c) && isTooClose(robots, r, c, CONFIG.minDistanceRobot) === false };
    })) {
      console.log("Failed to place robots, retrying...");
      return initGrid(attempt + 1);
    }

    // Заряд роботов
    for (let i = 0; i < robots.length; i++) {
      const charge = i === 0
        ? rand(CONFIG.chargeRobotFirstMin, CONFIG.chargeRobotFirstMax)
        : rand(CONFIG.chargeOtherRobotsMin, CONFIG.chargeOtherRobotsMax);
      robotCharge.push(charge);
    }

    renderGrid();
    updateTimerDisplay();
    chargeDisplay.textContent = "-";

    console.log("Field generated successfully on attempt", attempt + 1);
  }

  function rand(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function isFree(r, c) {
    return r >= 0 && r < CONFIG.rows && c >= 0 && c < CONFIG.cols && cells[r][c] === "free";
  }

  function isTooClose(list, r, c, minDist) {
    for (const item of list) {
      const dist = Math.abs(item.r - r) + Math.abs(item.c - c);
      if (dist < minDist) return true;
    }
    return false;
  }

  // Универсальная функция размещения объектов
  function placeObjects(list, count, generator) {
    const MAX_TRIES = 1000;
    let tries = 0;
    while (list.length < count && tries < MAX_TRIES) {
      tries++;
      const { r, c, valid } = generator();
      if (valid) {
        list.push({ r, c });
        cells[r][c] = getTypeFromList(list);
      }
    }
    return list.length === count;
  }

  function getTypeFromList(list) {
    if (list === columns) return "column";
    if (list === shelves) return "shelf";
    if (list === robots) return "robot";
    return "free";
  }

  // Зарядки — отдельно, т.к. ставятся рядом со столбами
  function placeChargingStations() {
    const centerColumns = columns.filter(col =>
      col.r >= CONFIG.chargingCenterRows.min && col.r <= CONFIG.chargingCenterRows.max &&
      col.c >= CONFIG.chargingCenterCols.min && col.c <= CONFIG.chargingCenterCols.max
    );
    const candidates = shuffle(centerColumns).slice(0, CONFIG.numChargingStations);

    for (const col of candidates) {
      const dirs = shuffle([{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }]);
      for (const dir of dirs) {
        const nr = col.r + dir.dr;
        const nc = col.c + dir.dc;
        if (isFree(nr, nc)) {
          cells[nr][nc] = "charging";
          chargingStations.push({ r: nr, c: nc });
          break;
        }
      }
    }
  }

  function shuffle(array) {
    return array.sort(() => Math.random() - 0.5);
  }

  // Отрисовка
  function renderGrid() {
    grid.innerHTML = "";
    for (let r = 0; r < CONFIG.rows; r++) {
      for (let c = 0; c < CONFIG.cols; c++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.dataset.row = r;
        cell.dataset.col = c;

        const type = cells[r][c];
        if (type === "parking") setImg(cell, CONFIG.images.parking);
        else if (type === "column") setImg(cell, CONFIG.images.column);
        else if (type === "charging") setImg(cell, CONFIG.images.charging);
        else if (type === "shelf") setImg(cell, CONFIG.images.shelf);
        else if (type === "robot") {
          setImg(cell, CONFIG.images.robot);
          addChargeBar(cell, getRobotIndex(r, c));
        }
        else if (type === "robot_charging") {
          setImg(cell, CONFIG.images.robotCharging);
          addChargeBar(cell, getRobotIndex(r, c));
        }
        else if (type === "robot_with_shelf") {
          setImg(cell, CONFIG.images.robotWithShelf);
          addChargeBar(cell, getRobotIndex(r, c));
        }
        else if (type === "shelf_parked") {
          setImg(cell, CONFIG.images.parkedShelf);
        }

        cell.addEventListener("click", () => handleCellClick(r, c));
        grid.appendChild(cell);
      }
    }
  }

  function setImg(cell, src) {
    const img = document.createElement("img");
    img.src = src;
    cell.appendChild(img);
  }

  function addChargeBar(cell, robotIdx) {
    if (robotIdx === -1) return;
    const bar = document.createElement("div");
    bar.classList.add("charge-bar");
    const level = document.createElement("div");
    level.classList.add("charge-level");
    const charge = robotCharge[robotIdx];
    level.style.width = `${charge}%`;
    level.style.backgroundColor = charge <= 25 ? "red" : charge <= 50 ? "orange" : charge <= 75 ? "yellow" : "green";
    bar.appendChild(level);
    cell.appendChild(bar);
  }

  function getRobotIndex(r, c) {
    for (let i = 0; i < robots.length; i++) {
      if (robots[i].r === r && robots[i].c === c) return i;
    }
    return -1;
  }

  // === КЛИК: старт — только по роботу ===
  function handleCellClick(r, c) {
    if (gameEnded) return;

    const robotIdx = getRobotIndex(r, c);

    // Показ заряда при клике на робота
    if (robotIdx !== -1) {
      chargeDisplay.textContent = robotCharge[robotIdx] + "%";
    }

    // Старт игры — только по роботу
    if (!gameStarted && robotIdx !== -1) {
      startGame();
    }

    if (!gameStarted) return;

    // Логика перемещения
    if (robotIdx !== -1 && !selectedRobot) {
      selectedRobot = { r, c, idx: robotIdx };
      highlightMoves(r, c);
      return;
    }

    if (selectedRobot) {
      if (isValidMove(selectedRobot.r, selectedRobot.c, r, c)) {
        moveRobot(selectedRobot.idx, r, c);
      }
      clearHighlights();
      selectedRobot = null;
    }
  }

  function highlightMoves(r, c) {
    clearHighlights();
    for (let nr = 0; nr < CONFIG.rows; nr++) {
      for (let nc = 0; nc < CONFIG.cols; nc++) {
        if (isValidMove(r, c, nr, nc)) {
          cells[nr][nc] = "trajectory";
        }
      }
    }
    renderGrid();
  }

  function clearHighlights() {
    for (let r = 0; r < CONFIG.rows; r++) {
      for (let c = 0; c < CONFIG.cols; c++) {
        if (cells[r][c] === "trajectory") {
          cells[r][c] = "free";
        }
      }
    }
  }

  function isValidMove(fromR, fromC, toR, toC) {
    if (!isFree(toR, toC) && !(toR === 0 && cells[toR][toC] === "parking")) return false;
    if (Math.abs(fromR - toR) + Math.abs(fromC - toC) !== 1) return false;

    const robotIdx = getRobotIndex(fromR, fromC);
    if (robotIdx === -1) return false;

    const hasShelf = cells[fromR][fromC] === "robot_with_shelf";
    const target = cells[toR][toC];

    if (["column", "robot", "charging"].includes(target)) return false;
    if (target === "free" || target === "parking") return true;
    if (hasShelf && target === "parking") return true;
    if (hasShelf && ["shelf", "robot_with_shelf"].includes(target)) return true;
    return false;
  }

  function moveRobot(idx, toR, toC) {
    const fromR = robots[idx].r;
    const fromC = robots[idx].c;
    const hasShelf = cells[fromR][fromC] === "robot_with_shelf";
    const target = cells[toR][toC];

    robotCharge[idx] = Math.max(0, robotCharge[idx] - CONFIG.chargeCostPerMove);
    if (robotCharge[idx] <= 0) {
      endGame(false);
      return;
    }

    // Перемещение
    if (hasShelf) {
      if (target === "parking") {
        cells[toR][toC] = "shelf_parked";
        shelves = shelves.filter(s => !(s.r === fromR && s.c === fromC));
      } else {
        cells[toR][toC] = "robot_with_shelf";
      }
      cells[fromR][fromC] = "free";
    } else {
      if (target === "shelf") {
        cells[toR][toC] = "robot_with_shelf";
      } else if (target === "charging") {
        cells[toR][toC] = "robot_charging";
      } else {
        cells[toR][toC] = "robot";
      }
      cells[fromR][fromC] = "free";
    }

    robots[idx] = { r: toR, c: toC };

    if (shelves.length === 0) endGame(true);
    renderGrid();
    updateChargeDisplay();
  }

  function startGame() {
    if (gameStarted) return;
    gameStarted = true;
    updateChargeDisplay();
    gameInterval = setInterval(updateTimer, 1000);
  }

  function updateTimer() {
    timer--;
    updateTimerDisplay();

    if (timer <= 0) {
      endGame(false);
      return;
    }

    for (const charge of robotCharge) {
      if (charge <= 0) {
        endGame(false);
        return;
      }
    }

    let needsRender = false;
    for (let i = 0; i < robots.length; i++) {
      const r = robots[i].r;
      const c = robots[i].c;
      if (cells[r][c] === "robot_charging" && robotCharge[i] < 100) {
        robotCharge[i] = Math.min(100, robotCharge[i] + CONFIG.chargeGainPerTick);
        needsRender = true;
      }
    }

    updateChargeDisplay();
    if (needsRender) renderGrid();
  }

  function updateTimerDisplay() {
    const mins = Math.floor(timer / 60).toString().padStart(2, '0');
    const secs = (timer % 60).toString().padStart(2, '0');
    timerDisplay.textContent = `${mins}:${secs}`;
  }

  function updateChargeDisplay() {
    const avg = robotCharge.length ? (robotCharge.reduce((a, b) => a + b, 0) / robotCharge.length) : 0;
    chargeDisplay.textContent = Math.round(avg) + "%";
  }

  function endGame(win) {
    clearInterval(gameInterval);
    gameEnded = true;
    overlay.style.display = "flex";
    overlay.textContent = win ? "ПОБЕДА!" : "GAME OVER";
  }

  function resetGame() {
    clearInterval(gameInterval);
    gameStarted = false;
    gameEnded = false;
    timer = CONFIG.gameMinutes * 60;
    selectedRobot = null;
    overlay.style.display = "none"; // Убираем серый слой
    updateTimerDisplay();
    chargeDisplay.textContent = "-";
    initGrid(0); // Перезапускаем генерацию
  }

  newGameBtn.addEventListener("click", resetGame);
  window.onload = () => initGrid(0);
</script>
</body>
</html>
